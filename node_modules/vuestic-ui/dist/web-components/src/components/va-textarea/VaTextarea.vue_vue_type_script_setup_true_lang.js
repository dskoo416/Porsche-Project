import { defineComponent, shallowRef, computed, openBlock, createBlock, unref, mergeProps, withCtx, createElementVNode, normalizeClass, withDirectives, isRef, vModelText } from "vue";
import { p as pick } from "../../../vendor.js";
import { V as VaInputWrapper } from "../va-input-wrapper/index.js";
import { a as focusElement, b as blurElement } from "../../utils/focus.js";
import { e as extractComponentProps } from "../../utils/component-options/extract-component-options.js";
import { u as useFormFieldProps } from "../../composables/useFormField.js";
import { u as useStatefulProps, b as useStateful } from "../../composables/useStateful.js";
import { b as useValidationProps, u as useValidationEmits, a as useValidation } from "../../composables/useValidation.js";
import { f as filterComponentProps } from "../../utils/component-options/filter-props.js";
import { u as useEmitProxy } from "../../composables/useEmitProxy.js";
const _hoisted_1 = ["rows", "loading", "ariaLabel"];
const positiveNumberValidator = (val) => {
  if (val > 0 && (val | 0) === val) {
    return true;
  }
  throw new Error(`\`minRows|maxRows\` must be a positive integer greater than 0, but ${val} is provided`);
};
const { createEmits, createListeners } = useEmitProxy([
  "input",
  "change",
  "click",
  "update:modelValue"
]);
const VaInputWrapperProps = extractComponentProps(VaInputWrapper);
const _sfc_main = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaTextarea"
  },
  __name: "VaTextarea",
  props: {
    ...useFormFieldProps,
    ...VaInputWrapperProps,
    ...useStatefulProps,
    ...useValidationProps,
    modelValue: { type: [String, Number], default: "" },
    placeholder: { type: String },
    autosize: { type: Boolean, default: false },
    minRows: {
      type: [Number, String],
      default: 1,
      validator: positiveNumberValidator
    },
    maxRows: {
      type: [Number, String],
      validator: positiveNumberValidator
    },
    resize: {
      type: Boolean,
      default: true
    },
    clearValue: {
      type: [String],
      default: ""
    }
  },
  emits: [...createEmits(), ...useValidationEmits],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const textarea = shallowRef();
    const { valueComputed } = useStateful(props, emit, "modelValue", {
      defaultValue: ""
    });
    const focus = () => {
      focusElement(textarea.value);
    };
    const blur = () => {
      blurElement(textarea.value);
    };
    const reset = () => withoutValidation(() => {
      emit("update:modelValue", props.clearValue);
      emit("clear");
      resetValidation();
    });
    const {
      isDirty,
      computedError,
      computedErrorMessages,
      listeners: validationListeners,
      validationAriaAttributes,
      isLoading,
      resetValidation,
      withoutValidation
    } = useValidation(props, emit, {
      value: valueComputed,
      focus,
      reset
    });
    const isResizable = computed(() => {
      return props.resize && !props.autosize;
    });
    const computedRowsCount = computed(() => {
      if (!props.autosize) {
        return void 0;
      }
      const rows = valueComputed.value ? valueComputed.value.toString().split("\n").length : 1;
      if (!props.maxRows) {
        return rows;
      }
      return Math.max(Number(props.minRows), Math.min(rows, Number(props.maxRows)));
    });
    const computedStyle = computed(() => ({
      resize: isResizable.value ? void 0 : "none"
    }));
    const computedProps = computed(() => ({
      ...pick(props, ["disabled", "readonly", "placeholder", "ariaLabel"])
    }));
    const vaInputWrapperProps = filterComponentProps(VaInputWrapperProps);
    const listeners = createListeners(emit);
    __expose({
      isDirty,
      isLoading,
      computedError,
      computedErrorMessages,
      reset,
      focus,
      blur,
      value: valueComputed,
      withoutValidation,
      resetValidation
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(VaInputWrapper), mergeProps({ class: "va-textarea" }, unref(vaInputWrapperProps), {
        error: unref(computedError),
        "error-messages": unref(computedErrorMessages)
      }), {
        default: withCtx(() => [
          createElementVNode("div", {
            class: normalizeClass(["va-textarea__resize-wrapper", {
              "va-textarea__resize-wrapper--resizable": isResizable.value
            }])
          }, [
            withDirectives(createElementVNode("textarea", mergeProps({
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => isRef(valueComputed) ? valueComputed.value = $event : null)
            }, { ...computedProps.value, ...unref(listeners), ...unref(validationAriaAttributes) }, {
              style: computedStyle.value,
              rows: computedRowsCount.value,
              loading: unref(isLoading),
              ref_key: "textarea",
              ref: textarea,
              ariaLabel: _ctx.$props.label,
              class: "va-textarea__textarea",
              onFocus: _cache[1] || (_cache[1] = //@ts-ignore
              (...args) => unref(validationListeners).onFocus && unref(validationListeners).onFocus(...args)),
              onBlur: _cache[2] || (_cache[2] = //@ts-ignore
              (...args) => unref(validationListeners).onBlur && unref(validationListeners).onBlur(...args))
            }), null, 16, _hoisted_1), [
              [vModelText, unref(valueComputed)]
            ])
          ], 2)
        ]),
        _: 1
      }, 16, ["error", "error-messages"]);
    };
  }
});
export {
  _sfc_main as _
};
//# sourceMappingURL=VaTextarea.vue_vue_type_script_setup_true_lang.js.map
