import {
  cleave_esm_default,
  nt,
  useFloating
} from "./chunk-SQMMOFAG.js";
import {
  autoUpdate,
  flip,
  offset,
  shift,
  size
} from "./chunk-Q6EJMJMY.js";
import {
  Comment,
  Fragment,
  Suspense,
  Teleport,
  Text,
  Transition,
  TransitionGroup,
  capitalize,
  computed,
  createBaseVNode,
  createBlock,
  createCommentVNode,
  createElementBlock,
  createSlots,
  createTextVNode,
  createVNode,
  defineComponent,
  defineCustomElement,
  getCurrentInstance,
  guardReactiveProps,
  h,
  inject,
  isRef,
  mergeProps,
  nextTick,
  normalizeClass,
  normalizeProps,
  normalizeStyle,
  onBeforeMount,
  onBeforeUnmount,
  onBeforeUpdate,
  onMounted,
  onUpdated,
  openBlock,
  provide,
  reactive,
  ref,
  render,
  renderList,
  renderSlot,
  resolveComponent,
  resolveDynamicComponent,
  shallowReactive,
  shallowReadonly,
  shallowRef,
  toDisplayString,
  toHandlers,
  toRef,
  toRefs,
  unref,
  useAttrs,
  useCssVars,
  useSlots,
  vModelDynamic,
  vModelText,
  vShow,
  watch,
  watchEffect,
  withCtx,
  withDirectives,
  withKeys,
  withModifiers
} from "./chunk-WRCYRYJU.js";
import "./chunk-E3EO7R6B.js";

// node_modules/vuestic-ui/dist/web-components/src/services/color/presets.js
var presets = {
  light: {
    // Accent
    primary: "#154EC1",
    secondary: "#767C88",
    success: "#3D9209",
    info: "#158DE3",
    danger: "#E42222",
    warning: "#FFD43A",
    // Background Colors
    backgroundPrimary: "#f6f6f6",
    backgroundSecondary: "#FFFFFF",
    backgroundElement: "#ECF0F1",
    backgroundBorder: "#DEE5F2",
    // Text Colors
    textPrimary: "#262824",
    textInverted: "#FFFFFF",
    // Misc
    shadow: "rgba(0, 0, 0, 0.12)",
    focus: "#49A8FF",
    transparent: "rgba(0, 0, 0, 0)"
  },
  dark: {
    // Accent
    primary: "#3472F0",
    secondary: "#767C88",
    success: "#66BE33",
    info: "#3EAAF8",
    danger: "#F34030",
    warning: "#FFD952",
    // Background Colors
    backgroundPrimary: "#050A10",
    backgroundSecondary: "#1F262F",
    backgroundElement: "#131A22",
    backgroundBorder: "#3D4C58",
    // Text Colors
    textPrimary: "#F1F1F1",
    textInverted: "#0B121A",
    // Misc
    shadow: "rgba(255, 255, 255, 0.12)",
    focus: "#49A8FF",
    transparent: "rgba(0, 0, 0, 0)"
  }
};

// node_modules/vuestic-ui/dist/web-components/src/services/breakpoint/index.js
var vaBreakpointSymbol = Symbol("vaBreakpoint");
var defaultThresholds = {
  xs: 0,
  sm: 640,
  md: 1024,
  lg: 1440,
  xl: 1920
};
var getBreakpointDefaultConfig = () => ({
  enabled: true,
  bodyClass: true,
  thresholds: defaultThresholds
});

// node_modules/vuestic-ui/dist/web-components/src/services/global-config/types.js
var defineVuesticConfig = (config) => config;

// node_modules/vuestic-ui/dist/web-components/src/composables/useComponentPreset.js
var useComponentPresetProp = {
  preset: {
    type: String,
    default: void 0
  }
};

// node_modules/vuestic-ui/dist/web-components/src/composables/useLocalConfig.js
var LocalConfigKey = "VaLocalConfig";
var CONFIGS_DEFAULT = computed(() => []);
function useLocalConfig() {
  return inject(LocalConfigKey, CONFIGS_DEFAULT);
}
function provideLocalConfig(config) {
  provide(LocalConfigKey, config);
}
function useLocalConfigProvider(config) {
  const prevChain = useLocalConfig();
  const nextChain = computed(() => [...prevChain.value, config.value]);
  provideLocalConfig(nextChain);
}

// node_modules/vuestic-ui/dist/web-components/src/utils/merge-deep.js
var isObject = (obj) => obj && typeof obj === "object" && !Array.isArray(obj);
var mergeDeep = (target, source) => {
  if (!isObject(target) || !isObject(source)) {
    return source;
  }
  Object.keys(source).forEach((key) => {
    const targetValue = target[key];
    const sourceValue = source[key];
    if (isObject(targetValue) && isObject(sourceValue)) {
      target[key] = mergeDeep(Object.create(
        Object.getPrototypeOf(targetValue),
        Object.getOwnPropertyDescriptors(targetValue)
      ), sourceValue);
    } else {
      target[key] = sourceValue;
    }
  });
  return target;
};

// node_modules/vuestic-ui/dist/web-components/__commonjsHelpers__.js
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}

// node_modules/vuestic-ui/dist/web-components/vendor.js
function listCacheClear$1() {
  this.__data__ = [];
  this.size = 0;
}
var _listCacheClear = listCacheClear$1;
function eq$4(value, other) {
  return value === other || value !== value && other !== other;
}
var eq_1 = eq$4;
var eq$3 = eq_1;
function assocIndexOf$4(array, key) {
  var length = array.length;
  while (length--) {
    if (eq$3(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}
var _assocIndexOf = assocIndexOf$4;
var assocIndexOf$3 = _assocIndexOf;
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete$1(key) {
  var data = this.__data__, index = assocIndexOf$3(data, key);
  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}
var _listCacheDelete = listCacheDelete$1;
var assocIndexOf$2 = _assocIndexOf;
function listCacheGet$1(key) {
  var data = this.__data__, index = assocIndexOf$2(data, key);
  return index < 0 ? void 0 : data[index][1];
}
var _listCacheGet = listCacheGet$1;
var assocIndexOf$1 = _assocIndexOf;
function listCacheHas$1(key) {
  return assocIndexOf$1(this.__data__, key) > -1;
}
var _listCacheHas = listCacheHas$1;
var assocIndexOf = _assocIndexOf;
function listCacheSet$1(key, value) {
  var data = this.__data__, index = assocIndexOf(data, key);
  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}
var _listCacheSet = listCacheSet$1;
var listCacheClear = _listCacheClear;
var listCacheDelete = _listCacheDelete;
var listCacheGet = _listCacheGet;
var listCacheHas = _listCacheHas;
var listCacheSet = _listCacheSet;
function ListCache$4(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
ListCache$4.prototype.clear = listCacheClear;
ListCache$4.prototype["delete"] = listCacheDelete;
ListCache$4.prototype.get = listCacheGet;
ListCache$4.prototype.has = listCacheHas;
ListCache$4.prototype.set = listCacheSet;
var _ListCache = ListCache$4;
var ListCache$3 = _ListCache;
function stackClear$1() {
  this.__data__ = new ListCache$3();
  this.size = 0;
}
var _stackClear = stackClear$1;
function stackDelete$1(key) {
  var data = this.__data__, result = data["delete"](key);
  this.size = data.size;
  return result;
}
var _stackDelete = stackDelete$1;
function stackGet$1(key) {
  return this.__data__.get(key);
}
var _stackGet = stackGet$1;
function stackHas$1(key) {
  return this.__data__.has(key);
}
var _stackHas = stackHas$1;
var freeGlobal$1 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
var _freeGlobal = freeGlobal$1;
var freeGlobal = _freeGlobal;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root$9 = freeGlobal || freeSelf || Function("return this")();
var _root = root$9;
var root$8 = _root;
var Symbol$6 = root$8.Symbol;
var _Symbol = Symbol$6;
var Symbol$5 = _Symbol;
var objectProto$d = Object.prototype;
var hasOwnProperty$a = objectProto$d.hasOwnProperty;
var nativeObjectToString$1 = objectProto$d.toString;
var symToStringTag$1 = Symbol$5 ? Symbol$5.toStringTag : void 0;
function getRawTag$1(value) {
  var isOwn = hasOwnProperty$a.call(value, symToStringTag$1), tag = value[symToStringTag$1];
  try {
    value[symToStringTag$1] = void 0;
    var unmasked = true;
  } catch (e) {
  }
  var result = nativeObjectToString$1.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result;
}
var _getRawTag = getRawTag$1;
var objectProto$c = Object.prototype;
var nativeObjectToString = objectProto$c.toString;
function objectToString$1(value) {
  return nativeObjectToString.call(value);
}
var _objectToString = objectToString$1;
var Symbol$4 = _Symbol;
var getRawTag = _getRawTag;
var objectToString = _objectToString;
var nullTag = "[object Null]";
var undefinedTag = "[object Undefined]";
var symToStringTag = Symbol$4 ? Symbol$4.toStringTag : void 0;
function baseGetTag$9(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}
var _baseGetTag = baseGetTag$9;
function isObject$c(value) {
  var type = typeof value;
  return value != null && (type == "object" || type == "function");
}
var isObject_1 = isObject$c;
var isObject$d = getDefaultExportFromCjs(isObject_1);
var baseGetTag$8 = _baseGetTag;
var isObject$b = isObject_1;
var asyncTag = "[object AsyncFunction]";
var funcTag$2 = "[object Function]";
var genTag$1 = "[object GeneratorFunction]";
var proxyTag = "[object Proxy]";
function isFunction$3(value) {
  if (!isObject$b(value)) {
    return false;
  }
  var tag = baseGetTag$8(value);
  return tag == funcTag$2 || tag == genTag$1 || tag == asyncTag || tag == proxyTag;
}
var isFunction_1 = isFunction$3;
var isFunction$4 = getDefaultExportFromCjs(isFunction_1);
var root$7 = _root;
var coreJsData$1 = root$7["__core-js_shared__"];
var _coreJsData = coreJsData$1;
var coreJsData = _coreJsData;
var maskSrcKey = function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
}();
function isMasked$1(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var _isMasked = isMasked$1;
var funcProto$2 = Function.prototype;
var funcToString$2 = funcProto$2.toString;
function toSource$2(func) {
  if (func != null) {
    try {
      return funcToString$2.call(func);
    } catch (e) {
    }
    try {
      return func + "";
    } catch (e) {
    }
  }
  return "";
}
var _toSource = toSource$2;
var isFunction$2 = isFunction_1;
var isMasked = _isMasked;
var isObject$a = isObject_1;
var toSource$1 = _toSource;
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto$1 = Function.prototype;
var objectProto$b = Object.prototype;
var funcToString$1 = funcProto$1.toString;
var hasOwnProperty$9 = objectProto$b.hasOwnProperty;
var reIsNative = RegExp(
  "^" + funcToString$1.call(hasOwnProperty$9).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function baseIsNative$1(value) {
  if (!isObject$a(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction$2(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource$1(value));
}
var _baseIsNative = baseIsNative$1;
function getValue$1(object, key) {
  return object == null ? void 0 : object[key];
}
var _getValue = getValue$1;
var baseIsNative = _baseIsNative;
var getValue = _getValue;
function getNative$7(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : void 0;
}
var _getNative = getNative$7;
var getNative$6 = _getNative;
var root$6 = _root;
var Map$3 = getNative$6(root$6, "Map");
var _Map = Map$3;
var getNative$5 = _getNative;
var nativeCreate$4 = getNative$5(Object, "create");
var _nativeCreate = nativeCreate$4;
var nativeCreate$3 = _nativeCreate;
function hashClear$1() {
  this.__data__ = nativeCreate$3 ? nativeCreate$3(null) : {};
  this.size = 0;
}
var _hashClear = hashClear$1;
function hashDelete$1(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}
var _hashDelete = hashDelete$1;
var nativeCreate$2 = _nativeCreate;
var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
var objectProto$a = Object.prototype;
var hasOwnProperty$8 = objectProto$a.hasOwnProperty;
function hashGet$1(key) {
  var data = this.__data__;
  if (nativeCreate$2) {
    var result = data[key];
    return result === HASH_UNDEFINED$1 ? void 0 : result;
  }
  return hasOwnProperty$8.call(data, key) ? data[key] : void 0;
}
var _hashGet = hashGet$1;
var nativeCreate$1 = _nativeCreate;
var objectProto$9 = Object.prototype;
var hasOwnProperty$7 = objectProto$9.hasOwnProperty;
function hashHas$1(key) {
  var data = this.__data__;
  return nativeCreate$1 ? data[key] !== void 0 : hasOwnProperty$7.call(data, key);
}
var _hashHas = hashHas$1;
var nativeCreate = _nativeCreate;
var HASH_UNDEFINED = "__lodash_hash_undefined__";
function hashSet$1(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
  return this;
}
var _hashSet = hashSet$1;
var hashClear = _hashClear;
var hashDelete = _hashDelete;
var hashGet = _hashGet;
var hashHas = _hashHas;
var hashSet = _hashSet;
function Hash$1(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
Hash$1.prototype.clear = hashClear;
Hash$1.prototype["delete"] = hashDelete;
Hash$1.prototype.get = hashGet;
Hash$1.prototype.has = hashHas;
Hash$1.prototype.set = hashSet;
var _Hash = Hash$1;
var Hash = _Hash;
var ListCache$2 = _ListCache;
var Map$2 = _Map;
function mapCacheClear$1() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash(),
    "map": new (Map$2 || ListCache$2)(),
    "string": new Hash()
  };
}
var _mapCacheClear = mapCacheClear$1;
function isKeyable$1(value) {
  var type = typeof value;
  return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
var _isKeyable = isKeyable$1;
var isKeyable = _isKeyable;
function getMapData$4(map, key) {
  var data = map.__data__;
  return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
var _getMapData = getMapData$4;
var getMapData$3 = _getMapData;
function mapCacheDelete$1(key) {
  var result = getMapData$3(this, key)["delete"](key);
  this.size -= result ? 1 : 0;
  return result;
}
var _mapCacheDelete = mapCacheDelete$1;
var getMapData$2 = _getMapData;
function mapCacheGet$1(key) {
  return getMapData$2(this, key).get(key);
}
var _mapCacheGet = mapCacheGet$1;
var getMapData$1 = _getMapData;
function mapCacheHas$1(key) {
  return getMapData$1(this, key).has(key);
}
var _mapCacheHas = mapCacheHas$1;
var getMapData = _getMapData;
function mapCacheSet$1(key, value) {
  var data = getMapData(this, key), size2 = data.size;
  data.set(key, value);
  this.size += data.size == size2 ? 0 : 1;
  return this;
}
var _mapCacheSet = mapCacheSet$1;
var mapCacheClear = _mapCacheClear;
var mapCacheDelete = _mapCacheDelete;
var mapCacheGet = _mapCacheGet;
var mapCacheHas = _mapCacheHas;
var mapCacheSet = _mapCacheSet;
function MapCache$2(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
MapCache$2.prototype.clear = mapCacheClear;
MapCache$2.prototype["delete"] = mapCacheDelete;
MapCache$2.prototype.get = mapCacheGet;
MapCache$2.prototype.has = mapCacheHas;
MapCache$2.prototype.set = mapCacheSet;
var _MapCache = MapCache$2;
var ListCache$1 = _ListCache;
var Map$1 = _Map;
var MapCache$1 = _MapCache;
var LARGE_ARRAY_SIZE = 200;
function stackSet$1(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache$1) {
    var pairs = data.__data__;
    if (!Map$1 || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache$1(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}
var _stackSet = stackSet$1;
var ListCache = _ListCache;
var stackClear = _stackClear;
var stackDelete = _stackDelete;
var stackGet = _stackGet;
var stackHas = _stackHas;
var stackSet = _stackSet;
function Stack$2(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}
Stack$2.prototype.clear = stackClear;
Stack$2.prototype["delete"] = stackDelete;
Stack$2.prototype.get = stackGet;
Stack$2.prototype.has = stackHas;
Stack$2.prototype.set = stackSet;
var _Stack = Stack$2;
function arrayEach$1(array, iteratee) {
  var index = -1, length = array == null ? 0 : array.length;
  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}
var _arrayEach = arrayEach$1;
var getNative$4 = _getNative;
var defineProperty$2 = function() {
  try {
    var func = getNative$4(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e) {
  }
}();
var _defineProperty = defineProperty$2;
var defineProperty$1 = _defineProperty;
function baseAssignValue$3(object, key, value) {
  if (key == "__proto__" && defineProperty$1) {
    defineProperty$1(object, key, {
      "configurable": true,
      "enumerable": true,
      "value": value,
      "writable": true
    });
  } else {
    object[key] = value;
  }
}
var _baseAssignValue = baseAssignValue$3;
var baseAssignValue$2 = _baseAssignValue;
var eq$2 = eq_1;
var objectProto$8 = Object.prototype;
var hasOwnProperty$6 = objectProto$8.hasOwnProperty;
function assignValue$3(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty$6.call(object, key) && eq$2(objValue, value)) || value === void 0 && !(key in object)) {
    baseAssignValue$2(object, key, value);
  }
}
var _assignValue = assignValue$3;
var assignValue$2 = _assignValue;
var baseAssignValue$1 = _baseAssignValue;
function copyObject$6(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});
  var index = -1, length = props.length;
  while (++index < length) {
    var key = props[index];
    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
    if (newValue === void 0) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue$1(object, key, newValue);
    } else {
      assignValue$2(object, key, newValue);
    }
  }
  return object;
}
var _copyObject = copyObject$6;
function baseTimes$1(n, iteratee) {
  var index = -1, result = Array(n);
  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}
var _baseTimes = baseTimes$1;
function isObjectLike$b(value) {
  return value != null && typeof value == "object";
}
var isObjectLike_1 = isObjectLike$b;
var baseGetTag$7 = _baseGetTag;
var isObjectLike$a = isObjectLike_1;
var argsTag$2 = "[object Arguments]";
function baseIsArguments$1(value) {
  return isObjectLike$a(value) && baseGetTag$7(value) == argsTag$2;
}
var _baseIsArguments = baseIsArguments$1;
var baseIsArguments = _baseIsArguments;
var isObjectLike$9 = isObjectLike_1;
var objectProto$7 = Object.prototype;
var hasOwnProperty$5 = objectProto$7.hasOwnProperty;
var propertyIsEnumerable$1 = objectProto$7.propertyIsEnumerable;
var isArguments$4 = baseIsArguments(function() {
  return arguments;
}()) ? baseIsArguments : function(value) {
  return isObjectLike$9(value) && hasOwnProperty$5.call(value, "callee") && !propertyIsEnumerable$1.call(value, "callee");
};
var isArguments_1 = isArguments$4;
var isArray$a = Array.isArray;
var isArray_1 = isArray$a;
var isBuffer$3 = { exports: {} };
function stubFalse() {
  return false;
}
var stubFalse_1 = stubFalse;
isBuffer$3.exports;
(function(module, exports) {
  var root2 = _root, stubFalse2 = stubFalse_1;
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var Buffer = moduleExports ? root2.Buffer : void 0;
  var nativeIsBuffer = Buffer ? Buffer.isBuffer : void 0;
  var isBuffer2 = nativeIsBuffer || stubFalse2;
  module.exports = isBuffer2;
})(isBuffer$3, isBuffer$3.exports);
var isBufferExports = isBuffer$3.exports;
var MAX_SAFE_INTEGER$1 = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex$4(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER$1 : length;
  return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
}
var _isIndex = isIndex$4;
var MAX_SAFE_INTEGER = 9007199254740991;
function isLength$3(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}
var isLength_1 = isLength$3;
var baseGetTag$6 = _baseGetTag;
var isLength$2 = isLength_1;
var isObjectLike$8 = isObjectLike_1;
var argsTag$1 = "[object Arguments]";
var arrayTag$1 = "[object Array]";
var boolTag$2 = "[object Boolean]";
var dateTag$3 = "[object Date]";
var errorTag$1 = "[object Error]";
var funcTag$1 = "[object Function]";
var mapTag$4 = "[object Map]";
var numberTag$3 = "[object Number]";
var objectTag$3 = "[object Object]";
var regexpTag$2 = "[object RegExp]";
var setTag$4 = "[object Set]";
var stringTag$3 = "[object String]";
var weakMapTag$2 = "[object WeakMap]";
var arrayBufferTag$2 = "[object ArrayBuffer]";
var dataViewTag$3 = "[object DataView]";
var float32Tag$2 = "[object Float32Array]";
var float64Tag$2 = "[object Float64Array]";
var int8Tag$2 = "[object Int8Array]";
var int16Tag$2 = "[object Int16Array]";
var int32Tag$2 = "[object Int32Array]";
var uint8Tag$2 = "[object Uint8Array]";
var uint8ClampedTag$2 = "[object Uint8ClampedArray]";
var uint16Tag$2 = "[object Uint16Array]";
var uint32Tag$2 = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] = typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] = typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] = typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] = typedArrayTags[uint32Tag$2] = true;
typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] = typedArrayTags[arrayBufferTag$2] = typedArrayTags[boolTag$2] = typedArrayTags[dataViewTag$3] = typedArrayTags[dateTag$3] = typedArrayTags[errorTag$1] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag$4] = typedArrayTags[numberTag$3] = typedArrayTags[objectTag$3] = typedArrayTags[regexpTag$2] = typedArrayTags[setTag$4] = typedArrayTags[stringTag$3] = typedArrayTags[weakMapTag$2] = false;
function baseIsTypedArray$1(value) {
  return isObjectLike$8(value) && isLength$2(value.length) && !!typedArrayTags[baseGetTag$6(value)];
}
var _baseIsTypedArray = baseIsTypedArray$1;
function baseUnary$4(func) {
  return function(value) {
    return func(value);
  };
}
var _baseUnary = baseUnary$4;
var _nodeUtil = { exports: {} };
_nodeUtil.exports;
(function(module, exports) {
  var freeGlobal2 = _freeGlobal;
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var freeProcess = moduleExports && freeGlobal2.process;
  var nodeUtil2 = function() {
    try {
      var types = freeModule && freeModule.require && freeModule.require("util").types;
      if (types) {
        return types;
      }
      return freeProcess && freeProcess.binding && freeProcess.binding("util");
    } catch (e) {
    }
  }();
  module.exports = nodeUtil2;
})(_nodeUtil, _nodeUtil.exports);
var _nodeUtilExports = _nodeUtil.exports;
var baseIsTypedArray = _baseIsTypedArray;
var baseUnary$3 = _baseUnary;
var nodeUtil$3 = _nodeUtilExports;
var nodeIsTypedArray = nodeUtil$3 && nodeUtil$3.isTypedArray;
var isTypedArray$2 = nodeIsTypedArray ? baseUnary$3(nodeIsTypedArray) : baseIsTypedArray;
var isTypedArray_1 = isTypedArray$2;
var baseTimes = _baseTimes;
var isArguments$3 = isArguments_1;
var isArray$9 = isArray_1;
var isBuffer$2 = isBufferExports;
var isIndex$3 = _isIndex;
var isTypedArray$1 = isTypedArray_1;
var objectProto$6 = Object.prototype;
var hasOwnProperty$4 = objectProto$6.hasOwnProperty;
function arrayLikeKeys$2(value, inherited) {
  var isArr = isArray$9(value), isArg = !isArr && isArguments$3(value), isBuff = !isArr && !isArg && isBuffer$2(value), isType = !isArr && !isArg && !isBuff && isTypedArray$1(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
  for (var key in value) {
    if ((inherited || hasOwnProperty$4.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
    (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
    isIndex$3(key, length)))) {
      result.push(key);
    }
  }
  return result;
}
var _arrayLikeKeys = arrayLikeKeys$2;
var objectProto$5 = Object.prototype;
function isPrototype$3(value) {
  var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$5;
  return value === proto;
}
var _isPrototype = isPrototype$3;
function overArg$2(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}
var _overArg = overArg$2;
var overArg$1 = _overArg;
var nativeKeys$1 = overArg$1(Object.keys, Object);
var _nativeKeys = nativeKeys$1;
var isPrototype$2 = _isPrototype;
var nativeKeys = _nativeKeys;
var objectProto$4 = Object.prototype;
var hasOwnProperty$3 = objectProto$4.hasOwnProperty;
function baseKeys$1(object) {
  if (!isPrototype$2(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty$3.call(object, key) && key != "constructor") {
      result.push(key);
    }
  }
  return result;
}
var _baseKeys = baseKeys$1;
var isFunction$1 = isFunction_1;
var isLength$1 = isLength_1;
function isArrayLike$4(value) {
  return value != null && isLength$1(value.length) && !isFunction$1(value);
}
var isArrayLike_1 = isArrayLike$4;
var arrayLikeKeys$1 = _arrayLikeKeys;
var baseKeys = _baseKeys;
var isArrayLike$3 = isArrayLike_1;
function keys$3(object) {
  return isArrayLike$3(object) ? arrayLikeKeys$1(object) : baseKeys(object);
}
var keys_1 = keys$3;
var copyObject$5 = _copyObject;
var keys$2 = keys_1;
function baseAssign$1(object, source) {
  return object && copyObject$5(source, keys$2(source), object);
}
var _baseAssign = baseAssign$1;
function nativeKeysIn$1(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}
var _nativeKeysIn = nativeKeysIn$1;
var isObject$9 = isObject_1;
var isPrototype$1 = _isPrototype;
var nativeKeysIn = _nativeKeysIn;
var objectProto$3 = Object.prototype;
var hasOwnProperty$2 = objectProto$3.hasOwnProperty;
function baseKeysIn$1(object) {
  if (!isObject$9(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype$1(object), result = [];
  for (var key in object) {
    if (!(key == "constructor" && (isProto || !hasOwnProperty$2.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}
var _baseKeysIn = baseKeysIn$1;
var arrayLikeKeys = _arrayLikeKeys;
var baseKeysIn = _baseKeysIn;
var isArrayLike$2 = isArrayLike_1;
function keysIn$5(object) {
  return isArrayLike$2(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}
var keysIn_1 = keysIn$5;
var copyObject$4 = _copyObject;
var keysIn$4 = keysIn_1;
function baseAssignIn$1(object, source) {
  return object && copyObject$4(source, keysIn$4(source), object);
}
var _baseAssignIn = baseAssignIn$1;
var _cloneBuffer = { exports: {} };
_cloneBuffer.exports;
(function(module, exports) {
  var root2 = _root;
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var Buffer = moduleExports ? root2.Buffer : void 0, allocUnsafe = Buffer ? Buffer.allocUnsafe : void 0;
  function cloneBuffer2(buffer, isDeep) {
    if (isDeep) {
      return buffer.slice();
    }
    var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
    buffer.copy(result);
    return result;
  }
  module.exports = cloneBuffer2;
})(_cloneBuffer, _cloneBuffer.exports);
var _cloneBufferExports = _cloneBuffer.exports;
function copyArray$2(source, array) {
  var index = -1, length = source.length;
  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}
var _copyArray = copyArray$2;
function arrayFilter$1(array, predicate) {
  var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}
var _arrayFilter = arrayFilter$1;
function stubArray$2() {
  return [];
}
var stubArray_1 = stubArray$2;
var arrayFilter = _arrayFilter;
var stubArray$1 = stubArray_1;
var objectProto$2 = Object.prototype;
var propertyIsEnumerable = objectProto$2.propertyIsEnumerable;
var nativeGetSymbols$1 = Object.getOwnPropertySymbols;
var getSymbols$3 = !nativeGetSymbols$1 ? stubArray$1 : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols$1(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};
var _getSymbols = getSymbols$3;
var copyObject$3 = _copyObject;
var getSymbols$2 = _getSymbols;
function copySymbols$1(source, object) {
  return copyObject$3(source, getSymbols$2(source), object);
}
var _copySymbols = copySymbols$1;
function arrayPush$3(array, values) {
  var index = -1, length = values.length, offset2 = array.length;
  while (++index < length) {
    array[offset2 + index] = values[index];
  }
  return array;
}
var _arrayPush = arrayPush$3;
var overArg = _overArg;
var getPrototype$3 = overArg(Object.getPrototypeOf, Object);
var _getPrototype = getPrototype$3;
var arrayPush$2 = _arrayPush;
var getPrototype$2 = _getPrototype;
var getSymbols$1 = _getSymbols;
var stubArray = stubArray_1;
var nativeGetSymbols = Object.getOwnPropertySymbols;
var getSymbolsIn$2 = !nativeGetSymbols ? stubArray : function(object) {
  var result = [];
  while (object) {
    arrayPush$2(result, getSymbols$1(object));
    object = getPrototype$2(object);
  }
  return result;
};
var _getSymbolsIn = getSymbolsIn$2;
var copyObject$2 = _copyObject;
var getSymbolsIn$1 = _getSymbolsIn;
function copySymbolsIn$1(source, object) {
  return copyObject$2(source, getSymbolsIn$1(source), object);
}
var _copySymbolsIn = copySymbolsIn$1;
var arrayPush$1 = _arrayPush;
var isArray$8 = isArray_1;
function baseGetAllKeys$2(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray$8(object) ? result : arrayPush$1(result, symbolsFunc(object));
}
var _baseGetAllKeys = baseGetAllKeys$2;
var baseGetAllKeys$1 = _baseGetAllKeys;
var getSymbols = _getSymbols;
var keys$1 = keys_1;
function getAllKeys$1(object) {
  return baseGetAllKeys$1(object, keys$1, getSymbols);
}
var _getAllKeys = getAllKeys$1;
var baseGetAllKeys = _baseGetAllKeys;
var getSymbolsIn = _getSymbolsIn;
var keysIn$3 = keysIn_1;
function getAllKeysIn$2(object) {
  return baseGetAllKeys(object, keysIn$3, getSymbolsIn);
}
var _getAllKeysIn = getAllKeysIn$2;
var getNative$3 = _getNative;
var root$5 = _root;
var DataView$1 = getNative$3(root$5, "DataView");
var _DataView = DataView$1;
var getNative$2 = _getNative;
var root$4 = _root;
var Promise$2 = getNative$2(root$4, "Promise");
var _Promise = Promise$2;
var getNative$1 = _getNative;
var root$3 = _root;
var Set$1 = getNative$1(root$3, "Set");
var _Set = Set$1;
var getNative = _getNative;
var root$2 = _root;
var WeakMap$1 = getNative(root$2, "WeakMap");
var _WeakMap = WeakMap$1;
var DataView = _DataView;
var Map2 = _Map;
var Promise$1 = _Promise;
var Set2 = _Set;
var WeakMap = _WeakMap;
var baseGetTag$5 = _baseGetTag;
var toSource = _toSource;
var mapTag$3 = "[object Map]";
var objectTag$2 = "[object Object]";
var promiseTag = "[object Promise]";
var setTag$3 = "[object Set]";
var weakMapTag$1 = "[object WeakMap]";
var dataViewTag$2 = "[object DataView]";
var dataViewCtorString = toSource(DataView);
var mapCtorString = toSource(Map2);
var promiseCtorString = toSource(Promise$1);
var setCtorString = toSource(Set2);
var weakMapCtorString = toSource(WeakMap);
var getTag$3 = baseGetTag$5;
if (DataView && getTag$3(new DataView(new ArrayBuffer(1))) != dataViewTag$2 || Map2 && getTag$3(new Map2()) != mapTag$3 || Promise$1 && getTag$3(Promise$1.resolve()) != promiseTag || Set2 && getTag$3(new Set2()) != setTag$3 || WeakMap && getTag$3(new WeakMap()) != weakMapTag$1) {
  getTag$3 = function(value) {
    var result = baseGetTag$5(value), Ctor = result == objectTag$2 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag$2;
        case mapCtorString:
          return mapTag$3;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag$3;
        case weakMapCtorString:
          return weakMapTag$1;
      }
    }
    return result;
  };
}
var _getTag = getTag$3;
var objectProto$1 = Object.prototype;
var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
function initCloneArray$1(array) {
  var length = array.length, result = new array.constructor(length);
  if (length && typeof array[0] == "string" && hasOwnProperty$1.call(array, "index")) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}
var _initCloneArray = initCloneArray$1;
var root$1 = _root;
var Uint8Array$1 = root$1.Uint8Array;
var _Uint8Array = Uint8Array$1;
var Uint8Array = _Uint8Array;
function cloneArrayBuffer$3(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}
var _cloneArrayBuffer = cloneArrayBuffer$3;
var cloneArrayBuffer$2 = _cloneArrayBuffer;
function cloneDataView$1(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer$2(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}
var _cloneDataView = cloneDataView$1;
var reFlags = /\w*$/;
function cloneRegExp$1(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}
var _cloneRegExp = cloneRegExp$1;
var Symbol$3 = _Symbol;
var symbolProto$1 = Symbol$3 ? Symbol$3.prototype : void 0;
var symbolValueOf = symbolProto$1 ? symbolProto$1.valueOf : void 0;
function cloneSymbol$1(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}
var _cloneSymbol = cloneSymbol$1;
var cloneArrayBuffer$1 = _cloneArrayBuffer;
function cloneTypedArray$2(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer$1(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}
var _cloneTypedArray = cloneTypedArray$2;
var cloneArrayBuffer = _cloneArrayBuffer;
var cloneDataView = _cloneDataView;
var cloneRegExp = _cloneRegExp;
var cloneSymbol = _cloneSymbol;
var cloneTypedArray$1 = _cloneTypedArray;
var boolTag$1 = "[object Boolean]";
var dateTag$2 = "[object Date]";
var mapTag$2 = "[object Map]";
var numberTag$2 = "[object Number]";
var regexpTag$1 = "[object RegExp]";
var setTag$2 = "[object Set]";
var stringTag$2 = "[object String]";
var symbolTag$2 = "[object Symbol]";
var arrayBufferTag$1 = "[object ArrayBuffer]";
var dataViewTag$1 = "[object DataView]";
var float32Tag$1 = "[object Float32Array]";
var float64Tag$1 = "[object Float64Array]";
var int8Tag$1 = "[object Int8Array]";
var int16Tag$1 = "[object Int16Array]";
var int32Tag$1 = "[object Int32Array]";
var uint8Tag$1 = "[object Uint8Array]";
var uint8ClampedTag$1 = "[object Uint8ClampedArray]";
var uint16Tag$1 = "[object Uint16Array]";
var uint32Tag$1 = "[object Uint32Array]";
function initCloneByTag$1(object, tag, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag$1:
      return cloneArrayBuffer(object);
    case boolTag$1:
    case dateTag$2:
      return new Ctor(+object);
    case dataViewTag$1:
      return cloneDataView(object, isDeep);
    case float32Tag$1:
    case float64Tag$1:
    case int8Tag$1:
    case int16Tag$1:
    case int32Tag$1:
    case uint8Tag$1:
    case uint8ClampedTag$1:
    case uint16Tag$1:
    case uint32Tag$1:
      return cloneTypedArray$1(object, isDeep);
    case mapTag$2:
      return new Ctor();
    case numberTag$2:
    case stringTag$2:
      return new Ctor(object);
    case regexpTag$1:
      return cloneRegExp(object);
    case setTag$2:
      return new Ctor();
    case symbolTag$2:
      return cloneSymbol(object);
  }
}
var _initCloneByTag = initCloneByTag$1;
var isObject$8 = isObject_1;
var objectCreate = Object.create;
var baseCreate$1 = function() {
  function object() {
  }
  return function(proto) {
    if (!isObject$8(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object();
    object.prototype = void 0;
    return result;
  };
}();
var _baseCreate = baseCreate$1;
var baseCreate = _baseCreate;
var getPrototype$1 = _getPrototype;
var isPrototype = _isPrototype;
function initCloneObject$2(object) {
  return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype$1(object)) : {};
}
var _initCloneObject = initCloneObject$2;
var getTag$2 = _getTag;
var isObjectLike$7 = isObjectLike_1;
var mapTag$1 = "[object Map]";
function baseIsMap$1(value) {
  return isObjectLike$7(value) && getTag$2(value) == mapTag$1;
}
var _baseIsMap = baseIsMap$1;
var baseIsMap = _baseIsMap;
var baseUnary$2 = _baseUnary;
var nodeUtil$2 = _nodeUtilExports;
var nodeIsMap = nodeUtil$2 && nodeUtil$2.isMap;
var isMap$1 = nodeIsMap ? baseUnary$2(nodeIsMap) : baseIsMap;
var isMap_1 = isMap$1;
var getTag$1 = _getTag;
var isObjectLike$6 = isObjectLike_1;
var setTag$1 = "[object Set]";
function baseIsSet$1(value) {
  return isObjectLike$6(value) && getTag$1(value) == setTag$1;
}
var _baseIsSet = baseIsSet$1;
var baseIsSet = _baseIsSet;
var baseUnary$1 = _baseUnary;
var nodeUtil$1 = _nodeUtilExports;
var nodeIsSet = nodeUtil$1 && nodeUtil$1.isSet;
var isSet$1 = nodeIsSet ? baseUnary$1(nodeIsSet) : baseIsSet;
var isSet_1 = isSet$1;
var Stack$1 = _Stack;
var arrayEach = _arrayEach;
var assignValue$1 = _assignValue;
var baseAssign = _baseAssign;
var baseAssignIn = _baseAssignIn;
var cloneBuffer$1 = _cloneBufferExports;
var copyArray$1 = _copyArray;
var copySymbols = _copySymbols;
var copySymbolsIn = _copySymbolsIn;
var getAllKeys = _getAllKeys;
var getAllKeysIn$1 = _getAllKeysIn;
var getTag = _getTag;
var initCloneArray = _initCloneArray;
var initCloneByTag = _initCloneByTag;
var initCloneObject$1 = _initCloneObject;
var isArray$7 = isArray_1;
var isBuffer$1 = isBufferExports;
var isMap = isMap_1;
var isObject$7 = isObject_1;
var isSet = isSet_1;
var keys = keys_1;
var keysIn$2 = keysIn_1;
var CLONE_DEEP_FLAG$2 = 1;
var CLONE_FLAT_FLAG$1 = 2;
var CLONE_SYMBOLS_FLAG$2 = 4;
var argsTag = "[object Arguments]";
var arrayTag = "[object Array]";
var boolTag = "[object Boolean]";
var dateTag$1 = "[object Date]";
var errorTag = "[object Error]";
var funcTag = "[object Function]";
var genTag = "[object GeneratorFunction]";
var mapTag = "[object Map]";
var numberTag$1 = "[object Number]";
var objectTag$1 = "[object Object]";
var regexpTag = "[object RegExp]";
var setTag = "[object Set]";
var stringTag$1 = "[object String]";
var symbolTag$1 = "[object Symbol]";
var weakMapTag = "[object WeakMap]";
var arrayBufferTag = "[object ArrayBuffer]";
var dataViewTag = "[object DataView]";
var float32Tag = "[object Float32Array]";
var float64Tag = "[object Float64Array]";
var int8Tag = "[object Int8Array]";
var int16Tag = "[object Int16Array]";
var int32Tag = "[object Int32Array]";
var uint8Tag = "[object Uint8Array]";
var uint8ClampedTag = "[object Uint8ClampedArray]";
var uint16Tag = "[object Uint16Array]";
var uint32Tag = "[object Uint32Array]";
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag$1] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag$1] = cloneableTags[objectTag$1] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag$1] = cloneableTags[symbolTag$1] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
function baseClone$2(value, bitmask, customizer, key, object, stack) {
  var result, isDeep = bitmask & CLONE_DEEP_FLAG$2, isFlat = bitmask & CLONE_FLAT_FLAG$1, isFull = bitmask & CLONE_SYMBOLS_FLAG$2;
  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== void 0) {
    return result;
  }
  if (!isObject$7(value)) {
    return value;
  }
  var isArr = isArray$7(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray$1(value, result);
    }
  } else {
    var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
    if (isBuffer$1(value)) {
      return cloneBuffer$1(value, isDeep);
    }
    if (tag == objectTag$1 || tag == argsTag || isFunc && !object) {
      result = isFlat || isFunc ? {} : initCloneObject$1(value);
      if (!isDeep) {
        return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag(value, tag, isDeep);
    }
  }
  stack || (stack = new Stack$1());
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);
  if (isSet(value)) {
    value.forEach(function(subValue) {
      result.add(baseClone$2(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap(value)) {
    value.forEach(function(subValue, key2) {
      result.set(key2, baseClone$2(subValue, bitmask, customizer, key2, value, stack));
    });
  }
  var keysFunc = isFull ? isFlat ? getAllKeysIn$1 : getAllKeys : isFlat ? keysIn$2 : keys;
  var props = isArr ? void 0 : keysFunc(value);
  arrayEach(props || value, function(subValue, key2) {
    if (props) {
      key2 = subValue;
      subValue = value[key2];
    }
    assignValue$1(result, key2, baseClone$2(subValue, bitmask, customizer, key2, value, stack));
  });
  return result;
}
var _baseClone = baseClone$2;
var baseClone$1 = _baseClone;
var CLONE_DEEP_FLAG$1 = 1;
var CLONE_SYMBOLS_FLAG$1 = 4;
function cloneDeep(value) {
  return baseClone$1(value, CLONE_DEEP_FLAG$1 | CLONE_SYMBOLS_FLAG$1);
}
var cloneDeep_1 = cloneDeep;
var cloneDeep$1 = getDefaultExportFromCjs(cloneDeep_1);
function arrayReduce$1(array, iteratee, accumulator, initAccum) {
  var index = -1, length = array == null ? 0 : array.length;
  if (initAccum && length) {
    accumulator = array[++index];
  }
  while (++index < length) {
    accumulator = iteratee(accumulator, array[index], index, array);
  }
  return accumulator;
}
var _arrayReduce = arrayReduce$1;
function basePropertyOf$1(object) {
  return function(key) {
    return object == null ? void 0 : object[key];
  };
}
var _basePropertyOf = basePropertyOf$1;
var basePropertyOf = _basePropertyOf;
var deburredLetters = {
  // Latin-1 Supplement block.
  "À": "A",
  "Á": "A",
  "Â": "A",
  "Ã": "A",
  "Ä": "A",
  "Å": "A",
  "à": "a",
  "á": "a",
  "â": "a",
  "ã": "a",
  "ä": "a",
  "å": "a",
  "Ç": "C",
  "ç": "c",
  "Ð": "D",
  "ð": "d",
  "È": "E",
  "É": "E",
  "Ê": "E",
  "Ë": "E",
  "è": "e",
  "é": "e",
  "ê": "e",
  "ë": "e",
  "Ì": "I",
  "Í": "I",
  "Î": "I",
  "Ï": "I",
  "ì": "i",
  "í": "i",
  "î": "i",
  "ï": "i",
  "Ñ": "N",
  "ñ": "n",
  "Ò": "O",
  "Ó": "O",
  "Ô": "O",
  "Õ": "O",
  "Ö": "O",
  "Ø": "O",
  "ò": "o",
  "ó": "o",
  "ô": "o",
  "õ": "o",
  "ö": "o",
  "ø": "o",
  "Ù": "U",
  "Ú": "U",
  "Û": "U",
  "Ü": "U",
  "ù": "u",
  "ú": "u",
  "û": "u",
  "ü": "u",
  "Ý": "Y",
  "ý": "y",
  "ÿ": "y",
  "Æ": "Ae",
  "æ": "ae",
  "Þ": "Th",
  "þ": "th",
  "ß": "ss",
  // Latin Extended-A block.
  "Ā": "A",
  "Ă": "A",
  "Ą": "A",
  "ā": "a",
  "ă": "a",
  "ą": "a",
  "Ć": "C",
  "Ĉ": "C",
  "Ċ": "C",
  "Č": "C",
  "ć": "c",
  "ĉ": "c",
  "ċ": "c",
  "č": "c",
  "Ď": "D",
  "Đ": "D",
  "ď": "d",
  "đ": "d",
  "Ē": "E",
  "Ĕ": "E",
  "Ė": "E",
  "Ę": "E",
  "Ě": "E",
  "ē": "e",
  "ĕ": "e",
  "ė": "e",
  "ę": "e",
  "ě": "e",
  "Ĝ": "G",
  "Ğ": "G",
  "Ġ": "G",
  "Ģ": "G",
  "ĝ": "g",
  "ğ": "g",
  "ġ": "g",
  "ģ": "g",
  "Ĥ": "H",
  "Ħ": "H",
  "ĥ": "h",
  "ħ": "h",
  "Ĩ": "I",
  "Ī": "I",
  "Ĭ": "I",
  "Į": "I",
  "İ": "I",
  "ĩ": "i",
  "ī": "i",
  "ĭ": "i",
  "į": "i",
  "ı": "i",
  "Ĵ": "J",
  "ĵ": "j",
  "Ķ": "K",
  "ķ": "k",
  "ĸ": "k",
  "Ĺ": "L",
  "Ļ": "L",
  "Ľ": "L",
  "Ŀ": "L",
  "Ł": "L",
  "ĺ": "l",
  "ļ": "l",
  "ľ": "l",
  "ŀ": "l",
  "ł": "l",
  "Ń": "N",
  "Ņ": "N",
  "Ň": "N",
  "Ŋ": "N",
  "ń": "n",
  "ņ": "n",
  "ň": "n",
  "ŋ": "n",
  "Ō": "O",
  "Ŏ": "O",
  "Ő": "O",
  "ō": "o",
  "ŏ": "o",
  "ő": "o",
  "Ŕ": "R",
  "Ŗ": "R",
  "Ř": "R",
  "ŕ": "r",
  "ŗ": "r",
  "ř": "r",
  "Ś": "S",
  "Ŝ": "S",
  "Ş": "S",
  "Š": "S",
  "ś": "s",
  "ŝ": "s",
  "ş": "s",
  "š": "s",
  "Ţ": "T",
  "Ť": "T",
  "Ŧ": "T",
  "ţ": "t",
  "ť": "t",
  "ŧ": "t",
  "Ũ": "U",
  "Ū": "U",
  "Ŭ": "U",
  "Ů": "U",
  "Ű": "U",
  "Ų": "U",
  "ũ": "u",
  "ū": "u",
  "ŭ": "u",
  "ů": "u",
  "ű": "u",
  "ų": "u",
  "Ŵ": "W",
  "ŵ": "w",
  "Ŷ": "Y",
  "ŷ": "y",
  "Ÿ": "Y",
  "Ź": "Z",
  "Ż": "Z",
  "Ž": "Z",
  "ź": "z",
  "ż": "z",
  "ž": "z",
  "Ĳ": "IJ",
  "ĳ": "ij",
  "Œ": "Oe",
  "œ": "oe",
  "ŉ": "'n",
  "ſ": "s"
};
var deburrLetter$1 = basePropertyOf(deburredLetters);
var _deburrLetter = deburrLetter$1;
function arrayMap$2(array, iteratee) {
  var index = -1, length = array == null ? 0 : array.length, result = Array(length);
  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}
var _arrayMap = arrayMap$2;
var baseGetTag$4 = _baseGetTag;
var isObjectLike$5 = isObjectLike_1;
var symbolTag = "[object Symbol]";
function isSymbol$4(value) {
  return typeof value == "symbol" || isObjectLike$5(value) && baseGetTag$4(value) == symbolTag;
}
var isSymbol_1 = isSymbol$4;
var Symbol$2 = _Symbol;
var arrayMap$1 = _arrayMap;
var isArray$6 = isArray_1;
var isSymbol$3 = isSymbol_1;
var INFINITY$1 = 1 / 0;
var symbolProto = Symbol$2 ? Symbol$2.prototype : void 0;
var symbolToString = symbolProto ? symbolProto.toString : void 0;
function baseToString$1(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isArray$6(value)) {
    return arrayMap$1(value, baseToString$1) + "";
  }
  if (isSymbol$3(value)) {
    return symbolToString ? symbolToString.call(value) : "";
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY$1 ? "-0" : result;
}
var _baseToString = baseToString$1;
var baseToString = _baseToString;
function toString$6(value) {
  return value == null ? "" : baseToString(value);
}
var toString_1 = toString$6;
var deburrLetter = _deburrLetter;
var toString$5 = toString_1;
var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
var rsComboMarksRange$3 = "\\u0300-\\u036f";
var reComboHalfMarksRange$3 = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange$3 = "\\u20d0-\\u20ff";
var rsComboRange$3 = rsComboMarksRange$3 + reComboHalfMarksRange$3 + rsComboSymbolsRange$3;
var rsCombo$2 = "[" + rsComboRange$3 + "]";
var reComboMark = RegExp(rsCombo$2, "g");
function deburr$1(string) {
  string = toString$5(string);
  return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
}
var deburr_1 = deburr$1;
var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
function asciiWords$1(string) {
  return string.match(reAsciiWord) || [];
}
var _asciiWords = asciiWords$1;
var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
function hasUnicodeWord$1(string) {
  return reHasUnicodeWord.test(string);
}
var _hasUnicodeWord = hasUnicodeWord$1;
var rsAstralRange$2 = "\\ud800-\\udfff";
var rsComboMarksRange$2 = "\\u0300-\\u036f";
var reComboHalfMarksRange$2 = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange$2 = "\\u20d0-\\u20ff";
var rsComboRange$2 = rsComboMarksRange$2 + reComboHalfMarksRange$2 + rsComboSymbolsRange$2;
var rsDingbatRange = "\\u2700-\\u27bf";
var rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff";
var rsMathOpRange = "\\xac\\xb1\\xd7\\xf7";
var rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf";
var rsPunctuationRange = "\\u2000-\\u206f";
var rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000";
var rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde";
var rsVarRange$2 = "\\ufe0e\\ufe0f";
var rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
var rsApos$1 = "['’]";
var rsBreak = "[" + rsBreakRange + "]";
var rsCombo$1 = "[" + rsComboRange$2 + "]";
var rsDigits = "\\d+";
var rsDingbat = "[" + rsDingbatRange + "]";
var rsLower = "[" + rsLowerRange + "]";
var rsMisc = "[^" + rsAstralRange$2 + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]";
var rsFitz$1 = "\\ud83c[\\udffb-\\udfff]";
var rsModifier$1 = "(?:" + rsCombo$1 + "|" + rsFitz$1 + ")";
var rsNonAstral$1 = "[^" + rsAstralRange$2 + "]";
var rsRegional$1 = "(?:\\ud83c[\\udde6-\\uddff]){2}";
var rsSurrPair$1 = "[\\ud800-\\udbff][\\udc00-\\udfff]";
var rsUpper = "[" + rsUpperRange + "]";
var rsZWJ$2 = "\\u200d";
var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")";
var rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")";
var rsOptContrLower = "(?:" + rsApos$1 + "(?:d|ll|m|re|s|t|ve))?";
var rsOptContrUpper = "(?:" + rsApos$1 + "(?:D|LL|M|RE|S|T|VE))?";
var reOptMod$1 = rsModifier$1 + "?";
var rsOptVar$1 = "[" + rsVarRange$2 + "]?";
var rsOptJoin$1 = "(?:" + rsZWJ$2 + "(?:" + [rsNonAstral$1, rsRegional$1, rsSurrPair$1].join("|") + ")" + rsOptVar$1 + reOptMod$1 + ")*";
var rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])";
var rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])";
var rsSeq$1 = rsOptVar$1 + reOptMod$1 + rsOptJoin$1;
var rsEmoji = "(?:" + [rsDingbat, rsRegional$1, rsSurrPair$1].join("|") + ")" + rsSeq$1;
var reUnicodeWord = RegExp([
  rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
  rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
  rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
  rsUpper + "+" + rsOptContrUpper,
  rsOrdUpper,
  rsOrdLower,
  rsDigits,
  rsEmoji
].join("|"), "g");
function unicodeWords$1(string) {
  return string.match(reUnicodeWord) || [];
}
var _unicodeWords = unicodeWords$1;
var asciiWords = _asciiWords;
var hasUnicodeWord = _hasUnicodeWord;
var toString$4 = toString_1;
var unicodeWords = _unicodeWords;
function words$1(string, pattern, guard) {
  string = toString$4(string);
  pattern = guard ? void 0 : pattern;
  if (pattern === void 0) {
    return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
  }
  return string.match(pattern) || [];
}
var words_1 = words$1;
var arrayReduce = _arrayReduce;
var deburr = deburr_1;
var words = words_1;
var rsApos = "['’]";
var reApos = RegExp(rsApos, "g");
function createCompounder$3(callback) {
  return function(string) {
    return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
  };
}
var _createCompounder = createCompounder$3;
var createCompounder$2 = _createCompounder;
var kebabCase = createCompounder$2(function(result, word, index) {
  return result + (index ? "-" : "") + word.toLowerCase();
});
var kebabCase_1 = kebabCase;
var kebabCase$1 = getDefaultExportFromCjs(kebabCase_1);
function baseSlice$2(array, start, end) {
  var index = -1, length = array.length;
  if (start < 0) {
    start = -start > length ? 0 : length + start;
  }
  end = end > length ? length : end;
  if (end < 0) {
    end += length;
  }
  length = start > end ? 0 : end - start >>> 0;
  start >>>= 0;
  var result = Array(length);
  while (++index < length) {
    result[index] = array[index + start];
  }
  return result;
}
var _baseSlice = baseSlice$2;
var baseSlice$1 = _baseSlice;
function castSlice$1(array, start, end) {
  var length = array.length;
  end = end === void 0 ? length : end;
  return !start && end >= length ? array : baseSlice$1(array, start, end);
}
var _castSlice = castSlice$1;
var rsAstralRange$1 = "\\ud800-\\udfff";
var rsComboMarksRange$1 = "\\u0300-\\u036f";
var reComboHalfMarksRange$1 = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange$1 = "\\u20d0-\\u20ff";
var rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1;
var rsVarRange$1 = "\\ufe0e\\ufe0f";
var rsZWJ$1 = "\\u200d";
var reHasUnicode = RegExp("[" + rsZWJ$1 + rsAstralRange$1 + rsComboRange$1 + rsVarRange$1 + "]");
function hasUnicode$2(string) {
  return reHasUnicode.test(string);
}
var _hasUnicode = hasUnicode$2;
function asciiToArray$1(string) {
  return string.split("");
}
var _asciiToArray = asciiToArray$1;
var rsAstralRange = "\\ud800-\\udfff";
var rsComboMarksRange = "\\u0300-\\u036f";
var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange = "\\u20d0-\\u20ff";
var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
var rsVarRange = "\\ufe0e\\ufe0f";
var rsAstral = "[" + rsAstralRange + "]";
var rsCombo = "[" + rsComboRange + "]";
var rsFitz = "\\ud83c[\\udffb-\\udfff]";
var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
var rsNonAstral = "[^" + rsAstralRange + "]";
var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
var rsZWJ = "\\u200d";
var reOptMod = rsModifier + "?";
var rsOptVar = "[" + rsVarRange + "]?";
var rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
var rsSeq = rsOptVar + reOptMod + rsOptJoin;
var rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
function unicodeToArray$1(string) {
  return string.match(reUnicode) || [];
}
var _unicodeToArray = unicodeToArray$1;
var asciiToArray = _asciiToArray;
var hasUnicode$1 = _hasUnicode;
var unicodeToArray = _unicodeToArray;
function stringToArray$1(string) {
  return hasUnicode$1(string) ? unicodeToArray(string) : asciiToArray(string);
}
var _stringToArray = stringToArray$1;
var castSlice = _castSlice;
var hasUnicode = _hasUnicode;
var stringToArray = _stringToArray;
var toString$3 = toString_1;
function createCaseFirst$1(methodName) {
  return function(string) {
    string = toString$3(string);
    var strSymbols = hasUnicode(string) ? stringToArray(string) : void 0;
    var chr = strSymbols ? strSymbols[0] : string.charAt(0);
    var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
    return chr[methodName]() + trailing;
  };
}
var _createCaseFirst = createCaseFirst$1;
var createCaseFirst = _createCaseFirst;
var upperFirst$2 = createCaseFirst("toUpperCase");
var upperFirst_1 = upperFirst$2;
var toString$2 = toString_1;
var upperFirst$1 = upperFirst_1;
function capitalize$1(string) {
  return upperFirst$1(toString$2(string).toLowerCase());
}
var capitalize_1 = capitalize$1;
var capitalize2 = capitalize_1;
var createCompounder$1 = _createCompounder;
var camelCase = createCompounder$1(function(result, word, index) {
  word = word.toLowerCase();
  return result + (index ? capitalize2(word) : word);
});
var camelCase_1 = camelCase;
var camelCase$1 = getDefaultExportFromCjs(camelCase_1);
function isNil(value) {
  return value == null;
}
var isNil_1 = isNil;
var isNil$1 = getDefaultExportFromCjs(isNil_1);
var root = _root;
var now$1 = function() {
  return root.Date.now();
};
var now_1 = now$1;
var reWhitespace = /\s/;
function trimmedEndIndex$1(string) {
  var index = string.length;
  while (index-- && reWhitespace.test(string.charAt(index))) {
  }
  return index;
}
var _trimmedEndIndex = trimmedEndIndex$1;
var trimmedEndIndex = _trimmedEndIndex;
var reTrimStart = /^\s+/;
function baseTrim$1(string) {
  return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
}
var _baseTrim = baseTrim$1;
var baseTrim = _baseTrim;
var isObject$6 = isObject_1;
var isSymbol$2 = isSymbol_1;
var NAN = 0 / 0;
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary = /^0b[01]+$/i;
var reIsOctal = /^0o[0-7]+$/i;
var freeParseInt = parseInt;
function toNumber$2(value) {
  if (typeof value == "number") {
    return value;
  }
  if (isSymbol$2(value)) {
    return NAN;
  }
  if (isObject$6(value)) {
    var other = typeof value.valueOf == "function" ? value.valueOf() : value;
    value = isObject$6(other) ? other + "" : other;
  }
  if (typeof value != "string") {
    return value === 0 ? value : +value;
  }
  value = baseTrim(value);
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}
var toNumber_1 = toNumber$2;
var isObject$5 = isObject_1;
var now = now_1;
var toNumber$1 = toNumber_1;
var FUNC_ERROR_TEXT$2 = "Expected a function";
var nativeMax$1 = Math.max;
var nativeMin = Math.min;
function debounce$1(func, wait, options) {
  var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT$2);
  }
  wait = toNumber$1(wait) || 0;
  if (isObject$5(options)) {
    leading = !!options.leading;
    maxing = "maxWait" in options;
    maxWait = maxing ? nativeMax$1(toNumber$1(options.maxWait) || 0, wait) : maxWait;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }
  function invokeFunc(time) {
    var args = lastArgs, thisArg = lastThis;
    lastArgs = lastThis = void 0;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }
  function leadingEdge(time) {
    lastInvokeTime = time;
    timerId = setTimeout(timerExpired, wait);
    return leading ? invokeFunc(time) : result;
  }
  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
    return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
  }
  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
    return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
  }
  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    timerId = setTimeout(timerExpired, remainingWait(time));
  }
  function trailingEdge(time) {
    timerId = void 0;
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = void 0;
    return result;
  }
  function cancel() {
    if (timerId !== void 0) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = void 0;
  }
  function flush() {
    return timerId === void 0 ? result : trailingEdge(now());
  }
  function debounced() {
    var time = now(), isInvoking = shouldInvoke(time);
    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;
    if (isInvoking) {
      if (timerId === void 0) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        clearTimeout(timerId);
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === void 0) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}
var debounce_1 = debounce$1;
var debounce$2 = getDefaultExportFromCjs(debounce_1);
var isArray$5 = isArray_1;
var isSymbol$1 = isSymbol_1;
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
var reIsPlainProp = /^\w*$/;
function isKey$1(value, object) {
  if (isArray$5(value)) {
    return false;
  }
  var type = typeof value;
  if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol$1(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}
var _isKey = isKey$1;
var MapCache = _MapCache;
var FUNC_ERROR_TEXT$1 = "Expected a function";
function memoize$1(func, resolver) {
  if (typeof func != "function" || resolver != null && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT$1);
  }
  var memoized = function() {
    var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize$1.Cache || MapCache)();
  return memoized;
}
memoize$1.Cache = MapCache;
var memoize_1 = memoize$1;
var memoize = memoize_1;
var MAX_MEMOIZE_SIZE = 500;
function memoizeCapped$1(func) {
  var result = memoize(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });
  var cache = result.cache;
  return result;
}
var _memoizeCapped = memoizeCapped$1;
var memoizeCapped = _memoizeCapped;
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath$1 = memoizeCapped(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46) {
    result.push("");
  }
  string.replace(rePropName, function(match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
  });
  return result;
});
var _stringToPath = stringToPath$1;
var isArray$4 = isArray_1;
var isKey = _isKey;
var stringToPath = _stringToPath;
var toString$1 = toString_1;
function castPath$6(value, object) {
  if (isArray$4(value)) {
    return value;
  }
  return isKey(value, object) ? [value] : stringToPath(toString$1(value));
}
var _castPath = castPath$6;
var isSymbol = isSymbol_1;
var INFINITY = 1 / 0;
function toKey$4(value) {
  if (typeof value == "string" || isSymbol(value)) {
    return value;
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
var _toKey = toKey$4;
var castPath$5 = _castPath;
var toKey$3 = _toKey;
function baseGet$2(object, path) {
  path = castPath$5(path, object);
  var index = 0, length = path.length;
  while (object != null && index < length) {
    object = object[toKey$3(path[index++])];
  }
  return index && index == length ? object : void 0;
}
var _baseGet = baseGet$2;
var assignValue = _assignValue;
var castPath$4 = _castPath;
var isIndex$2 = _isIndex;
var isObject$4 = isObject_1;
var toKey$2 = _toKey;
function baseSet$1(object, path, value, customizer) {
  if (!isObject$4(object)) {
    return object;
  }
  path = castPath$4(path, object);
  var index = -1, length = path.length, lastIndex = length - 1, nested = object;
  while (nested != null && ++index < length) {
    var key = toKey$2(path[index]), newValue = value;
    if (key === "__proto__" || key === "constructor" || key === "prototype") {
      return object;
    }
    if (index != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : void 0;
      if (newValue === void 0) {
        newValue = isObject$4(objValue) ? objValue : isIndex$2(path[index + 1]) ? [] : {};
      }
    }
    assignValue(nested, key, newValue);
    nested = nested[key];
  }
  return object;
}
var _baseSet = baseSet$1;
var baseGet$1 = _baseGet;
var baseSet = _baseSet;
var castPath$3 = _castPath;
function basePickBy$1(object, paths, predicate) {
  var index = -1, length = paths.length, result = {};
  while (++index < length) {
    var path = paths[index], value = baseGet$1(object, path);
    if (predicate(value, path)) {
      baseSet(result, castPath$3(path, object), value);
    }
  }
  return result;
}
var _basePickBy = basePickBy$1;
function baseHasIn$1(object, key) {
  return object != null && key in Object(object);
}
var _baseHasIn = baseHasIn$1;
var castPath$2 = _castPath;
var isArguments$2 = isArguments_1;
var isArray$3 = isArray_1;
var isIndex$1 = _isIndex;
var isLength = isLength_1;
var toKey$1 = _toKey;
function hasPath$1(object, path, hasFunc) {
  path = castPath$2(path, object);
  var index = -1, length = path.length, result = false;
  while (++index < length) {
    var key = toKey$1(path[index]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index != length) {
    return result;
  }
  length = object == null ? 0 : object.length;
  return !!length && isLength(length) && isIndex$1(key, length) && (isArray$3(object) || isArguments$2(object));
}
var _hasPath = hasPath$1;
var baseHasIn = _baseHasIn;
var hasPath = _hasPath;
function hasIn$1(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}
var hasIn_1 = hasIn$1;
var basePickBy = _basePickBy;
var hasIn = hasIn_1;
function basePick$1(object, paths) {
  return basePickBy(object, paths, function(value, path) {
    return hasIn(object, path);
  });
}
var _basePick = basePick$1;
var Symbol$1 = _Symbol;
var isArguments$1 = isArguments_1;
var isArray$2 = isArray_1;
var spreadableSymbol = Symbol$1 ? Symbol$1.isConcatSpreadable : void 0;
function isFlattenable$1(value) {
  return isArray$2(value) || isArguments$1(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
}
var _isFlattenable = isFlattenable$1;
var arrayPush = _arrayPush;
var isFlattenable = _isFlattenable;
function baseFlatten$1(array, depth, predicate, isStrict, result) {
  var index = -1, length = array.length;
  predicate || (predicate = isFlattenable);
  result || (result = []);
  while (++index < length) {
    var value = array[index];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        baseFlatten$1(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}
var _baseFlatten = baseFlatten$1;
var baseFlatten = _baseFlatten;
function flatten$1(array) {
  var length = array == null ? 0 : array.length;
  return length ? baseFlatten(array, 1) : [];
}
var flatten_1 = flatten$1;
var flatten$2 = getDefaultExportFromCjs(flatten_1);
function apply$1(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);
    case 1:
      return func.call(thisArg, args[0]);
    case 2:
      return func.call(thisArg, args[0], args[1]);
    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}
var _apply = apply$1;
var apply = _apply;
var nativeMax = Math.max;
function overRest$2(func, start, transform) {
  start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
  return function() {
    var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}
var _overRest = overRest$2;
function constant$1(value) {
  return function() {
    return value;
  };
}
var constant_1 = constant$1;
function identity$2(value) {
  return value;
}
var identity_1 = identity$2;
var constant = constant_1;
var defineProperty = _defineProperty;
var identity$1 = identity_1;
var baseSetToString$1 = !defineProperty ? identity$1 : function(func, string) {
  return defineProperty(func, "toString", {
    "configurable": true,
    "enumerable": false,
    "value": constant(string),
    "writable": true
  });
};
var _baseSetToString = baseSetToString$1;
var HOT_COUNT = 800;
var HOT_SPAN = 16;
var nativeNow = Date.now;
function shortOut$1(func) {
  var count = 0, lastCalled = 0;
  return function() {
    var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(void 0, arguments);
  };
}
var _shortOut = shortOut$1;
var baseSetToString = _baseSetToString;
var shortOut = _shortOut;
var setToString$2 = shortOut(baseSetToString);
var _setToString = setToString$2;
var flatten = flatten_1;
var overRest$1 = _overRest;
var setToString$1 = _setToString;
function flatRest$2(func) {
  return setToString$1(overRest$1(func, void 0, flatten), func + "");
}
var _flatRest = flatRest$2;
var basePick = _basePick;
var flatRest$1 = _flatRest;
var pick = flatRest$1(function(object, paths) {
  return object == null ? {} : basePick(object, paths);
});
var pick_1 = pick;
var pick$1 = getDefaultExportFromCjs(pick_1);
var toString = toString_1;
var idCounter = 0;
function uniqueId(prefix2) {
  var id = ++idCounter;
  return toString(prefix2) + id;
}
var uniqueId_1 = uniqueId;
var uniqueId$1 = getDefaultExportFromCjs(uniqueId_1);
var baseGetTag$3 = _baseGetTag;
var isArray$1 = isArray_1;
var isObjectLike$4 = isObjectLike_1;
var stringTag = "[object String]";
function isString(value) {
  return typeof value == "string" || !isArray$1(value) && isObjectLike$4(value) && baseGetTag$3(value) == stringTag;
}
var isString_1 = isString;
var isString$1 = getDefaultExportFromCjs(isString_1);
var baseAssignValue = _baseAssignValue;
var eq$1 = eq_1;
function assignMergeValue$2(object, key, value) {
  if (value !== void 0 && !eq$1(object[key], value) || value === void 0 && !(key in object)) {
    baseAssignValue(object, key, value);
  }
}
var _assignMergeValue = assignMergeValue$2;
function createBaseFor$1(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}
var _createBaseFor = createBaseFor$1;
var createBaseFor = _createBaseFor;
var baseFor$1 = createBaseFor();
var _baseFor = baseFor$1;
var isArrayLike$1 = isArrayLike_1;
var isObjectLike$3 = isObjectLike_1;
function isArrayLikeObject$1(value) {
  return isObjectLike$3(value) && isArrayLike$1(value);
}
var isArrayLikeObject_1 = isArrayLikeObject$1;
var baseGetTag$2 = _baseGetTag;
var getPrototype = _getPrototype;
var isObjectLike$2 = isObjectLike_1;
var objectTag = "[object Object]";
var funcProto = Function.prototype;
var objectProto = Object.prototype;
var funcToString = funcProto.toString;
var hasOwnProperty = objectProto.hasOwnProperty;
var objectCtorString = funcToString.call(Object);
function isPlainObject$2(value) {
  if (!isObjectLike$2(value) || baseGetTag$2(value) != objectTag) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
  return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
}
var isPlainObject_1 = isPlainObject$2;
function safeGet$2(object, key) {
  if (key === "constructor" && typeof object[key] === "function") {
    return;
  }
  if (key == "__proto__") {
    return;
  }
  return object[key];
}
var _safeGet = safeGet$2;
var copyObject$1 = _copyObject;
var keysIn$1 = keysIn_1;
function toPlainObject$1(value) {
  return copyObject$1(value, keysIn$1(value));
}
var toPlainObject_1 = toPlainObject$1;
var assignMergeValue$1 = _assignMergeValue;
var cloneBuffer = _cloneBufferExports;
var cloneTypedArray = _cloneTypedArray;
var copyArray = _copyArray;
var initCloneObject = _initCloneObject;
var isArguments = isArguments_1;
var isArray = isArray_1;
var isArrayLikeObject = isArrayLikeObject_1;
var isBuffer = isBufferExports;
var isFunction = isFunction_1;
var isObject$3 = isObject_1;
var isPlainObject$1 = isPlainObject_1;
var isTypedArray = isTypedArray_1;
var safeGet$1 = _safeGet;
var toPlainObject = toPlainObject_1;
function baseMergeDeep$1(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = safeGet$1(object, key), srcValue = safeGet$1(source, key), stacked = stack.get(srcValue);
  if (stacked) {
    assignMergeValue$1(object, key, stacked);
    return;
  }
  var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : void 0;
  var isCommon = newValue === void 0;
  if (isCommon) {
    var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray(objValue)) {
        newValue = objValue;
      } else if (isArrayLikeObject(objValue)) {
        newValue = copyArray(objValue);
      } else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer(srcValue, true);
      } else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray(srcValue, true);
      } else {
        newValue = [];
      }
    } else if (isPlainObject$1(srcValue) || isArguments(srcValue)) {
      newValue = objValue;
      if (isArguments(objValue)) {
        newValue = toPlainObject(objValue);
      } else if (!isObject$3(objValue) || isFunction(objValue)) {
        newValue = initCloneObject(srcValue);
      }
    } else {
      isCommon = false;
    }
  }
  if (isCommon) {
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack["delete"](srcValue);
  }
  assignMergeValue$1(object, key, newValue);
}
var _baseMergeDeep = baseMergeDeep$1;
var Stack = _Stack;
var assignMergeValue = _assignMergeValue;
var baseFor = _baseFor;
var baseMergeDeep = _baseMergeDeep;
var isObject$2 = isObject_1;
var keysIn = keysIn_1;
var safeGet = _safeGet;
function baseMerge$1(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }
  baseFor(source, function(srcValue, key) {
    stack || (stack = new Stack());
    if (isObject$2(srcValue)) {
      baseMergeDeep(object, source, key, srcIndex, baseMerge$1, customizer, stack);
    } else {
      var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : void 0;
      if (newValue === void 0) {
        newValue = srcValue;
      }
      assignMergeValue(object, key, newValue);
    }
  }, keysIn);
}
var _baseMerge = baseMerge$1;
var identity = identity_1;
var overRest = _overRest;
var setToString = _setToString;
function baseRest$1(func, start) {
  return setToString(overRest(func, start, identity), func + "");
}
var _baseRest = baseRest$1;
var eq = eq_1;
var isArrayLike = isArrayLike_1;
var isIndex = _isIndex;
var isObject$1 = isObject_1;
function isIterateeCall$1(value, index, object) {
  if (!isObject$1(object)) {
    return false;
  }
  var type = typeof index;
  if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
    return eq(object[index], value);
  }
  return false;
}
var _isIterateeCall = isIterateeCall$1;
var baseRest = _baseRest;
var isIterateeCall = _isIterateeCall;
function createAssigner$1(assigner) {
  return baseRest(function(object, sources) {
    var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
    customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? void 0 : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}
var _createAssigner = createAssigner$1;
var baseMerge = _baseMerge;
var createAssigner = _createAssigner;
var merge = createAssigner(function(object, source, srcIndex) {
  baseMerge(object, source, srcIndex);
});
var merge_1 = merge;
var merge$1 = getDefaultExportFromCjs(merge_1);
function last$1(array) {
  var length = array == null ? 0 : array.length;
  return length ? array[length - 1] : void 0;
}
var last_1 = last$1;
var baseGet = _baseGet;
var baseSlice = _baseSlice;
function parent$1(object, path) {
  return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
}
var _parent = parent$1;
var castPath$1 = _castPath;
var last = last_1;
var parent = _parent;
var toKey = _toKey;
function baseUnset$1(object, path) {
  path = castPath$1(path, object);
  object = parent(object, path);
  return object == null || delete object[toKey(last(path))];
}
var _baseUnset = baseUnset$1;
var isPlainObject = isPlainObject_1;
function customOmitClone$1(value) {
  return isPlainObject(value) ? void 0 : value;
}
var _customOmitClone = customOmitClone$1;
var arrayMap = _arrayMap;
var baseClone = _baseClone;
var baseUnset = _baseUnset;
var castPath = _castPath;
var copyObject = _copyObject;
var customOmitClone = _customOmitClone;
var flatRest = _flatRest;
var getAllKeysIn = _getAllKeysIn;
var CLONE_DEEP_FLAG = 1;
var CLONE_FLAT_FLAG = 2;
var CLONE_SYMBOLS_FLAG = 4;
var omit = flatRest(function(object, paths) {
  var result = {};
  if (object == null) {
    return result;
  }
  var isDeep = false;
  paths = arrayMap(paths, function(path) {
    path = castPath(path, object);
    isDeep || (isDeep = path.length > 1);
    return path;
  });
  copyObject(object, getAllKeysIn(object), result);
  if (isDeep) {
    result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
  }
  var length = paths.length;
  while (length--) {
    baseUnset(result, paths[length]);
  }
  return result;
});
var omit_1 = omit;
var omit$1 = getDefaultExportFromCjs(omit_1);
function baseClamp$1(number, lower, upper) {
  if (number === number) {
    if (upper !== void 0) {
      number = number <= upper ? number : upper;
    }
    if (lower !== void 0) {
      number = number >= lower ? number : lower;
    }
  }
  return number;
}
var _baseClamp = baseClamp$1;
var baseClamp = _baseClamp;
var toNumber = toNumber_1;
function clamp(number, lower, upper) {
  if (upper === void 0) {
    upper = lower;
    lower = void 0;
  }
  if (upper !== void 0) {
    upper = toNumber(upper);
    upper = upper === upper ? upper : 0;
  }
  if (lower !== void 0) {
    lower = toNumber(lower);
    lower = lower === lower ? lower : 0;
  }
  return baseClamp(toNumber(number), lower, upper);
}
var clamp_1 = clamp;
var clamp$1 = getDefaultExportFromCjs(clamp_1);
function noop() {
}
var noop_1 = noop;
var noop$1 = getDefaultExportFromCjs(noop_1);
var debounce = debounce_1;
var isObject2 = isObject_1;
var FUNC_ERROR_TEXT = "Expected a function";
function throttle(func, wait, options) {
  var leading = true, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  if (isObject2(options)) {
    leading = "leading" in options ? !!options.leading : leading;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }
  return debounce(func, wait, {
    "leading": leading,
    "maxWait": wait,
    "trailing": trailing
  });
}
var throttle_1 = throttle;
var throttle$1 = getDefaultExportFromCjs(throttle_1);
var createCompounder = _createCompounder;
var upperFirst = upperFirst_1;
var startCase = createCompounder(function(result, word, index) {
  return result + (index ? " " : "") + upperFirst(word);
});
var startCase_1 = startCase;
var startCase$1 = getDefaultExportFromCjs(startCase_1);
var baseGetTag$1 = _baseGetTag;
var isObjectLike$1 = isObjectLike_1;
var dateTag = "[object Date]";
function baseIsDate$1(value) {
  return isObjectLike$1(value) && baseGetTag$1(value) == dateTag;
}
var _baseIsDate = baseIsDate$1;
var baseIsDate = _baseIsDate;
var baseUnary = _baseUnary;
var nodeUtil = _nodeUtilExports;
var nodeIsDate = nodeUtil && nodeUtil.isDate;
var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
var isDate_1 = isDate;
var isDate$1 = getDefaultExportFromCjs(isDate_1);
var baseGetTag = _baseGetTag;
var isObjectLike = isObjectLike_1;
var numberTag = "[object Number]";
function isNumber(value) {
  return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
}
var isNumber_1 = isNumber;
var isNumber$1 = getDefaultExportFromCjs(isNumber_1);

// node_modules/vuestic-ui/dist/web-components/src/services/color/config/make-config.js
var makeColorsConfig = (values) => ({
  ...values,
  get variables() {
    return this.presets[this.currentPresetName];
  },
  set variables(value) {
    this.presets[this.currentPresetName] = value;
  }
});

// node_modules/vuestic-ui/dist/web-components/src/utils/env.js
var processShim = typeof process !== "undefined" ? process : {};
var envShim = processShim.env || {};
var nodeEnv = envShim.NODE_ENV || "";
var isDev = typeof __DEV__ !== "undefined" ? __DEV__ : !["prod", "production"].includes(nodeEnv);

// node_modules/vuestic-ui/dist/web-components/src/utils/console.js
var warn = (...attrs) => {
  if (isDev) {
    console.warn(...attrs);
  }
  return false;
};
var throwError = (message) => {
  throw new Error(`[Vuestic] ${message}`);
};

// node_modules/vuestic-ui/dist/web-components/src/services/current-app.js
var currentApp = null;
var prevRegisteredApp = null;
var setCurrentApp = (newApp) => {
  if ((prevRegisteredApp == null ? void 0 : prevRegisteredApp._instance) === null) {
    prevRegisteredApp = null;
  }
  if (newApp === null && prevRegisteredApp === null) {
    return;
  }
  prevRegisteredApp = currentApp;
  currentApp = newApp;
};
var getCurrentApp = () => currentApp;
var inject2 = (key, value = void 0) => {
  var _a2;
  const injectedFromApp = (_a2 = getCurrentApp()) == null ? void 0 : _a2._context.provides[key];
  const vm = getCurrentInstance();
  if (vm) {
    return inject(key, value);
  }
  return injectedFromApp ?? throwError("You're using Vuestic composable outside Vue app. Since you registered Vuestic in multiple apps, composables can not be used outside setup function anymore.");
};

// node_modules/vuestic-ui/dist/web-components/src/services/colors-classes/config/default.js
var ColorsClassesPresets = [
  {
    prefix: "bg",
    property: "background-color"
  },
  {
    prefix: "text",
    property: ["color", "fill"]
  }
];
var getColorsClassesDefaultConfig = () => ColorsClassesPresets;

// node_modules/vuestic-ui/dist/web-components/src/services/color/config/default.js
var getColorDefaultConfig = () => makeColorsConfig({
  threshold: 150,
  presets: {
    light: presets.light,
    dark: presets.dark
  },
  currentPresetName: "light"
});

// node_modules/vuestic-ui/dist/web-components/src/services/icon/presets/vuestic-aliases.js
var VuesticIconAliases = [
  {
    name: "va-arrow-first",
    to: "mi-first_page"
  },
  {
    name: "va-arrow-last",
    to: "mi-last_page"
  },
  {
    name: "va-arrow-right",
    to: "mi-chevron_right"
  },
  {
    name: "va-arrow-left",
    to: "mi-chevron_left"
  },
  {
    name: "va-arrow-down",
    to: "mi-expand_more"
  },
  {
    name: "va-arrow-up",
    to: "mi-expand_less"
  },
  {
    name: "va-calendar",
    to: "mi-calendar_today"
  },
  {
    name: "va-delete",
    to: "mi-delete_outline"
  },
  {
    name: "va-check",
    to: "mi-check"
  },
  {
    name: "va-check-circle",
    to: "mi-check_circle"
  },
  {
    name: "va-warning",
    to: "mi-warning"
  },
  {
    name: "va-clear",
    to: "mi-highlight_off"
  },
  {
    name: "va-close",
    to: "mi-close"
  },
  {
    name: "va-loading",
    to: "mi-loop"
  },
  {
    name: "va-plus",
    to: "add"
  },
  {
    name: "va-minus",
    to: "remove"
  }
];

// node_modules/vuestic-ui/dist/web-components/src/services/icon/presets/fonts.js
var VuesticIconFonts = [
  {
    name: "mi-{icon}",
    class: "material-icons",
    resolve: ({ icon }) => ({ content: icon })
  },
  // Fallback
  {
    name: "{icon}",
    class: "material-icons",
    resolve: ({ icon }) => ({ content: icon })
  }
];

// node_modules/vuestic-ui/dist/web-components/src/services/icon/create-icons-config.js
var createIconsConfig = (config) => {
  config.aliases = config.aliases || [];
  config.fonts = config.fonts || [];
  return [
    ...config.aliases,
    ...VuesticIconAliases,
    ...config.fonts,
    ...VuesticIconFonts
  ];
};

// node_modules/vuestic-ui/dist/web-components/src/services/icon/config/default.js
var getIconDefaultConfig = () => createIconsConfig({});

// node_modules/vuestic-ui/dist/web-components/src/services/component-config/config/default.js
var getComponentsDefaultConfig = () => (
  // TODO: Should be handled in size service
  {
    VaIcon: {
      sizesConfig: {
        defaultSize: 18,
        sizes: {
          small: 14,
          medium: 18,
          large: 24
        }
      }
    },
    VaRating: {
      sizesConfig: {
        defaultSize: 18,
        sizes: {
          small: 14,
          medium: 18,
          large: 24
        }
      }
    },
    all: {},
    presets: {
      VaButton: {
        default: {
          backgroundOpacity: 1,
          hoverBehavior: "mask",
          hoverOpacity: 0.15,
          pressedBehavior: "mask",
          pressedOpacity: 0.13
        },
        primary: {
          backgroundOpacity: 0.1,
          hoverBehavior: "opacity",
          hoverOpacity: 0.07,
          pressedBehavior: "opacity",
          pressedOpacity: 0.13
        },
        secondary: {
          backgroundOpacity: 0,
          hoverBehavior: "opacity",
          hoverOpacity: 0.07,
          pressedBehavior: "opacity",
          pressedOpacity: 0.13
        },
        plain: {
          plain: true,
          hoverBehavior: "mask",
          hoverOpacity: 0.15,
          pressedBehavior: "mask",
          pressedOpacity: 0.13
        },
        plainOpacity: {
          plain: true,
          textOpacity: 0.6,
          hoverBehavior: "opacity",
          hoverOpacity: 1,
          pressedBehavior: "opacity",
          pressedOpacity: 0.9
        }
      },
      VaInputWrapper: {
        solid: {
          background: "backgroundElement"
        },
        bordered: {
          class: "va-input-wrapper--bordered",
          background: "backgroundElement"
        }
      },
      VaCheckbox: {
        solid: {
          style: "--va-checkbox-background: var(--va-background-element)"
        }
      },
      VaRadio: {
        solid: {
          style: "--va-radio-background: var(--va-background-element)"
        }
      },
      VaMenu: {
        context: {
          cursor: true,
          placement: "right-start",
          trigger: "right-click"
        }
      }
    }
  }
);

// node_modules/vuestic-ui/dist/web-components/src/services/i18n/config/default.js
var getI18nConfigDefaults = () => ({
  // PROPS
  /** Select search field default text */
  search: "Search",
  /** Select no options text */
  noOptions: "Items not found",
  /** Modal Ok button default text */
  ok: "OK",
  /** Modal Cancel button default text */
  cancel: "Cancel",
  /** FileUpload default button text */
  uploadFile: "Upload file",
  /** FileUpload default undo button text */
  undo: "Undo",
  /** FileUpload default dropzone text */
  dropzone: "Drop files here to upload",
  /** FileUpload default file deleted alert text */
  fileDeleted: "File deleted",
  // Aria attributes
  /** Alert close button aria-label */
  closeAlert: "close alert",
  backToTop: "back to top",
  toggleDropdown: "toggle dropdown",
  carousel: "carousel",
  goPreviousSlide: "go previous slide",
  goNextSlide: "go next slide",
  goSlide: "go slide {index}",
  slideOf: "slide {index} of {length}",
  close: "close",
  openColorPicker: "open color picker",
  colorSelection: "color selection",
  colorName: "color {color}",
  decreaseCounter: "decrease counter",
  increaseCounter: "increase counter",
  selectAllRows: "select all rows",
  sortColumnBy: "sort column by {name}",
  selectRowByIndex: "select row {index}",
  resetDate: "reset date",
  nextPeriod: "next period",
  switchView: "switch view",
  previousPeriod: "previous period",
  removeFile: "remove file",
  reset: "reset",
  pagination: "pagination",
  goToTheFirstPage: "go to the first page",
  goToPreviousPage: "go to the previous page",
  goToSpecificPage: "go to the {page} page",
  goToSpecificPageInput: "enter the page number to go",
  goNextPage: "go next page",
  goLastPage: "go last page",
  /** Rating aria-label */
  currentRating: "current rating {value} of {max}",
  /** Rating item aria-label */
  voteRating: "vote rating {value} of {max}",
  /** Select search input aria-label */
  optionsFilter: "options filter",
  splitPanels: "split panels",
  movePaginationLeft: "move pagination left",
  movePaginationRight: "move pagination right",
  resetTime: "reset time",
  closeToast: "close toast",
  /**
   * Select aria-label selected option prefix
   *
   * @example
   *
   * `Selected option: {option}` or `Selected option: Animal`
   */
  selectedOption: "Selected option",
  /** Select aria-label if no option is selected */
  noSelectedOption: "Option is not selected",
  breadcrumbs: "breadcrumbs",
  counterValue: "counter value",
  selectedDate: "selected date",
  selectedTime: "selected time",
  progressState: "progress state",
  color: "color",
  /** Stepper next button text */
  next: "Next",
  /** Stepper previous button text */
  back: "Previous",
  /** Stepper finish button text */
  finish: "Finish",
  step: "step",
  progress: "progress",
  /** Skeleton aria label */
  loading: "Loading",
  /** Slider aria label */
  sliderValue: "Current slider value is {value}",
  /** Switch aria label */
  switch: "Switch",
  /** Input aria label */
  inputField: "Input field"
});

// node_modules/vuestic-ui/dist/web-components/src/services/global-config/global-config.js
var GLOBAL_CONFIG = Symbol("GLOBAL_CONFIG");
var getDefaultConfig = () => ({
  colors: getColorDefaultConfig(),
  icons: getIconDefaultConfig(),
  components: getComponentsDefaultConfig(),
  breakpoint: getBreakpointDefaultConfig(),
  i18n: getI18nConfigDefaults(),
  colorsClasses: getColorsClassesDefaultConfig(),
  /**
   * global config variable to pass nuxt-link component to vuestic-ui via @vuestic/nuxt
   * TODO: give a try to integrate inertia js router components via this option
   * TODO: if this try won't be success, may be remake to provide/inject
   */
  routerComponent: void 0
});
var createGlobalConfig = (defaultConfig = {}) => {
  const globalConfig = ref(mergeDeep(getDefaultConfig(), defaultConfig));
  const getGlobalConfig = () => globalConfig.value;
  const setGlobalConfig = (updater) => {
    const config = typeof updater === "function" ? updater(globalConfig.value) : updater;
    globalConfig.value = cloneDeep$1(config);
  };
  const mergeGlobalConfig = (updater) => {
    const config = typeof updater === "function" ? updater(globalConfig.value) : updater;
    globalConfig.value = mergeDeep(cloneDeep$1(globalConfig.value), config);
  };
  return {
    getGlobalConfig,
    setGlobalConfig,
    mergeGlobalConfig,
    globalConfig
  };
};
var provideForCurrentApp = (provide2) => {
  var _a2, _b;
  const provides = ((_a2 = getCurrentInstance()) == null ? void 0 : _a2.appContext.provides) || ((_b = getCurrentApp()) == null ? void 0 : _b._context.provides);
  if (!provides) {
    throw new Error("Vue app not found for provide");
  }
  provides[GLOBAL_CONFIG] = provide2;
  return provide2;
};

// node_modules/vuestic-ui/dist/web-components/src/composables/useGlobalConfig.js
function useGlobalConfig() {
  let injected = inject2(GLOBAL_CONFIG);
  if (!injected) {
    injected = createGlobalConfig();
    provideForCurrentApp(injected);
  }
  return injected;
}

// node_modules/vuestic-ui/dist/web-components/src/components/va-config/hooks/useGlobalConfigProvider.js
var useGlobalConfigProvider = (next) => {
  const { globalConfig, mergeGlobalConfig, setGlobalConfig, getGlobalConfig } = useGlobalConfig();
  const nextChain = computed(() => {
    var _a2;
    const gcCopy = cloneDeep$1(globalConfig.value);
    const compiledCopy = {
      ...gcCopy,
      colors: makeColorsConfig(gcCopy.colors)
    };
    const config = mergeDeep(compiledCopy, next.value);
    if ((_a2 = next.value.colors) == null ? void 0 : _a2.variables) {
      Object.keys(next.value.colors.variables).forEach((key) => {
        config.colors.variables[key] = next.value.colors.variables[key];
      });
    }
    return config;
  });
  provide(GLOBAL_CONFIG, {
    mergeGlobalConfig,
    setGlobalConfig,
    getGlobalConfig,
    globalConfig: nextChain
  });
  return nextChain;
};

// node_modules/vuestic-ui/dist/web-components/src/utils/headless.js
var toNode = (v, attrs) => {
  if (!v) {
    return null;
  }
  if (!("type" in v) || v.type === Text || typeof v === "string") {
    return h("div", attrs, v);
  }
  if (v.type === Comment) {
    return v;
  }
  if ("$el" in v) {
    return toNode(v.$el, attrs);
  }
  if (v.type === Suspense) {
    return h(v.ssContent, attrs);
  }
  if (v.type === Teleport) {
    if (v.children === null) {
      return v;
    }
    const anchor = toNode(v.children[0], attrs);
    if (anchor) {
      v.children[0] = h(anchor, attrs);
    }
    return v;
  }
  if (v.type === Fragment) {
    if (v.children === null) {
      return v;
    }
    if (v.children.length === 1) {
      return h(Fragment, v.props, [toNode(v.children[0], attrs)]);
    }
    return h("div", attrs, v);
  }
  if (typeof v.type.render === "function") {
    const component = h(v);
    if (Array.isArray(component.children) && component.children.length > 1) {
      return h("div", attrs, component.children);
    }
  }
  return h(v, attrs);
};
var renderSlotNode = (slot, slotBind = {}, nodeAttributes = {}) => {
  const children = slot == null ? void 0 : slot(slotBind);
  if (!children) {
    return null;
  }
  const nonCommentChildren = children.filter((v) => v.type !== Comment);
  if (nonCommentChildren.length === 0) {
    return null;
  }
  if (nonCommentChildren.length === 1) {
    return toNode(nonCommentChildren[0], nodeAttributes);
  }
  return h("div", nodeAttributes, children);
};
var renderSlotNodes = (slot, slotBind = {}, nodeAttributes = {}) => {
  const children = slot == null ? void 0 : slot(slotBind);
  if (!children) {
    return null;
  }
  return children.map((v) => toNode(v, nodeAttributes));
};

// node_modules/vuestic-ui/dist/web-components/src/services/vue-plugin/utils/define-vuestic-plugin.js
var defineVuesticPlugin = (fabric) => fabric;

// node_modules/vuestic-ui/dist/web-components/src/services/cache/plugin/index.js
var VaAppCachePluginKey = Symbol("VaAppCachePlugin");
var CachePlugin = defineVuesticPlugin(() => ({
  install(app) {
    const cache = {
      colorContrast: {}
    };
    app.provide(VaAppCachePluginKey, cache);
  }
}));

// node_modules/vuestic-ui/dist/web-components/src/composables/useCache.js
var useCache = () => {
  const cache = inject2(VaAppCachePluginKey);
  if (!cache) {
    return {
      colorContrast: {}
    };
  }
  return cache;
};

// node_modules/vuestic-ui/dist/web-components/src/composables/useReactiveComputed.js
var useReactiveComputed = (obj) => {
  const objectRef = typeof obj === "function" ? computed(obj) : computed(obj);
  const proxy = new Proxy(objectRef, {
    get(target, p, receiver) {
      if (typeof objectRef.value !== "object") {
        return void 0;
      }
      return unref(Reflect.get(objectRef.value, p, receiver));
    },
    set(target, p, value) {
      if (isRef(objectRef.value[p]) && !isRef(value)) {
        objectRef.value[p].value = value;
      } else {
        objectRef.value[p] = value;
      }
      return true;
    },
    deleteProperty(target, p) {
      return Reflect.deleteProperty(objectRef.value, p);
    },
    has(target, p) {
      if (typeof objectRef.value !== "object") {
        return false;
      }
      return Reflect.has(objectRef.value, p);
    },
    ownKeys() {
      if (typeof objectRef.value !== "object") {
        return [];
      }
      return Object.keys(objectRef.value);
    },
    getOwnPropertyDescriptor() {
      return {
        enumerable: true,
        configurable: true
      };
    }
  });
  return reactive(proxy);
};

// node_modules/vuestic-ui/dist/web-components/src/services/color/utils.js
var makeColor = (color) => {
  try {
    return new nt(color);
  } catch (e) {
    throw new Error(`Color ${color} is not valid. Please, provide valid color.`, {
      cause: e
    });
  }
};
var isCSSVariable = (strColor) => /var\(--.+\)/.test(strColor);
var cssVariableName = (colorName) => `--va-${kebabCase$1(colorName)}`;
var normalizeColorName = (colorName) => camelCase$1(colorName);
var colorToRgba = (color, opacity) => {
  return makeColor(color).setA(opacity).RGBA;
};
var getColorLightness = (color) => {
  const { R, G, B } = makeColor(color);
  return Math.sqrt(R * R * 0.241 + G * G * 0.691 + B * B * 0.068);
};
var getBoxShadowColor = (color, opacity = 0.4) => {
  return makeColor(color).setA(opacity).RGBA;
};
var getBoxShadowColorFromBg = (background, opacity = 0.4) => {
  return makeColor(background).setA(opacity).RGBA;
};
var getHoverColor = (color, opacity = 0.2) => {
  return makeColor(color).setA(opacity).RGBA;
};
var getFocusColor = (color, opacity = 0.3) => {
  return makeColor(color).setA(opacity).RGBA;
};
var shiftHSLAColor = (color, offset2) => {
  const result = makeColor(color);
  if (offset2.h) {
    result.setH(result.H + offset2.h);
  }
  if (offset2.s) {
    result.setS(result.S + offset2.s);
  }
  if (offset2.l) {
    result.setL(result.L + offset2.l);
  }
  if (offset2.a) {
    result.setA(result.A + offset2.a);
  }
  return result.HSLA;
};
var setHSLAColor = (color, newColor) => {
  const result = makeColor(color);
  if (newColor.h !== void 0) {
    result.setH(newColor.h);
  }
  if (newColor.s !== void 0) {
    result.setS(newColor.s);
  }
  if (newColor.l !== void 0) {
    result.setL(newColor.l);
  }
  if (newColor.a !== void 0) {
    result.setA(newColor.a);
  }
  return result.HSLA;
};
var shiftGradientColor = (color) => {
  const newColor = nt.toHSLA(color, false);
  if (newColor.s < 10) {
    return shiftHSLAColor(newColor, { h: 2, s: 5, l: 10 });
  }
  if (newColor.s < 30) {
    return shiftHSLAColor(newColor, { s: -14, l: 11 });
  }
  if (newColor.h >= 0 && newColor.h < 44 || newColor.h >= 285) {
    return shiftHSLAColor(newColor, { h: 11, s: 27, l: 8 });
  }
  if (newColor.h >= 44 && newColor.h < 85) {
    return shiftHSLAColor(newColor, { h: 3, l: 9 });
  }
  if (newColor.h >= 85 && newColor.h < 165) {
    return shiftHSLAColor(newColor, { h: 16, l: 14 });
  }
  if (newColor.h >= 165 && newColor.h < 285) {
    return shiftHSLAColor(newColor, { h: -15, s: 3, l: 2 });
  }
  throw new Error("This method should handle all colors. But it didn't for some reason.");
};
var getGradientBackground = (color) => {
  const colorLeft = shiftGradientColor(color);
  const colorRight = nt.toHSLA(color);
  return `linear-gradient(to right, ${colorLeft}, ${colorRight})`;
};
var getStateMaskGradientBackground = (color, maskColor, maskOpacity) => {
  const mask = colorToRgba(maskColor, maskOpacity);
  return `linear-gradient(0deg, ${mask}, ${mask}), ${color}`;
};
var isColor = (strColor) => {
  const cssColorRegex = /^#([\da-f]{3}){1,2}$|^#([\da-f]{4}){1,2}$|(rgb|hsl)a?\((\s*-?\d+%?\s*,){2}(\s*-?\d+%?\s*,?\s*\)?)(,\s*(0?\.\d+)?|1)?\)/;
  return cssColorRegex.test(strColor.toLocaleLowerCase());
};
var applyColors = (color1, color2) => {
  const c1 = makeColor(color1);
  const c2 = makeColor(color2);
  const weight = c2.A;
  if (weight === 1) {
    return c2.RGBA;
  }
  if (weight === 0) {
    return c1.RGBA;
  }
  c1.setR(Math.round(c1.R * (1 - weight) + c2.R * weight));
  c1.setG(Math.round(c1.G * (1 - weight) + c2.G * weight));
  c1.setB(Math.round(c1.B * (1 - weight) + c2.B * weight));
  return c1.RGBA;
};
var isColorTransparent = (color) => {
  if (!color) {
    return false;
  }
  if (color === "transparent") {
    return true;
  }
  return makeColor(color).A <= 0.1;
};

// node_modules/vuestic-ui/dist/web-components/src/composables/useColors.js
var useColorProps = {
  color: {
    type: String,
    default: ""
  }
};
var useColors = () => {
  const gc = useGlobalConfig();
  if (!gc) {
    throw new Error("useColors must be used in setup function or Vuestic GlobalConfigPlugin is not registered!");
  }
  const { globalConfig } = gc;
  const colors = useReactiveComputed({
    get: () => globalConfig.value.colors.presets[globalConfig.value.colors.currentPresetName],
    set: (v) => {
      setColors(v);
    }
  });
  const setColors = (colors2) => {
    globalConfig.value.colors.presets[globalConfig.value.colors.currentPresetName] = {
      ...globalConfig.value.colors.variables,
      ...colors2
    };
  };
  const getColors = () => {
    return colors;
  };
  const getColor = (prop, defaultColor, preferVariables) => {
    if (!defaultColor) {
      defaultColor = colors.primary;
    }
    if (prop === "transparent") {
      return "#ffffff00";
    }
    if (prop === "currentColor") {
      return prop;
    }
    if (prop == null ? void 0 : prop.startsWith("on")) {
      const colorName = prop.slice(2);
      if (colors[normalizeColorName(colorName)]) {
        return getColor(getTextColor(getColor(colorName)), void 0, preferVariables);
      }
    }
    if (!prop) {
      prop = getColor(defaultColor);
    }
    const colorValue = colors[prop] || colors[normalizeColorName(prop)];
    if (colorValue) {
      return preferVariables ? `var(${cssVariableName(prop)})` : colorValue;
    }
    if (isColor(prop)) {
      return prop;
    }
    if (preferVariables && isCSSVariable(prop)) {
      return prop;
    }
    warn(`'${prop}' is not a proper color! Use HEX or default color themes
      names (https://vuestic.dev/en/styles/colors#default-color-themes)`);
    return getColor(defaultColor);
  };
  const getComputedColor = (color) => {
    return computed({
      get() {
        return getColor(color);
      },
      set(v) {
        setColors({ [color]: v });
      }
    });
  };
  const colorsToCSSVariable = (colors2, prefix2 = "va") => {
    return Object.keys(colors2).filter((key) => colors2[key] !== void 0).reduce((acc, colorName) => {
      acc[`--${prefix2}-${kebabCase$1(colorName)}`] = getColor(colors2[colorName], void 0, true);
      acc[`--${prefix2}-on-${kebabCase$1(colorName)}`] = getColor(getTextColor(getColor(colors2[colorName])), void 0, true);
      return acc;
    }, {});
  };
  const cache = useCache();
  const getColorLightnessFromCache = (color) => {
    if (typeof color !== "string") {
      return getColorLightness(color);
    }
    if (!cache.colorContrast[color]) {
      cache.colorContrast[color] = getColorLightness(color);
    }
    return cache.colorContrast[color];
  };
  const computedDarkColor = computed(() => {
    return getColorLightnessFromCache(getColor("textPrimary")) > 255 / 2 ? "textInverted" : "textPrimary";
  });
  const computedLightColor = computed(() => {
    return getColorLightnessFromCache(getColor("textPrimary")) > 255 / 2 ? "textPrimary" : "textInverted";
  });
  const getTextColor = (color, darkColor, lightColor) => {
    const onColorName = `on${capitalize(String(color))}`;
    if (colors[onColorName]) {
      return colors[onColorName];
    }
    darkColor = darkColor || computedDarkColor.value;
    lightColor = lightColor || computedLightColor.value;
    return getColorLightnessFromCache(color) > globalConfig.value.colors.threshold ? darkColor : lightColor;
  };
  const currentPresetName = computed({
    get: () => globalConfig.value.colors.currentPresetName,
    set: (v) => {
      applyPreset(v);
    }
  });
  const presets2 = computed(() => globalConfig.value.colors.presets);
  const applyPreset = (presetName) => {
    globalConfig.value.colors.currentPresetName = presetName;
    if (!globalConfig.value.colors.presets[presetName]) {
      return warn(`Preset ${presetName} does not exist`);
    }
  };
  return {
    colors,
    currentPresetName,
    presets: presets2,
    applyPreset,
    setColors,
    getColors,
    getColor,
    getComputedColor,
    getBoxShadowColor,
    getBoxShadowColorFromBg,
    getHoverColor,
    getFocusColor,
    getGradientBackground,
    getTextColor,
    shiftHSLAColor,
    setHSLAColor,
    colorsToCSSVariable,
    colorToRgba,
    getStateMaskGradientBackground
  };
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-config/VaConfig.vue_vue_type_script_setup_true_lang.js
var CssVarsRenderer = defineComponent({
  name: "VaCssVarsRenderer",
  inheritAttrs: false,
  setup(props, { slots, attrs }) {
    const { colorsToCSSVariable, colors } = useColors();
    const style = computed(() => {
      return colorsToCSSVariable(colors);
    });
    return () => h(Fragment, attrs, renderSlotNodes(slots.default, {}, {
      style: style.value
    }) || void 0);
  }
});
var _sfc_main = defineComponent({
  ...{
    name: "VaConfig",
    inheritAttrs: false
  },
  __name: "VaConfig",
  props: {
    ...useComponentPresetProp,
    components: { type: Object, default: () => ({}) },
    colors: { type: Object },
    i18n: { type: Object }
  },
  setup(__props) {
    const props = __props;
    const prevChain = useLocalConfig();
    const nextChain = computed(() => [...prevChain.value, props.components]);
    provideLocalConfig(nextChain);
    useGlobalConfigProvider(computed(() => {
      const config = {};
      if (props.colors) {
        config.colors = props.colors;
      }
      if (props.i18n) {
        config.i18n = props.i18n;
      }
      return config;
    }));
    const doRenderCssVars = computed(() => {
      return Boolean(props.colors);
    });
    return (_ctx, _cache) => {
      return doRenderCssVars.value ? (openBlock(), createBlock(unref(CssVarsRenderer), normalizeProps(mergeProps({ key: 0 }, _ctx.$attrs)), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16)) : renderSlot(_ctx.$slots, "default", { key: 1 });
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/composables/useIsMounted.js
var useIsMounted = () => {
  const isMounted = ref(false);
  onMounted(() => {
    isMounted.value = true;
  });
  onBeforeUnmount(() => {
    isMounted.value = false;
  });
  return isMounted;
};

// node_modules/vuestic-ui/dist/web-components/src/composables/useBreakpoint.js
var helpersKeys = ["xs", "sm", "md", "lg", "xl", "smUp", "mdUp", "lgUp", "smDown", "mdDown", "lgDown"];
var defaultHelpers = helpersKeys.reduce((acc, key) => {
  acc[key] = false;
  return acc;
}, {});
var useBreakpoint = () => {
  const injected = inject(vaBreakpointSymbol, {});
  const isMounted = useIsMounted();
  const { globalConfig } = useGlobalConfig();
  const breakpointConfig = computed(() => {
    const breakpoint = globalConfig.value.breakpoint;
    if (!breakpoint) {
      warn("useBreakpoint: breakpointConfig is not defined!");
    }
    return breakpoint ?? {};
  });
  const defaultBreakpoint = computed(() => breakpointConfig.value.enabled ? {
    width: void 0,
    height: void 0,
    current: void 0,
    thresholds: breakpointConfig.value.thresholds,
    ...defaultHelpers
  } : {});
  return useReactiveComputed(() => isMounted.value ? injected : defaultBreakpoint.value);
};

// node_modules/vuestic-ui/dist/web-components/src/composables/useI18n.js
var useI18nConfig = () => {
  const { globalConfig, mergeGlobalConfig } = useGlobalConfig();
  const config = computed(() => globalConfig.value.i18n);
  const mergeIntoConfig = (newConfig) => {
    mergeGlobalConfig({
      i18n: {
        ...config.value,
        ...newConfig
      }
    });
  };
  return {
    config,
    mergeIntoConfig
  };
};

// node_modules/vuestic-ui/dist/web-components/src/services/icon/utils/regex.js
var isMatchRegex = (str, regex) => {
  return regex.test(str);
};
var regexGroupsValues = (str, regex) => {
  if (typeof regex !== "string" && regex.global) {
    return [...str.matchAll(regex)].map((g) => g.slice(1));
  }
  const match = str.match(regex) || [];
  if (!match) {
    return [];
  }
  if (match.length > 1) {
    return match.slice(1);
  }
  return match;
};

// node_modules/vuestic-ui/dist/web-components/src/services/icon/utils/dynamic-segment.js
var dynamicSegmentRegex = /{[^}]*}/g;
var dynamicSegmentStringToRegex = (template) => {
  return template.replace(dynamicSegmentRegex, "(.*)");
};
var dynamicSegmentsNames = (template) => {
  return (template.match(dynamicSegmentRegex) || []).map((g) => g.replace(/{|}/g, ""));
};
var dynamicSegmentsValues = (str, template) => {
  return regexGroupsValues(str, dynamicSegmentStringToRegex(template));
};
var dynamicSegments = (str, template) => {
  const params = dynamicSegmentsNames(template);
  const values = dynamicSegmentsValues(str, template);
  return params.reduce((acc, paramValue, i) => ({ ...acc, [paramValue]: values[i] }), {});
};
var strictMatch = (str, regex) => {
  return (str.match(regex) || [])[0] === str;
};
var isMatchDynamicSegments = (str, template) => {
  const templateRegex = dynamicSegmentStringToRegex(template);
  return strictMatch(str, new RegExp(templateRegex));
};

// node_modules/vuestic-ui/dist/web-components/src/services/icon/types.js
var isIconConfigurationString = (config) => {
  return typeof config.name === "string";
};
var isIconConfigurationRegex = (config) => {
  return config.name instanceof RegExp;
};

// node_modules/vuestic-ui/dist/web-components/src/services/icon/utils/get-icon-configuration.js
var isMatchConfiguration = (iconName, iconConfiguration) => {
  if (isIconConfigurationString(iconConfiguration)) {
    return isMatchDynamicSegments(iconName, iconConfiguration.name);
  }
  if (isIconConfigurationRegex(iconConfiguration)) {
    return isMatchRegex(iconName, iconConfiguration.name);
  }
  return false;
};
var resolveIconConfigurationString = (iconName, iconConfiguration) => {
  const args = dynamicSegments(iconName, iconConfiguration.name);
  return iconConfiguration.resolve && iconConfiguration.resolve(args);
};
var resolveIconConfigurationRegex = (iconName, iconConfig) => {
  if (iconConfig.name.global) {
    throw new Error(`Bad icon config with name ${iconConfig.name}. Please, don't use global regex as name.`);
  }
  const args = regexGroupsValues(iconName, iconConfig.name);
  return iconConfig.resolveFromRegex && iconConfig.resolveFromRegex(...args);
};
var resolveIconConfiguration = (iconName, iconConfiguration) => {
  if (isIconConfigurationString(iconConfiguration)) {
    return resolveIconConfigurationString(iconName, iconConfiguration);
  }
  if (isIconConfigurationRegex(iconConfiguration)) {
    return resolveIconConfigurationRegex(iconName, iconConfiguration);
  }
  throw Error("Unknown icon config");
};
var findMatchedIconConfiguration = (iconName, globalIconConfig, namesToIgnore = []) => {
  const matchedConfig = globalIconConfig.find((config) => {
    if (namesToIgnore.includes(config.name.toString())) {
      return false;
    }
    return isMatchConfiguration(iconName, config);
  });
  if (!matchedConfig) {
    throw new Error(`Can not find icon config from ${iconName}. Please provide default config.`);
  }
  return matchedConfig;
};
var findIconConfiguration = (iconName, globalIconConfig, namesToIgnore = []) => {
  if (!iconName) {
    return;
  }
  const matchedIconConfiguration = findMatchedIconConfiguration(iconName, globalIconConfig, namesToIgnore);
  const resolvedIconConfiguration = merge$1(resolveIconConfiguration(iconName, matchedIconConfiguration), matchedIconConfiguration);
  namesToIgnore = [...namesToIgnore, matchedIconConfiguration.name.toString()];
  return merge$1(
    findIconConfiguration(resolvedIconConfiguration.to, globalIconConfig, namesToIgnore),
    resolvedIconConfiguration
  );
};
var iconPropsFromIconConfiguration = (iconConfiguration) => {
  const junkKeys = ["name", "to", "resolve", "resolveFromRegex"];
  const configuration = iconConfiguration;
  junkKeys.forEach((key) => {
    delete configuration[key];
  });
  return configuration;
};
var getIconConfiguration = (name, iconConfig) => {
  const configuration = findIconConfiguration(name, iconConfig);
  if (configuration === void 0) {
    return {};
  }
  return iconPropsFromIconConfiguration(configuration);
};

// node_modules/vuestic-ui/dist/web-components/src/composables/useIcon.js
var useIcon = () => {
  const { globalConfig } = useGlobalConfig();
  return {
    getIcon: (name) => getIconConfiguration(name, globalConfig.value.icons)
  };
};

// node_modules/vuestic-ui/dist/web-components/src/composables/useTemplateRef.js
var useTemplateRef = (key) => {
  const vm = getCurrentInstance();
  const el = shallowRef();
  const updateEl = () => {
    var _a2;
    el.value = (_a2 = vm.proxy) == null ? void 0 : _a2.$refs[key];
  };
  onMounted(updateEl);
  onUpdated(updateEl);
  onBeforeUnmount(updateEl);
  return el;
};

// node_modules/vuestic-ui/dist/web-components/src/composables/useForm/useForm.js
var useForm = (ref2) => {
  const form = typeof ref2 === "string" ? useTemplateRef(ref2) : ref2;
  return {
    isValid: computed(() => {
      var _a2;
      return ((_a2 = form.value) == null ? void 0 : _a2.isValid) || false;
    }),
    immediate: computed(() => {
      var _a2;
      return ((_a2 = form.value) == null ? void 0 : _a2.immediate) || false;
    }),
    isLoading: computed(() => {
      var _a2;
      return ((_a2 = form.value) == null ? void 0 : _a2.isLoading) || false;
    }),
    isDirty: computed(() => {
      var _a2;
      return ((_a2 = form.value) == null ? void 0 : _a2.isDirty) || false;
    }),
    fields: computed(() => {
      var _a2;
      return ((_a2 = form.value) == null ? void 0 : _a2.fields) ?? [];
    }),
    fieldsNamed: computed(() => {
      var _a2;
      return ((_a2 = form.value) == null ? void 0 : _a2.fieldsNamed) ?? [];
    }),
    fieldNames: computed(() => {
      var _a2;
      return ((_a2 = form.value) == null ? void 0 : _a2.fieldNames) ?? [];
    }),
    formData: computed(() => {
      var _a2;
      return ((_a2 = form.value) == null ? void 0 : _a2.formData) ?? {};
    }),
    errorMessages: computed(() => {
      var _a2;
      return ((_a2 = form.value) == null ? void 0 : _a2.errorMessages) || [];
    }),
    errorMessagesNamed: computed(() => {
      var _a2;
      return ((_a2 = form.value) == null ? void 0 : _a2.errorMessagesNamed) || {};
    }),
    validate: () => {
      var _a2;
      return (_a2 = form.value) == null ? void 0 : _a2.validate();
    },
    validateAsync: () => {
      var _a2;
      return (_a2 = form.value) == null ? void 0 : _a2.validateAsync();
    },
    reset: () => {
      var _a2;
      return (_a2 = form.value) == null ? void 0 : _a2.reset();
    },
    resetValidation: () => {
      var _a2;
      return (_a2 = form.value) == null ? void 0 : _a2.resetValidation();
    },
    focus: () => {
      var _a2;
      return (_a2 = form.value) == null ? void 0 : _a2.focus();
    },
    focusInvalidField: () => {
      var _a2;
      return (_a2 = form.value) == null ? void 0 : _a2.focusInvalidField();
    }
  };
};

// node_modules/vuestic-ui/dist/web-components/src/services/vue-plugin/utils/global-properties.js
var extractGlobalProperties = (app) => app.config.globalProperties;
var defineGlobalProperty = (app, key, v) => {
  const globalProperties = extractGlobalProperties(app);
  globalProperties[key] = v;
};
var getGlobalProperty = (app, key) => {
  return extractGlobalProperties(app)[key];
};

// node_modules/vuestic-ui/dist/web-components/src/services/global-config/plugin/index.js
var GlobalConfigPlugin = defineVuesticPlugin((config = {}) => ({
  install(app) {
    const globalConfig = createGlobalConfig(config);
    if (config == null ? void 0 : config.componentsAll) {
      console.warn("Global config -> `componentsAll` was moved to Global config -> components.all. Please replace this to make it work. More info here: https://github.com/epicmaxco/vuestic-ui/issues/1967");
    }
    app.provide(GLOBAL_CONFIG, globalConfig);
    defineGlobalProperty(app, "$vaConfig", globalConfig);
  }
}));

// node_modules/vuestic-ui/dist/web-components/src/utils/ssr.js
var isServer = () => typeof window === "undefined";
var isClient = () => !isServer();
var getWindow = () => typeof window === "undefined" ? void 0 : window;
var fakeGlobal = {};
var getGlobal = () => {
  if (isServer()) {
    if (typeof globalThis === "undefined") {
      return fakeGlobal;
    }
    return globalThis;
  } else {
    return window;
  }
};

// node_modules/vuestic-ui/dist/web-components/src/utils/uuid.js
var counter = 0;
var getRandomString = (stringLength = 4) => {
  return Math.random().toString(36).substring(2, stringLength + 2);
};
var generateUniqueId = () => {
  return `${getRandomString(8)}-${getRandomString(4)}-${getRandomString(4)}-${++counter}`;
};

// node_modules/vuestic-ui/dist/web-components/src/utils/dom.js
var addOrUpdateStyleElement = (id, getStyles) => {
  if (isServer()) {
    return;
  }
  let stylesElement = document.getElementById(id);
  if (stylesElement) {
    stylesElement.innerHTML = getStyles();
  } else {
    stylesElement = document.createElement("style");
    stylesElement.setAttribute("type", "text/css");
    stylesElement.setAttribute("id", id);
    stylesElement.innerHTML = getStyles();
    document.head.append(stylesElement);
  }
};

// node_modules/vuestic-ui/dist/web-components/src/services/color/plugin/create-color-config-plugin.js
var generateCSSVariable = (key, value) => {
  return `${cssVariableName(key)}: ${value};
`;
};
var createColorConfigPlugin = (app, config) => {
  const { colors: configColors, getTextColor, getColor, currentPresetName, applyPreset } = useColors();
  const renderCSSVariables = (colors = configColors) => {
    if (!colors) {
      return;
    }
    const colorNames = Object.keys(colors);
    const renderedColors = colorNames.map((key) => `${cssVariableName(key)}: ${colors[key]}`).join(";");
    const renderedOnColors = colorNames.map((key) => `${cssVariableName(`on-${key}`)}: ${getColor(getTextColor(colors[key]))}`).join(";");
    return `${renderedColors};${renderedOnColors}`;
  };
  const renderCSSVariablesStyleContent = (colors = configColors) => {
    const colorNames = Object.keys(colors);
    let result = ":root {\n";
    colorNames.forEach((key) => {
      result += generateCSSVariable(key, colors[key]);
    });
    colorNames.forEach((key) => {
      result += generateCSSVariable(`on-${key}`, getColor(getTextColor(colors[key])));
    });
    result += "}\n";
    return result;
  };
  const uniqueId2 = computed(generateUniqueId);
  const updateColors = (newValue) => {
    if (!newValue) {
      return;
    }
    if (isServer()) {
      return;
    }
    const styleContent = renderCSSVariablesStyleContent(newValue);
    addOrUpdateStyleElement(`va-color-variables-${uniqueId2.value}`, () => styleContent);
  };
  watch(configColors, (newValue) => {
    updateColors(newValue);
  }, { immediate: true, deep: true });
  return {
    colors: configColors,
    currentPresetName,
    renderCSSVariables,
    updateColors,
    renderCSSVariablesStyleContent
  };
};

// node_modules/vuestic-ui/dist/web-components/src/services/color/plugin/index.js
var ColorConfigPlugin = defineVuesticPlugin((config) => ({
  install(app) {
    defineGlobalProperty(app, "$vaColorConfig", createColorConfigPlugin());
  }
}));

// node_modules/vuestic-ui/dist/web-components/src/composables/useClientOnly.js
var useClientOnly = (cb) => {
  const isMounted = computed(isClient);
  const result = ref(null);
  watch(isMounted, () => {
    if (isMounted.value) {
      result.value = cb();
    }
  }, { immediate: true });
  return result;
};

// node_modules/vuestic-ui/dist/web-components/src/composables/useWindow.js
var useWindow = () => useClientOnly(() => window);

// node_modules/vuestic-ui/dist/web-components/src/utils/unwrapEl.js
var unwrapEl = (el) => {
  if (!el) {
    return;
  }
  if (typeof el !== "object") {
    return;
  }
  el = unref(el);
  if (!el) {
    return;
  }
  if (typeof el.$el !== "undefined") {
    return el.$el;
  }
  return el;
};

// node_modules/vuestic-ui/dist/web-components/src/utils/add-event-listener.js
var addEventListener = (target, ...args) => {
  if (!target || typeof target !== "object") {
    return;
  }
  if ("addEventListener" in target && typeof target.addEventListener === "function") {
    target.addEventListener(...args);
    return;
  }
  if ("parentElement" in target) {
    addEventListener(target.parentElement, ...args);
  }
};
var removeEventListener = (target, ...args) => {
  if (!target || typeof target !== "object") {
    return;
  }
  if ("removeEventListener" in target && typeof target.removeEventListener === "function") {
    target.removeEventListener(...args);
    return;
  }
  if ("parentElement" in target) {
    removeEventListener(target.parentElement, ...args);
  }
};

// node_modules/vuestic-ui/dist/web-components/src/composables/useEvent.js
var useEvent = (event, listener, target) => {
  const source = target && typeof target !== "boolean" ? target : useWindow();
  const capture = typeof target === "boolean" ? target : false;
  watch(source, (newValue, oldValue) => {
    if (!Array.isArray(event)) {
      addEventListener(unwrapEl(unref(newValue)), event, listener, capture);
      removeEventListener(unwrapEl(unref(oldValue)), event, listener, capture);
    } else {
      event.forEach((e) => {
        addEventListener(unwrapEl(unref(newValue)), e, listener, capture);
        removeEventListener(unwrapEl(unref(oldValue)), e, listener, capture);
      });
    }
  }, { immediate: true });
};

// node_modules/vuestic-ui/dist/web-components/src/composables/useWindowSize.js
function useWindowSize() {
  const windowSizes = reactive({
    width: void 0,
    height: void 0
  });
  const setCurrentWindowSizes = () => {
    windowSizes.width = window == null ? void 0 : window.innerWidth;
    windowSizes.height = window == null ? void 0 : window.innerHeight;
  };
  const isMounted = computed(isClient);
  watch(isMounted, (newValue) => {
    if (!newValue) {
      return;
    }
    setCurrentWindowSizes();
  }, { immediate: true });
  useEvent("resize", setCurrentWindowSizes, true);
  return { windowSizes };
}

// node_modules/vuestic-ui/dist/web-components/src/composables/useDocument.js
var useDocument = () => useClientOnly(() => document);

// node_modules/vuestic-ui/dist/web-components/src/services/breakpoint/plugin/create-service.js
var createBreakpointConfigPlugin = (app) => {
  var _a2;
  const globalConfig = (_a2 = getGlobalProperty(app, "$vaConfig")) == null ? void 0 : _a2.globalConfig;
  if (!globalConfig) {
    warn("createBreakpointConfigPlugin: globalConfig is not defined!");
    return {};
  }
  const breakpointConfig = computed(() => {
    const breakpoint = globalConfig.value.breakpoint;
    if (!breakpoint) {
      warn("createBreakpointConfigPlugin: breakpointConfig is not defined!");
    }
    return breakpoint ?? {};
  });
  if (!breakpointConfig.value.enabled) {
    return {};
  }
  if (!breakpointConfig.value.thresholds || !Object.values(breakpointConfig.value.thresholds).length) {
    warn("createBreakpointConfigPlugin: there are no defined thresholds!");
    return {};
  }
  const { windowSizes } = useWindowSize();
  const isMounted = computed(isClient);
  const currentBreakpoint = computed(() => {
    if (!isMounted.value || !windowSizes.width) {
      return;
    }
    return Object.entries(breakpointConfig.value.thresholds).reduce((acc, [key, value]) => {
      if (windowSizes.width >= value) {
        acc = key;
      }
      return acc;
    }, "xs");
  });
  const screenClasses = computed(() => Object.keys(breakpointConfig.value.thresholds).reduce((acc, threshold) => {
    acc[threshold] = `va-screen-${threshold}`;
    return acc;
  }, {}));
  const generateHelpersMediaCss = () => {
    let result = "";
    Object.values(breakpointConfig.value.thresholds).forEach((thresholdValue, index) => {
      result += `@media screen and (min-width: ${thresholdValue}px) {`;
      result += `:root { --va-media-ratio: ${(index + 1) * 0.2} }`;
      result += "}\n";
    });
    return result;
  };
  const uniqueId2 = computed(generateUniqueId);
  addOrUpdateStyleElement(`va-helpers-media-${uniqueId2.value}`, generateHelpersMediaCss);
  const getDocument = useDocument();
  watch(currentBreakpoint, (newValue) => {
    if (!newValue || !breakpointConfig.value.bodyClass || !getDocument.value) {
      return;
    }
    getDocument.value.body.classList.forEach((className) => {
      if (Object.values(screenClasses.value).includes(className)) {
        getDocument.value.body.classList.remove(className);
      }
    });
    getDocument.value.body.classList.add(screenClasses.value[newValue]);
  }, { immediate: true });
  const breakpointHelpers = computed(() => {
    const isXs = currentBreakpoint.value === "xs";
    const isSm = currentBreakpoint.value === "sm";
    const isMd = currentBreakpoint.value === "md";
    const isLg = currentBreakpoint.value === "lg";
    const isXl = currentBreakpoint.value === "xl";
    return {
      xs: isXs,
      sm: isSm,
      md: isMd,
      lg: isLg,
      xl: isXl,
      smUp: isSm || isMd || isLg || isXl,
      mdUp: isMd || isLg || isXl,
      lgUp: isLg || isXl,
      smDown: isXs || isSm,
      mdDown: isXs || isSm || isMd,
      lgDown: isXs || isSm || isMd || isLg
    };
  });
  return useReactiveComputed(() => ({
    width: windowSizes.width,
    height: windowSizes.height,
    current: currentBreakpoint.value,
    thresholds: breakpointConfig.value.thresholds,
    ...breakpointHelpers.value
  }));
};

// node_modules/vuestic-ui/dist/web-components/src/services/breakpoint/plugin/index.js
var BreakpointConfigPlugin = defineVuesticPlugin(() => ({
  install(app) {
    const breakpointConfig = createBreakpointConfigPlugin(app);
    app.provide(vaBreakpointSymbol, breakpointConfig);
    defineGlobalProperty(app, "$vaBreakpoint", breakpointConfig);
  }
}));

// node_modules/vuestic-ui/dist/web-components/src/composables/useSize.js
var sizesConfig = {
  defaultSize: 48,
  sizes: {
    small: 32,
    medium: 48,
    large: 64
  }
};
var fontSizesConfig = {
  defaultSize: 1,
  sizes: {
    small: 0.75,
    medium: 1,
    large: 1.25
  }
};
var useSizeProps = {
  size: {
    type: [String, Number],
    default: "",
    validator: (size2) => {
      return typeof size2 === "string" || typeof size2 === "number";
    }
  },
  sizesConfig: {
    type: Object,
    default: () => sizesConfig
  },
  fontSizesConfig: {
    type: Object,
    default: () => fontSizesConfig
  }
};
var fontRegex = /(?<fontSize>\d+)(?<extension>px|rem)/i;
var convertToRem = (px) => px / 16 - 0.5;
var sizeToAbsolute = (size2) => {
  if (typeof size2 === "number") {
    return `${size2}px`;
  }
  return String(size2);
};
var doHaveSizesConfig = (props) => "sizesConfig" in props;
var useSizeRef = (props) => {
  const sizePropName = "size";
  return computed(() => {
    let sizePropValue = props[sizePropName];
    if (doHaveSizesConfig(props)) {
      const { defaultSize, sizes } = props.sizesConfig;
      if (isNil$1(sizePropValue)) {
        sizePropValue = defaultSize;
      }
      if (sizes) {
        const sizeFromConfig = sizes[sizePropValue];
        if (sizeFromConfig) {
          return sizeToAbsolute(sizeFromConfig);
        }
      }
    }
    return sizeToAbsolute(sizePropValue);
  });
};
var useSize = (props, componentName2 = ((_a2) => (_a2 = getCurrentInstance()) == null ? void 0 : _a2.type.name)()) => {
  const { getGlobalConfig } = useGlobalConfig();
  const sizesConfigGlobal = computed(() => {
    var _a2, _b;
    return componentName2 ? (_b = (_a2 = getGlobalConfig().components) == null ? void 0 : _a2[componentName2]) == null ? void 0 : _b.sizesConfig : void 0;
  });
  const sizeComputed = computed(() => {
    var _a2, _b, _c;
    const { defaultSize, sizes } = props.sizesConfig;
    const defaultSizeGlobal = (_a2 = sizesConfigGlobal.value) == null ? void 0 : _a2.defaultSize;
    if (!props.size) {
      return `${defaultSize || defaultSizeGlobal}px`;
    }
    if (typeof props.size === "string") {
      const sizeFromGlobalConfig = (_c = (_b = sizesConfigGlobal.value) == null ? void 0 : _b.sizes) == null ? void 0 : _c[props.size];
      const sizeFromProps = sizes[props.size];
      if (sizeFromProps) {
        return `${sizeFromProps}px`;
      }
      if (sizeFromGlobalConfig) {
        return `${sizeFromGlobalConfig}px`;
      }
      return props.size;
    }
    return `${props.size}px`;
  });
  const fontSizeInRem = computed(() => {
    const { defaultSize, sizes } = props.fontSizesConfig;
    if (!props.size) {
      return defaultSize;
    }
    if (typeof props.size === "string") {
      if (props.size in sizes) {
        return sizes[props.size];
      }
      const fontSizeParsed = props.size.match(fontRegex);
      if (!fontSizeParsed || !fontSizeParsed.groups) {
        throw new Error("Size prop should be either valid string or number");
      }
      const { extension, fontSize } = fontSizeParsed.groups;
      return extension === "rem" ? +fontSize : convertToRem(+fontSize);
    }
    return convertToRem(props.size);
  });
  const fontSizeComputed = computed(() => `${fontSizeInRem.value}rem`);
  return {
    sizeComputed,
    fontSizeComputed,
    fontSizeInRem
  };
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-icon/VaIcon.vue_vue_type_script_setup_true_lang.js
var _sfc_main2 = defineComponent({
  ...{
    name: "VaIcon"
  },
  __name: "VaIcon",
  props: {
    ...useSizeProps,
    ...useComponentPresetProp,
    name: { type: String, default: "" },
    tag: { type: String },
    component: { type: Object },
    color: { type: String },
    rotation: { type: [String, Number] },
    spin: { type: [String, Boolean] },
    flip: {
      type: String,
      default: "off",
      validator: (value) => ["off", "horizontal", "vertical", "both"].includes(value)
    }
  },
  setup(__props) {
    const props = __props;
    const { getColor } = useColors();
    const { sizeComputed } = useSize(props);
    const { getIcon } = useIcon();
    const iconConfig = computed(() => getIcon(props.name));
    const computedTag = computed(() => props.component || props.tag || iconConfig.value.component || iconConfig.value.tag || "i");
    const attrs = useAttrs();
    const computedAttrs = computed(() => ({ ...iconConfig.value.attrs, ...omit$1(attrs, ["class"]) }));
    const getSpinClass = (spin) => {
      if (spin === void 0 || spin === false) {
        return;
      }
      return spin === "counter-clockwise" ? "va-icon--spin-reverse" : "va-icon--spin";
    };
    const computedClass = computed(() => [
      iconConfig.value.class,
      getSpinClass(props.spin ?? iconConfig.value.spin)
    ]);
    const transformStyle = computed(() => {
      const rotation = props.rotation ? `rotate(${props.rotation}deg)` : "";
      const flipY = props.flip === "vertical" || props.flip === "both" ? -1 : 1;
      const flipX = props.flip === "horizontal" || props.flip === "both" ? -1 : 1;
      const scale = props.flip === "off" ? "" : `scale(${flipY}, ${flipX})`;
      return `${scale} ${rotation}`.trim();
    });
    const computedStyle = computed(() => ({
      transform: transformStyle.value,
      cursor: attrs.onClick ? "pointer" : null,
      color: props.color ? getColor(props.color, void 0, true) : iconConfig.value.color,
      fontSize: sizeComputed.value,
      height: sizeComputed.value,
      lineHeight: sizeComputed.value
    }));
    const tabindexComputed = computed(() => attrs.tabindex ?? -1);
    const ariaHiddenComputed = computed(() => attrs.role !== "button" || tabindexComputed.value < 0);
    return (_ctx, _cache) => {
      return openBlock(), createBlock(resolveDynamicComponent(computedTag.value), mergeProps({
        class: ["va-icon", computedClass.value],
        style: computedStyle.value,
        "aria-hidden": ariaHiddenComputed.value,
        notranslate: ""
      }, computedAttrs.value), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default", {}, () => [
            iconConfig.value.content ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              createTextVNode(toDisplayString(iconConfig.value.content), 1)
            ], 64)) : createCommentVNode("", true)
          ])
        ]),
        _: 3
      }, 16, ["class", "style", "aria-hidden"]);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/plugin-vue_export-helper.js
var _export_sfc = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-icon/VaIcon.js
var _style_0 = ':root,\n:host {\n  --va-icon-vertical-align: middle;\n  --va-icon-user-select: none;\n}\n.va-icon {\n  vertical-align: var(--va-icon-vertical-align);\n  -webkit-user-select: var(--va-icon-user-select);\n     -moz-user-select: var(--va-icon-user-select);\n          user-select: var(--va-icon-user-select);\n}\n.va-icon[role^=button][tabindex]:not([tabindex^="-"]) {\n  cursor: pointer;\n}\n.va-icon[role^=button][tabindex]:not([tabindex^="-"]):focus-visible {\n  outline: 2px solid var(--va-focus) !important;\n  border-radius: 2px;\n}\n.va-icon.va-icon {\n  font-style: normal;\n}\n.va-icon--spin {\n  animation: va-icon--spin-animation 1500ms linear infinite;\n}\n.va-icon--spin-reverse {\n  animation: va-icon--spin-animation 1500ms linear infinite;\n  animation-direction: reverse;\n}\n@keyframes va-icon--spin-animation {\nfrom {\n    transform: rotate(0deg);\n}\nto {\n    transform: rotate(360deg);\n}\n}\n.va-icon svg {\n  fill: currentColor;\n  height: 100%;\n}';
var _VaIcon = _export_sfc(_sfc_main2, [["styles", [_style_0]]]);

// node_modules/vuestic-ui/dist/web-components/src/composables/useTimer.js
var useTimer = () => {
  let timer;
  const start = (...args) => {
    timer = window.setTimeout(...args);
    return timer;
  };
  const clear = () => timer && window.clearTimeout(timer);
  return {
    start,
    clear
  };
};

// node_modules/vuestic-ui/dist/web-components/src/composables/useTranslation.js
var applyI18nTemplate = (key, values) => {
  if (!values) {
    return key;
  }
  Object.keys(values).forEach((valueKey) => {
    key = key.replace(`{${valueKey}}`, String(values[valueKey]));
  });
  return key;
};
var useTranslation = () => {
  const { globalConfig } = useGlobalConfig();
  const config = computed(() => globalConfig.value.i18n);
  return {
    /** Translate prop. Translate only if key has `$t:` prefix */
    tp: (key, values) => {
      if (!key) {
        return "";
      }
      if (key.startsWith("$t:")) {
        key = config.value[key.slice(3)] || key;
      }
      return applyI18nTemplate(key, values) || key;
    },
    t(key, values) {
      const translated = config.value[key];
      if (!translated) {
        warn(`${key} not found in VuesticUI i18n config`);
        return key;
      }
      return applyI18nTemplate(translated, values) || key;
    }
  };
};

// node_modules/vuestic-ui/dist/web-components/src/composables/useTextColor.js
var useTextColor = (componentColor, isTransparent = false) => {
  const { props } = getCurrentInstance();
  const { getColor, getTextColor } = useColors();
  const textColorComputed = computed(() => {
    if (props.textColor) {
      return getColor(props.textColor);
    }
    const bg = componentColor ? unref(componentColor) : props.color;
    if (!bg) {
      return "currentColor";
    }
    const componentColorHex = getColor(bg);
    if (isColorTransparent(componentColorHex)) {
      return "currentColor";
    }
    return unref(isTransparent) ? componentColorHex : getColor(getTextColor(componentColorHex));
  });
  return { textColorComputed };
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-toast/VaToast.vue_vue_type_script_setup_true_lang.js
var _hoisted_1 = ["role", "aria-live"];
var _hoisted_2 = { class: "va-toast__group" };
var _hoisted_3 = ["textContent"];
var _hoisted_4 = { class: "va-toast__content" };
var _hoisted_5 = ["innerHTML"];
var _hoisted_6 = ["textContent"];
var _hoisted_7 = {
  key: 1,
  class: "va-toast__content"
};
var _sfc_main3 = defineComponent({
  ...{
    name: "VaToast"
  },
  __name: "VaToast",
  props: {
    ...useComponentPresetProp,
    title: { type: String, default: "" },
    offsetY: { type: Number, default: 16 },
    offsetX: { type: Number, default: 16 },
    message: { type: [String, Function], default: "" },
    dangerouslyUseHtmlString: { type: Boolean, default: false },
    icon: { type: String, default: "close" },
    customClass: { type: String, default: "" },
    duration: { type: Number, default: 5e3 },
    color: { type: String, default: "" },
    closeable: { type: Boolean, default: true },
    onClose: { type: Function },
    onClick: { type: Function },
    multiLine: { type: Boolean, default: false },
    position: {
      type: String,
      default: "top-right",
      validator: (value) => ["top-right", "top-left", "bottom-right", "bottom-left"].includes(value)
    },
    render: { type: Function },
    ariaCloseLabel: { type: String, default: "$t:close" },
    role: { type: String, default: void 0 },
    inline: { type: Boolean, default: false }
  },
  emits: ["on-click", "on-close"],
  setup(__props, { emit: __emit }) {
    const VaToastRenderer = defineComponent({
      name: "VaToastRenderer",
      props: {
        render: { type: Function, required: true }
      },
      setup: (props2) => () => props2.render()
    });
    const { tp } = useTranslation();
    const props = __props;
    const emit = __emit;
    const rootElement = shallowRef();
    const { getColor } = useColors();
    const { textColorComputed } = useTextColor(computed(() => getColor(props.color)));
    const visible = ref(false);
    const positionX = computed(() => {
      return props.position.includes("right") ? "right" : "left";
    });
    const positionY = computed(() => {
      return props.position.includes("top") ? "top" : "bottom";
    });
    const toastClasses = computed(() => [
      props.customClass,
      props.multiLine ? "va-toast--multiline" : "",
      props.inline ? "va-toast--inline" : ""
    ]);
    const toastStyles = computed(() => ({
      [positionY.value]: `${props.offsetY}px`,
      [positionX.value]: `${props.offsetX}px`,
      backgroundColor: getColor(props.color),
      color: textColorComputed.value
    }));
    const computedAriaLive = computed(() => {
      if (props.role === "status") {
        return "polite";
      } else {
        return "assertive";
      }
    });
    const computedMessage = computed(() => typeof props.message === "function" ? props.message() : props.message);
    const destroyElement = () => {
      var _a2, _b;
      (_a2 = rootElement.value) == null ? void 0 : _a2.removeEventListener("transitionend", destroyElement);
      (_b = rootElement.value) == null ? void 0 : _b.remove();
    };
    const onToastClick = () => {
      if (typeof props.onClick === "function") {
        props.onClick();
      } else {
        emit("on-click");
      }
    };
    const onToastClose = () => {
      var _a2;
      visible.value = false;
      (_a2 = rootElement.value) == null ? void 0 : _a2.addEventListener("transitionend", destroyElement);
      if (typeof props.onClose === "function") {
        props.onClose();
      } else {
        emit("on-close");
      }
    };
    const timer = useTimer();
    const clearTimer = timer.clear;
    const startTimer = () => {
      if (props.duration > 0) {
        timer.start(() => visible.value && onToastClose(), props.duration);
      }
    };
    onMounted(() => {
      visible.value = true;
      startTimer();
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(Transition, { name: "va-toast-fade" }, {
        default: withCtx(() => [
          withDirectives(createBaseVNode("div", {
            ref_key: "rootElement",
            ref: rootElement,
            role: _ctx.$props.role ?? _ctx.$props.closeable ? "alertdialog" : "alert",
            "aria-live": computedAriaLive.value,
            "aria-atomic": "true",
            class: normalizeClass(["va-toast", toastClasses.value]),
            style: normalizeStyle(toastStyles.value),
            onMouseenter: _cache[0] || (_cache[0] = //@ts-ignore
            (...args) => unref(clearTimer) && unref(clearTimer)(...args)),
            onMouseleave: startTimer,
            onClick: onToastClick
          }, [
            createBaseVNode("div", _hoisted_2, [
              _ctx.$props.title ? (openBlock(), createElementBlock("h2", {
                key: 0,
                class: "va-toast__title",
                textContent: toDisplayString(_ctx.$props.title)
              }, null, 8, _hoisted_3)) : createCommentVNode("", true),
              withDirectives(createBaseVNode("div", _hoisted_4, [
                _ctx.$props.dangerouslyUseHtmlString ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  innerHTML: computedMessage.value
                }, null, 8, _hoisted_5)) : (openBlock(), createElementBlock("p", {
                  key: 1,
                  textContent: toDisplayString(computedMessage.value)
                }, null, 8, _hoisted_6))
              ], 512), [
                [vShow, _ctx.$props.message]
              ]),
              _ctx.$props.render ? (openBlock(), createElementBlock("div", _hoisted_7, [
                createVNode(unref(VaToastRenderer), {
                  render: _ctx.$props.render
                }, null, 8, ["render"])
              ])) : createCommentVNode("", true),
              _ctx.$props.closeable ? (openBlock(), createBlock(_VaIcon, {
                key: 2,
                class: "va-toast__close-icon",
                role: "button",
                "aria-label": unref(tp)(_ctx.$props.ariaCloseLabel),
                tabindex: "0",
                size: "1rem",
                name: _ctx.$props.icon,
                onClick: withModifiers(onToastClose, ["stop"]),
                onKeydown: withKeys(withModifiers(onToastClose, ["stop"]), ["enter"])
              }, null, 8, ["aria-label", "name", "onKeydown"])) : createCommentVNode("", true)
            ])
          ], 46, _hoisted_1), [
            [vShow, visible.value]
          ])
        ]),
        _: 1
      });
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-toast/VaToast.js
var _style_02 = ":root,\n:host {\n  --va-toast-display: flex;\n  --va-toast-width: 330px;\n  --va-toast-padding: 14px 26px 14px 13px;\n  --va-toast-border-radius: 8px;\n  --va-toast-border-color: transparent;\n  --va-toast-border: 1px solid var(--va-toast-border-color);\n  --va-toast-background-color: var(--va-background-secondary);\n  --va-toast-box-shadow: 0 2px 12px 0 var(--va-shadow);\n  --va-toast-transition: opacity 0.3s, transform 0.3s, left 0.3s, right 0.3s, top 0.4s, bottom 0.3s;\n  --va-toast-z-index: calc(var(--va-z-index-teleport-overlay) + 100);\n  /* Group */\n  --va-toast-group-margin-left: 13px;\n  --va-toast-group-margin-right: 8px;\n  /* Title */\n  --va-toast-title-font-weight: bold;\n  --va-toast-title-font-size: 1rem;\n  --va-toast-title-color: #303133;\n  --va-toast-title-margin: 0 0 6px;\n  /* Content */\n  --va-toast-content-font-size: 1rem;\n  --va-toast-content-line-height: 1.3125;\n  --va-toast-content-padding-right: 20px;\n  /* Icon */\n  --va-toast-icon-height: 24px;\n  --va-toast-icon-width: 24px;\n  --va-toast-icon-font-size: 24px;\n  /* Icon Close */\n  --va-toast-close-icon-top: 18px;\n  --va-toast-close-icon-right: 15px;\n  --va-toast-close-icon-font-size: 1rem;\n}\n.va-toast {\n  position: fixed;\n  box-sizing: border-box;\n  width: var(--va-toast-width);\n  padding: var(--va-toast-padding);\n  display: flex;\n  align-items: center;\n  border-radius: var(--va-toast-border-radius);\n  border: var(--va-toast-border);\n  background-color: var(--va-toast-background-color);\n  box-shadow: var(--va-toast-box-shadow);\n  transition: var(--va-toast-transition);\n  overflow: hidden;\n  z-index: var(--va-toast-z-index);\n  font-family: var(--va-font-family);\n}\n.va-toast--inline {\n  position: static;\n}\n.va-toast--multiline {\n  min-height: 70px;\n}\n.va-toast--right {\n  right: 16px;\n}\n.va-toast--left {\n  left: 16px;\n}\n.va-toast__group {\n  margin-left: var(--va-toast-group-margin-left);\n  margin-right: var(--va-toast-group-margin-right);\n}\n.va-toast__title {\n  font-weight: var(--va-toast-title-font-weight);\n  font-size: var(--va-toast-title-font-size);\n  margin: var(--va-toast-title-margin);\n  font-size: 0.625rem;\n  letter-spacing: 0.6px;\n  line-height: 1.2;\n  font-weight: 700;\n  text-transform: uppercase;\n}\n.va-toast__content {\n  font-size: var(--va-toast-content-font-size);\n  line-height: var(--va-toast-content-line-height);\n  padding-right: var(--va-toast-content-padding-right);\n}\n.va-toast__content p,\n.va-toast__content div {\n  margin: 0;\n}\n.va-toast__icon {\n  height: var(--va-toast-icon-height);\n  width: var(--va-toast-icon-width);\n  font-size: var(--va-toast-icon-font-size);\n}\n.va-toast__close-icon {\n  position: absolute;\n  top: 50%;\n  right: var(--va-toast-close-icon-right);\n  cursor: pointer;\n  transform: translateY(-50%);\n  font-size: var(--va-toast-close-icon-font-siz);\n  opacity: 0.7;\n}\n.va-toast__close-icon:hover {\n  opacity: 1;\n}\n.va-toast-fade-enter.right {\n  right: 0;\n  transform: translateX(100%);\n}\n.va-toast-fade-enter.left {\n  left: 0;\n  transform: translateX(-100%);\n}\n.va-toast-fade-leave-active {\n  opacity: 0;\n}";
var _VaToast = _export_sfc(_sfc_main3, [["styles", [_style_02]]]);

// node_modules/vuestic-ui/dist/web-components/src/services/component-config/utils/use-component-config-props.js
var useComponentConfigProps = (component, originalProps) => {
  const localConfig = useLocalConfig();
  const { globalConfig } = useGlobalConfig();
  const instancePreset = computed(() => originalProps.preset);
  const getPresetProps = (presetName) => {
    var _a2, _b, _c;
    return (_c = (_b = (_a2 = globalConfig.value.components) == null ? void 0 : _a2.presets) == null ? void 0 : _b[component.name]) == null ? void 0 : _c[presetName];
  };
  return computed(() => {
    var _a2, _b;
    const globalConfigProps = {
      ...(_a2 = globalConfig.value.components) == null ? void 0 : _a2.all,
      ...(_b = globalConfig.value.components) == null ? void 0 : _b[component.name]
    };
    const localConfigProps = localConfig.value.reduce(
      (finalConfig, config) => config[component.name] ? { ...finalConfig, ...config[component.name] } : finalConfig,
      {}
    );
    const presetName = instancePreset.value || localConfigProps.preset || globalConfigProps.preset;
    const presetProps = presetName && getPresetProps(presetName);
    return { ...globalConfigProps, ...localConfigProps, ...presetProps };
  });
};

// node_modules/vuestic-ui/dist/web-components/src/services/config-transport/createProxyComponent.js
var KEBAB_CASE_REGEX = /([a-z0-9])([A-Z])/g;
var toKebabCase = (str) => str.replace(KEBAB_CASE_REGEX, "$1-$2").toLowerCase();
var findCamelCased = (obj, key) => {
  if (key in obj) {
    return obj[key];
  }
  return obj[toKebabCase(key)];
};
var createPropsWithCustomConfig = (instance, propsFromConfig) => {
  const instanceProps = instance.props;
  return new Proxy(instanceProps, {
    get: (target, key) => {
      var _a2;
      if (typeof key !== "string") {
        return target[key];
      }
      const incomingProps = instance.vnode.props || {};
      const originalProp = target[key];
      const propFromConfig = (_a2 = propsFromConfig.value) == null ? void 0 : _a2[key];
      const incomingProp = findCamelCased(incomingProps, key);
      if (incomingProp !== void 0) {
        return originalProp;
      }
      if (propFromConfig !== void 0) {
        return propFromConfig;
      }
      return originalProp;
    }
  });
};
var createAttrsWithCustomConfig = (instance, propsFromConfig) => {
  const instanceAttrs = instance.attrs;
  return new Proxy(instanceAttrs, {
    get: (target, key) => {
      var _a2;
      if (typeof key !== "string") {
        return target[key];
      }
      if (key === "class") {
        return normalizeClass([propsFromConfig.value.class, instanceAttrs.class]);
      }
      if (key === "style") {
        return normalizeStyle([propsFromConfig.value.style, instanceAttrs.style]);
      }
      const attrFromConfig = (_a2 = propsFromConfig.value) == null ? void 0 : _a2[key];
      if (attrFromConfig !== void 0) {
        return attrFromConfig;
      }
      return target[key];
    },
    ownKeys(target) {
      return [.../* @__PURE__ */ new Set([...Object.keys(instanceAttrs), ...Object.keys(propsFromConfig.value)])];
    },
    getOwnPropertyDescriptor(target, key) {
      return Reflect.getOwnPropertyDescriptor(propsFromConfig.value, key) ?? Reflect.getOwnPropertyDescriptor(instanceAttrs, key);
    }
  });
};
var createProxyComponent = (component) => {
  const customSetup = (originalProps, ctx) => {
    var _a2;
    const instance = getCurrentInstance();
    const propsFromConfig = useComponentConfigProps(component, originalProps);
    const attrsFromConfig = computed(() => {
      return omit$1(propsFromConfig.value, Object.keys(originalProps));
    });
    const props = createPropsWithCustomConfig(instance, propsFromConfig);
    const attrs = createAttrsWithCustomConfig(instance, attrsFromConfig);
    instance.props = props;
    instance.attrs = attrs;
    const setupState = (_a2 = component.setup) == null ? void 0 : _a2.call(component, shallowReadonly(props), {
      ...ctx,
      attrs
    });
    if (typeof setupState === "object" && !instance.exposed) {
      ctx.expose(setupState);
    }
    return setupState;
  };
  return new Proxy(component, {
    get(target, key) {
      if (key === "setup") {
        return customSetup;
      }
      return target[key];
    }
  });
};

// node_modules/vuestic-ui/dist/web-components/src/services/config-transport/withConfigTransport.js
var CLASS_COMPONENT_KEY = "__c";
var patchClassComponent = (component) => {
  component[CLASS_COMPONENT_KEY] = createProxyComponent(component[CLASS_COMPONENT_KEY]);
  return component;
};
var withConfigTransport = (component) => {
  if ("setup" in component) {
    return createProxyComponent(component);
  } else if (CLASS_COMPONENT_KEY in component) {
    return patchClassComponent(component);
  } else {
    component.setup = () => ({
      /* Fake setup function */
    });
    return createProxyComponent(component);
  }
};
var withConfigTransport$1 = withConfigTransport;

// node_modules/vuestic-ui/dist/web-components/src/components/va-toast/toast.js
var VaToast = withConfigTransport(_VaToast);
var GAP = 5;
var seed = 1;
getGlobal().vaToastInstances = [];
var getTranslateValue = (item, position) => {
  if (item.el) {
    const direction = position.includes("bottom") ? -1 : 1;
    return (item.el.offsetHeight + GAP) * direction;
  }
  return 0;
};
var getNewTranslateValue = (transformY, redundantHeight, position) => {
  const direction = position.includes("bottom") ? -1 : 1;
  return parseInt(transformY, 10) - (redundantHeight + GAP) * direction;
};
var getNodeProps = (vNode) => {
  var _a2;
  return ((_a2 = vNode.component) == null ? void 0 : _a2.props) || {};
};
var closeNotification = (targetInstance, destroyElementFn) => {
  var _a2;
  if (!targetInstance) {
    return;
  }
  if (!getGlobal().vaToastInstances.length) {
    seed = 1;
    return;
  }
  const targetInstanceIndex = getGlobal().vaToastInstances.findIndex((instance) => instance === targetInstance);
  if (targetInstanceIndex < 0) {
    return;
  }
  const nodeProps = getNodeProps(targetInstance);
  const {
    offsetX: targetOffsetX,
    offsetY: targetOffsetY,
    position: targetPosition
  } = nodeProps;
  const redundantHeight = (_a2 = targetInstance.el) == null ? void 0 : _a2.offsetHeight;
  destroyElementFn();
  getGlobal().vaToastInstances = getGlobal().vaToastInstances.reduce((acc, instance, index) => {
    if (instance === targetInstance) {
      return acc;
    }
    if (instance.component) {
      const { offsetX, offsetY, position } = getNodeProps(instance);
      const isNextInstance = index > targetInstanceIndex && targetOffsetX === offsetX && targetOffsetY === offsetY && targetPosition === position;
      if (isNextInstance && instance.el && redundantHeight) {
        const [_, transformY] = instance.el.style.transform.match(/[\d-]+(?=px)/g);
        const transformYNew = getNewTranslateValue(transformY, redundantHeight, position);
        instance.el.style.transform = `translate(0, ${transformYNew}px)`;
      }
    }
    return [...acc, instance];
  }, []);
  if (!getGlobal().vaToastInstances.length) {
    seed = 1;
  }
};
var destroy = (el, node) => {
  if (el) {
    render(null, el);
    el.remove();
  }
  el = null;
};
var mount = (component, {
  props,
  children,
  element,
  appContext
} = {}) => {
  let el = element;
  let vNode;
  const onClose = () => {
    closeNotification(vNode, () => destroy(el));
    if (props == null ? void 0 : props.onClose) {
      props.onClose();
    }
  };
  vNode = createVNode(component, { ...props, onClose }, children);
  if (appContext) {
    vNode.appContext = appContext;
  }
  if (el) {
    render(vNode, el);
  } else if (typeof document !== "undefined") {
    render(vNode, el = document.createElement("div"));
  }
  return { vNode, el };
};
var closeAllNotifications = (appContext) => {
  if (!getGlobal().vaToastInstances.length) {
    seed = 1;
    return;
  }
  getGlobal().vaToastInstances.forEach((instance) => {
    if (appContext && instance.appContext !== appContext) {
      return;
    }
    getNodeProps(instance).onClose();
  });
};
var closeById = (id) => {
  const targetInstance = getGlobal().vaToastInstances.find((instance) => {
    var _a2;
    return ((_a2 = instance.el) == null ? void 0 : _a2.id) === id;
  });
  if (targetInstance) {
    const nodeProps = getNodeProps(targetInstance);
    nodeProps.onClose();
  }
};
var getToastOptions = (options) => {
  if (typeof options === "string") {
    return {
      message: options
    };
  }
  return options;
};
var createToastInstance = (customProps, appContext) => {
  const { vNode, el } = mount(VaToast, { appContext, props: getToastOptions(customProps) });
  const nodeProps = getNodeProps(vNode);
  if (el && vNode.el && nodeProps) {
    document.body.appendChild(el.childNodes[0]);
    const { offsetX, offsetY, position } = nodeProps;
    vNode.el.style.display = "flex";
    vNode.el.id = "notification_" + seed;
    let transformY = 0;
    getGlobal().vaToastInstances.filter((item) => {
      const {
        offsetX: itemOffsetX,
        offsetY: itemOffsetY,
        position: itemPosition
      } = getNodeProps(item);
      return itemOffsetX === offsetX && itemOffsetY === offsetY && position === itemPosition;
    }).forEach((item) => {
      transformY += getTranslateValue(item, position);
    });
    vNode.el.style.transform = `translate(0, ${transformY}px)`;
    seed += 1;
    getGlobal().vaToastInstances.push(vNode);
    return vNode.el.id;
  }
  return null;
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-toast/plugin/index.js
var createVaToastPlugin = (app) => ({
  /** Returns toast instance id */
  init(options) {
    return createToastInstance(options, app == null ? void 0 : app._context);
  },
  close(id) {
    closeById(id);
  },
  closeAll(allApps = false) {
    closeAllNotifications(allApps ? void 0 : app == null ? void 0 : app._context);
  }
});
var VaToastPlugin = defineVuesticPlugin(() => ({
  install(app) {
    defineGlobalProperty(app, "$vaToast", createVaToastPlugin(app));
  }
}));

// node_modules/vuestic-ui/dist/web-components/src/components/va-dropdown/plugin/index.js
var vaDropdownPlugin = {
  closeDropdown() {
    let vm = this;
    while (vm = vm.$parent) {
      const name = vm.$options.name;
      if (name === "VaDropdown") {
        vm.hide();
        break;
      }
    }
  }
};
var VaDropdownPlugin = defineVuesticPlugin(() => ({
  install(app) {
    defineGlobalProperty(app, "$closeDropdown", vaDropdownPlugin.closeDropdown);
    defineGlobalProperty(app, "$vaDropdown", vaDropdownPlugin);
  }
}));

// node_modules/vuestic-ui/dist/web-components/src/components/va-button/hooks/useButtonBackground.js
var useButtonBackground = (colorComputed, isPressed, isHovered) => {
  const instance = getCurrentInstance();
  if (!instance) {
    throw new Error("`useButtonBackground` hook must be used only inside of setup function!");
  }
  const props = instance.props;
  const { getColor, getGradientBackground: getGradientBackground2 } = useColors();
  const backgroundColor = computed(() => {
    if (props.plain) {
      return "transparent";
    }
    return props.gradient ? getGradientBackground2(colorComputed.value) : colorComputed.value;
  });
  const hoveredBgState = computed(() => !props.plain && isHovered.value);
  const pressedBgState = computed(() => !props.plain && isPressed.value);
  const backgroundColorOpacity = computed(() => {
    if (pressedBgState.value && props.pressedBehavior === "opacity") {
      return props.pressedOpacity;
    }
    if (hoveredBgState.value && props.hoverBehavior === "opacity") {
      return props.hoverOpacity;
    }
    return props.backgroundOpacity;
  });
  const hoveredMaskState = computed(() => hoveredBgState.value && props.hoverBehavior === "mask");
  const pressedMaskState = computed(() => pressedBgState.value && props.pressedBehavior === "mask");
  const backgroundMaskOpacity = computed(() => {
    if (pressedMaskState.value) {
      return props.pressedOpacity;
    }
    if (hoveredMaskState.value) {
      return props.hoverOpacity;
    }
    return 0;
  });
  const backgroundMaskColor = computed(() => {
    if (pressedMaskState.value) {
      return getColor(props.pressedMaskColor);
    }
    if (hoveredMaskState.value) {
      return getColor(props.hoverMaskColor);
    }
    return "transparent";
  });
  return {
    backgroundColor,
    backgroundColorOpacity,
    backgroundMaskOpacity,
    backgroundMaskColor
  };
};

// node_modules/vuestic-ui/dist/web-components/src/composables/useRouterLink.js
var useRouterLinkProps = {
  tag: { type: String, default: "span" },
  to: { type: [String, Object], default: void 0 },
  replace: { type: Boolean, default: void 0 },
  append: { type: Boolean, default: void 0 },
  exact: { type: Boolean, default: void 0 },
  activeClass: { type: String, default: void 0 },
  exactActiveClass: { type: String, default: void 0 },
  href: { type: String, default: void 0 },
  target: { type: String, default: void 0 },
  disabled: { type: Boolean, default: false }
};
var useRouterLink = (props) => {
  var _a2;
  const currentInstance = getCurrentInstance();
  const globalProperties = computed(() => currentInstance == null ? void 0 : currentInstance.appContext.config.globalProperties);
  const vueRouter = computed(() => {
    var _a22;
    return (_a22 = globalProperties.value) == null ? void 0 : _a22.$router;
  });
  const vueRoute = computed(() => {
    var _a22;
    return (_a22 = globalProperties.value) == null ? void 0 : _a22.$route;
  });
  const { getGlobalConfig } = useGlobalConfig();
  const routerComponent = getGlobalConfig().routerComponent;
  const isNuxt = !!((_a2 = globalProperties.value) == null ? void 0 : _a2.$nuxt);
  const isNuxtLink = computed(() => !!(!props.disabled && props.to && isNuxt && routerComponent));
  const tagComputed = computed(() => {
    if (props.disabled) {
      return props.tag;
    }
    if (props.href && !props.to) {
      return "a";
    }
    if (isNuxtLink.value) {
      return routerComponent;
    }
    if (props.to) {
      return "router-link";
    }
    return props.tag || "div";
  });
  const isLinkTag = computed(() => isNuxtLink.value || ["a", "router-link"].includes(tagComputed.value));
  const linkAttributesComputed = computed(() => {
    if (!isLinkTag.value) {
      return {};
    }
    return tagComputed.value === "a" ? {
      target: props.target,
      href: hrefComputed.value
    } : {
      target: props.target,
      to: props.to,
      replace: props.replace,
      append: props.append,
      activeClass: props.activeClass,
      exact: props.exact,
      exactActiveClass: props.exactActiveClass
    };
  });
  const isActiveRouterLink = computed(() => {
    if (!vueRouter.value || !props.to) {
      return false;
    }
    const to = vueRouter.value.resolve(props.to).href;
    const currentHref = vueRouter.value.currentRoute.value.path;
    return to.replace("#", "") === currentHref.replace("#", "");
  });
  const hrefComputed = computed(() => {
    var _a22;
    return props.href || (props.to ? (_a22 = vueRouter.value) == null ? void 0 : _a22.resolve(props.to, vueRoute.value).href : void 0);
  });
  return {
    isLinkTag,
    tagComputed,
    hrefComputed,
    isActiveRouterLink,
    linkAttributesComputed
  };
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-button/hooks/useButtonAttributes.js
var useButtonAttributes = (props) => {
  const { linkAttributesComputed, isLinkTag } = useRouterLink(props);
  const typeComputed = computed(() => isLinkTag.value ? void 0 : props.type);
  const buttonAttributesComputed = computed(() => {
    const disabledAttributes = {
      "aria-disabled": !!props.disabled,
      disabled: !!props.disabled
    };
    if (isLinkTag.value) {
      return disabledAttributes;
    }
    return {
      type: typeComputed.value,
      tabindex: props.loading || props.disabled ? -1 : 0,
      ...disabledAttributes
    };
  });
  return computed(() => ({ ...linkAttributesComputed.value, ...buttonAttributesComputed.value }));
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-button/hooks/useButtonTextColor.js
var getOpacity = (opacity) => {
  var _a2, _b, _c;
  if (isServer()) {
    return opacity;
  }
  if (opacity > 0) {
    const userAgent = (_a2 = window == null ? void 0 : window.navigator) == null ? void 0 : _a2.userAgent;
    const isSafari = userAgent && /^((?!chrome|android).)*safari/i.test((_b = window == null ? void 0 : window.navigator) == null ? void 0 : _b.userAgent);
    const isLatestSafari = userAgent && /(version.)15|16/i.test((_c = window == null ? void 0 : window.navigator) == null ? void 0 : _c.userAgent);
    if (isSafari && !isLatestSafari) {
      return opacity < 1 ? 1 - opacity : opacity;
    }
  }
  return opacity;
};
var useButtonTextColor = (textColorComputed, colorComputed, isPressed, isHovered) => {
  const instance = getCurrentInstance();
  if (!instance) {
    throw new Error("`useButtonTextColor` hook must be used only inside of setup function!");
  }
  const props = instance.props;
  const { getColor, colorToRgba: colorToRgba2, getStateMaskGradientBackground: getStateMaskGradientBackground2 } = useColors();
  const plainColorStyles = computed(() => ({
    background: "transparent",
    color: textColorComputed.value,
    "-webkit-background-clip": "text",
    "background-clip": "text",
    opacity: getPlainTextOpacity.value
  }));
  const getStateColor = (maskColor, stateOpacity, stateBehavior) => {
    const maskStateColor = getColor(maskColor);
    let stateStyles;
    if (stateBehavior === "opacity") {
      stateStyles = { color: colorToRgba2(textColorComputed.value, stateOpacity) };
    } else {
      stateStyles = {
        background: getStateMaskGradientBackground2(colorComputed.value, maskStateColor, stateOpacity),
        color: stateOpacity < 1 ? colorToRgba2(textColorComputed.value, getOpacity(stateOpacity)) : maskStateColor
      };
    }
    return { ...plainColorStyles.value, ...stateStyles };
  };
  const hoverTextColorComputed = computed(() => {
    return getStateColor(props.hoverMaskColor, props.hoverOpacity, props.hoverBehavior);
  });
  const pressedTextColorComputed = computed(() => {
    return getStateColor(props.pressedMaskColor, props.pressedOpacity, props.pressedBehavior);
  });
  const getPlainTextOpacity = computed(() => {
    if (props.disabled) {
      return void 0;
    }
    if (props.textOpacity === 1 || isHovered.value && !isPressed.value) {
      return 1;
    }
    return isPressed.value ? 0.9 : props.textOpacity;
  });
  return computed(() => {
    const defaultColorStyles = {
      color: textColorComputed.value,
      background: "transparent"
    };
    props.plain && Object.assign(defaultColorStyles, plainColorStyles.value, { background: textColorComputed.value });
    if (!props.plain) {
      return defaultColorStyles;
    }
    if (isPressed.value) {
      return pressedTextColorComputed.value;
    }
    if (isHovered.value) {
      return hoverTextColorComputed.value;
    }
    return defaultColorStyles;
  });
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-icon/index.js
var VaIcon = withConfigTransport$1(_VaIcon);

// node_modules/vuestic-ui/dist/web-components/src/components/va-progress-circle/VaProgressCircle.vue_vue_type_script_setup_true_lang.js
var _hoisted_12 = {
  class: "va-progress-circle__wrapper",
  viewBox: "0 0 40 40"
};
var _hoisted_22 = ["r", "stroke", "stroke-width", "stroke-dasharray", "stroke-dashoffset"];
var _sfc_main4 = defineComponent({
  ...{
    name: "VaProgressCircle"
  },
  __name: "VaProgressCircle",
  props: {
    ...useSizeProps,
    ...useComponentPresetProp,
    modelValue: { type: Number, default: 0 },
    indeterminate: { type: Boolean, default: false },
    thickness: { type: Number, default: 0.06 },
    color: { type: String, default: "primary" },
    ariaLabel: { type: String, default: "$t:progressState" }
  },
  setup(__props) {
    const props = __props;
    const { getColor } = useColors();
    const { sizeComputed } = useSize(props);
    const cappedThickness = computed(() => clamp$1(props.thickness, 0, 1) / 2 * 100);
    const radius = computed(() => 20 - 20 * cappedThickness.value / 100);
    const dasharray = computed(() => 2 * Math.PI * radius.value);
    const dashoffset = computed(() => dasharray.value * (1 - clamp$1(props.modelValue, 0, 100) / 100));
    const colorComputed = computed(() => getColor(props.color, void 0, true));
    const { tp } = useTranslation();
    const infoStyle = computed(() => ({ color: colorComputed.value }));
    const rootStyle = computed(() => ({
      width: sizeComputed.value,
      height: sizeComputed.value
    }));
    const rootClass = computed(() => ({
      "va-progress-circle--indeterminate": props.indeterminate
    }));
    const ariaAttributesComputed = computed(() => ({
      role: "progressbar",
      "aria-label": tp(props.ariaLabel),
      "aria-valuenow": !props.indeterminate ? props.modelValue : void 0
    }));
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", mergeProps({
        class: ["va-progress-circle", rootClass.value],
        style: rootStyle.value
      }, ariaAttributesComputed.value), [
        (openBlock(), createElementBlock("svg", _hoisted_12, [
          createBaseVNode("circle", {
            class: "va-progress-circle__overlay",
            cx: "50%",
            cy: "50%",
            r: radius.value,
            fill: "none",
            stroke: colorComputed.value,
            "stroke-width": cappedThickness.value + "%",
            "stroke-dasharray": dasharray.value,
            "stroke-dashoffset": dashoffset.value
          }, null, 8, _hoisted_22)
        ])),
        _ctx.$slots.default ? (openBlock(), createElementBlock("div", {
          key: 0,
          style: normalizeStyle(infoStyle.value),
          class: "va-progress-circle__info"
        }, [
          renderSlot(_ctx.$slots, "default")
        ], 4)) : createCommentVNode("", true)
      ], 16);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-progress-circle/VaProgressCircle.js
var _style_03 = ":root,\n:host {\n  /* Circle */\n  --va-progress-circle-position: relative;\n  --va-progress-circle-overflow: hidden;\n  /* Circle Wrapper */\n  --va-progress-circle-width: 80%;\n  --va-progress-circle-height: 80%;\n  /* Circle Overlay */\n  --va-progress-circle-overlay-transition: all ease 2s;\n  /* Circle Info */\n  --va-progress-circle-font-size: 0.75rem;\n}\n.va-progress-circle {\n  position: var(--va-progress-circle-position);\n  overflow: var(--va-progress-circle-overflow);\n  font-family: var(--va-font-family);\n}\n.va-progress-circle__wrapper {\n  position: absolute;\n  top: 0;\n  left: 0;\n  bottom: 0;\n  right: 0;\n  margin: auto;\n  transform: rotate(-90deg);\n  width: var(--va-progress-circle-width);\n  height: var(--va-progress-circle-height);\n  display: flex;\n  justify-content: center;\n  align-items: center;\n}\n.va-progress-circle--indeterminate .va-progress-circle__wrapper {\n  animation: va-progress-circle__wrapper--indeterminate 2s linear infinite;\n}\n.va-progress-circle__overlay {\n  transition: var(--va-progress-circle-overlay-transition);\n}\n.va-progress-circle--indeterminate .va-progress-circle__overlay {\n  animation: va-progress-circle__overlay--indeterminate 2s ease-in-out infinite;\n}\n.va-progress-circle__info {\n  font-size: var(--va-progress-circle-font-size);\n  position: absolute;\n  left: 50%;\n  top: 50%;\n  transform: translate(-50%, -50%);\n}\n@keyframes va-progress-circle__wrapper--indeterminate {\n100% {\n    transform: rotate(270deg);\n}\n}\n@keyframes va-progress-circle__overlay--indeterminate {\n0% {\n    stroke-dasharray: 1, 125;\n    stroke-dashoffset: 0;\n}\n50% {\n    stroke-dasharray: 125, 125;\n    stroke-dashoffset: -65px;\n}\n100% {\n    stroke-dasharray: 125, 125;\n    stroke-dashoffset: -125px;\n}\n}";
var _VaProgressCircle = _export_sfc(_sfc_main4, [["styles", [_style_03]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-progress-circle/index.js
var VaProgressCircle = withConfigTransport$1(_VaProgressCircle);

// node_modules/vuestic-ui/dist/web-components/src/composables/useHoverStyle.js
var useHoverStyleProps = {
  hoverBehavior: {
    type: String,
    default: "mask",
    validator: (value) => ["opacity", "mask"].includes(value)
  },
  hoverOpacity: { type: Number, default: 0.15 },
  hoverMaskColor: { type: String, default: "textInverted" }
};

// node_modules/vuestic-ui/dist/web-components/src/composables/usePressedStyle.js
var usePressedStyleProps = {
  pressedBehavior: {
    type: String,
    default: "mask",
    validator: (value) => ["opacity", "mask"].includes(value)
  },
  pressedOpacity: { type: Number, default: 0.13 },
  pressedMaskColor: { type: String, default: "textPrimary" }
};

// node_modules/vuestic-ui/dist/web-components/src/composables/useLoading.js
var useLoadingProps = {
  loading: { type: Boolean, default: false }
};

// node_modules/vuestic-ui/dist/web-components/src/utils/focus.js
var isHTMLElement = (el) => {
  return el instanceof HTMLElement;
};
var focusElement = (el) => {
  if (!el || !isHTMLElement(el)) {
    return;
  }
  el.focus();
  el.dispatchEvent(new FocusEvent("focus", { bubbles: true }));
};
var blurElement = (el) => {
  if (!el || !isHTMLElement(el)) {
    return;
  }
  el.blur();
  el.dispatchEvent(new Event("blur", { bubbles: true }));
};
var focusFirstFocusableChild = (el) => {
  if (el.tabIndex !== -1) {
    focusElement(el);
    return;
  }
  const focusable = el.querySelector('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])');
  if (focusable) {
    focusElement(focusable);
  }
};

// node_modules/vuestic-ui/dist/web-components/src/composables/useCaptureEvent.js
var useCaptureEvent = (event, cb, options = {}) => {
  onMounted(() => window.addEventListener(event, cb, { capture: true, ...options }));
  onBeforeUnmount(() => window.removeEventListener(event, cb, { capture: true, ...options }));
};

// node_modules/vuestic-ui/dist/web-components/src/composables/useActiveElement.js
var useActiveElement = () => {
  const activeEl = shallowRef();
  const updateActiveElement = () => {
    activeEl.value = document.activeElement;
  };
  onMounted(updateActiveElement);
  useCaptureEvent("focus", updateActiveElement);
  useCaptureEvent("blur", updateActiveElement);
  return activeEl;
};

// node_modules/vuestic-ui/dist/web-components/src/composables/useFocus.js
var useFocusEmits = ["focus", "blur"];
function useFocus(el, emit) {
  const activeElement = useActiveElement();
  const isFocused = computed({
    get: () => {
      if (isNil$1(activeElement.value)) {
        return false;
      }
      if (isNil$1(el == null ? void 0 : el.value)) {
        return false;
      }
      return activeElement.value === (el == null ? void 0 : el.value);
    },
    set: (value) => {
      if (value) {
        focus();
      } else {
        blur();
      }
    }
  });
  const onFocus = (e) => {
    emit == null ? void 0 : emit("focus", e);
  };
  const onBlur = (e) => {
    emit == null ? void 0 : emit("blur", e);
  };
  const focus = () => {
    if (!(el == null ? void 0 : el.value)) {
      return;
    }
    focusElement(unwrapEl(el == null ? void 0 : el.value));
  };
  const blur = () => {
    if (!(el == null ? void 0 : el.value)) {
      return;
    }
    blurElement(unwrapEl(el == null ? void 0 : el.value));
  };
  useEvent("focus", onFocus, el);
  useEvent("blur", onBlur, el);
  return {
    isFocused,
    onFocus,
    onBlur,
    focus,
    blur
  };
}

// node_modules/vuestic-ui/dist/web-components/src/composables/useHTMLElement.js
var useHTMLElement = (key) => {
  if (isRef(key)) {
    return computed({
      get() {
        return unwrapEl(key.value);
      },
      set(value) {
        key.value = value;
      }
    });
  }
  if (key) {
    const el2 = useTemplateRef(key);
    return computed({
      get() {
        return unwrapEl(el2.value);
      },
      set(value) {
        el2.value = value;
      }
    });
  }
  const el = shallowRef();
  return computed({
    set(value) {
      el.value = unwrapEl(value);
    },
    get() {
      return el.value;
    }
  });
};

// node_modules/vuestic-ui/dist/web-components/src/composables/useHover.js
function useHover(el, disabled) {
  const isHovered = ref(false);
  const onMouseEnter = () => {
    isHovered.value = true;
  };
  const onMouseLeave = () => {
    isHovered.value = false;
  };
  disabled && watch(disabled, (v) => {
    if (v) {
      isHovered.value = false;
    }
  });
  const target = useHTMLElement(el);
  useEvent("mouseenter", onMouseEnter, target);
  useEvent("mouseleave", onMouseLeave, target);
  return { isHovered, onMouseEnter, onMouseLeave };
}

// node_modules/vuestic-ui/dist/web-components/src/composables/usePressed.js
function usePressed(el) {
  const isPressed = ref(false);
  const onMouseDown = () => {
    isPressed.value = true;
  };
  const onMouseUp = () => {
    isPressed.value = false;
  };
  const target = useHTMLElement(el);
  useEvent(["mousedown", "touchstart", "dragstart"], onMouseDown, target);
  useEvent([
    "mouseup",
    "mouseleave",
    "touchend",
    "touchcancel",
    "drop",
    "dragend"
  ], onMouseUp, true);
  return { isPressed, onMouseDown, onMouseUp };
}

// node_modules/vuestic-ui/dist/web-components/src/composables/useSlotPassed.js
var checkSlotChildrenDeep = (v, initial = true) => {
  var _a2;
  if (!v || initial && (!isFunction$4(v) || !((_a2 = v()) == null ? void 0 : _a2.length))) {
    return false;
  }
  const slotData = initial ? v() : v;
  if (Array.isArray(slotData)) {
    return slotData.some((el) => {
      return Array.isArray(el.children) ? checkSlotChildrenDeep(el.children, false) : el.children || el.props;
    });
  }
  return !!slotData.children;
};
var useSlotPassed = (name = "default") => {
  const { slots } = getCurrentInstance();
  return computed(() => checkSlotChildrenDeep(slots[name]));
};

// node_modules/vuestic-ui/dist/web-components/src/composables/useBem.js
var useBem = (prefix2, modifiers) => {
  if (isDev && !prefix2) {
    console.warn('You must pass the @param "prefix" to the useBem hook!');
  }
  const modifiersList = computed(() => isFunction$4(modifiers) ? modifiers() : unref(modifiers));
  const computedBemClassesObject = computed(() => {
    return Object.entries(unref(modifiersList)).reduce((classesObj, [modifierName, value]) => {
      if (value) {
        classesObj[`${prefix2}--${kebabCase$1(modifierName)}`] = true;
      }
      return classesObj;
    }, {});
  });
  const computedBemClassesArray = computed(() => Object.keys(computedBemClassesObject.value));
  const computedBemClassesString = computed(() => computedBemClassesArray.value.join(" "));
  return new Proxy({}, {
    ownKeys() {
      return Reflect.ownKeys(computedBemClassesObject.value);
    },
    getOwnPropertyDescriptor(_, key) {
      return Reflect.getOwnPropertyDescriptor(computedBemClassesObject.value, key);
    },
    get(_, key, receiver) {
      switch (key) {
        case "asArray":
          return computedBemClassesArray;
        case "asString":
          return computedBemClassesString;
        case "asObject":
          return computedBemClassesObject;
        default:
          return Reflect.get(computedBemClassesObject.value, key, receiver);
      }
    }
  });
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-button/VaButton.vue_vue_type_script_setup_true_lang.js
var _sfc_main5 = defineComponent({
  ...{
    name: "VaButton"
  },
  __name: "VaButton",
  props: {
    ...useComponentPresetProp,
    ...useSizeProps,
    ...useHoverStyleProps,
    ...usePressedStyleProps,
    ...useLoadingProps,
    ...useRouterLinkProps,
    tag: { type: String, default: "button" },
    type: { type: String, default: "button" },
    block: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false },
    color: { type: String, default: "primary" },
    textColor: { type: String, default: "" },
    textOpacity: { type: Number, default: 1 },
    backgroundOpacity: { type: Number, default: 1 },
    borderColor: { type: String, default: "" },
    // only for filled bg state
    gradient: { type: Boolean, default: false },
    plain: { type: Boolean, default: false },
    round: { type: Boolean, default: false },
    size: {
      type: String,
      default: "medium",
      validator: (v) => ["small", "medium", "large"].includes(v)
    },
    icon: { type: String, default: "" },
    iconRight: { type: String, default: "" },
    iconColor: { type: String, default: "" }
  },
  setup(__props, { expose: __expose }) {
    useCssVars((_ctx) => ({
      "16fe6bdb": unref(backgroundColor),
      "7b55b0a0": unref(backgroundColorOpacity),
      "455e2762": unref(backgroundMaskColor),
      "48a629f7": unref(backgroundMaskOpacity)
    }));
    const props = __props;
    const { getColor } = useColors();
    const colorComputed = computed(() => getColor(props.color));
    const { sizeComputed } = useSize(props);
    const iconSizeComputed = computed(() => {
      const size2 = /([0-9]*)(px)/.exec(sizeComputed.value);
      return size2 ? `${+size2[1] / 2}${size2[2]}` : sizeComputed.value;
    });
    const { tagComputed } = useRouterLink(props);
    const attributesComputed = useButtonAttributes(props);
    const { disabled } = toRefs(props);
    const button = shallowRef();
    const { focus, blur } = useFocus(button);
    const { isHovered } = useHover(button, disabled);
    const { isPressed } = usePressed(button);
    const iconColorComputed = computed(() => props.iconColor ? getColor(props.iconColor) : textColorComputed.value);
    const iconAttributesComputed = computed(() => ({
      color: iconColorComputed.value,
      size: props.size
    }));
    const wrapperClassComputed = computed(() => ({ "va-button__content--loading": props.loading }));
    const isSlotContentPassed = useSlotPassed();
    const isOneIcon = computed(() => !!(props.iconRight && !props.icon || !props.iconRight && props.icon));
    const isOnlyIcon = computed(() => !isSlotContentPassed.value && isOneIcon.value);
    const computedClass = useBem("va-button", () => ({
      ...pick$1(props, ["disabled", "block", "loading", "round", "plain"]),
      small: props.size === "small",
      normal: !props.size || props.size === "medium",
      large: props.size === "large",
      opacity: props.textOpacity < 1,
      bordered: !!props.borderColor,
      iconOnly: isOnlyIcon.value,
      leftIcon: !isOnlyIcon.value && !!props.icon && !props.iconRight,
      rightIcon: !isOnlyIcon.value && !props.icon && !!props.iconRight
    }));
    const isTransparentBg = computed(() => props.plain || props.backgroundOpacity < 0.5);
    const { textColorComputed } = useTextColor(colorComputed, isTransparentBg);
    const {
      backgroundColor,
      backgroundColorOpacity,
      backgroundMaskOpacity,
      backgroundMaskColor
    } = useButtonBackground(colorComputed, isPressed, isHovered);
    const contentColorComputed = useButtonTextColor(textColorComputed, colorComputed, isPressed, isHovered);
    const computedStyle = computed(() => ({
      borderColor: props.borderColor ? getColor(props.borderColor) : "transparent",
      ...contentColorComputed.value
    }));
    __expose({
      focus,
      blur
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(resolveDynamicComponent(unref(tagComputed)), mergeProps({
        ref_key: "button",
        ref: button,
        class: ["va-button", unref(computedClass)],
        style: computedStyle.value
      }, unref(attributesComputed)), {
        default: withCtx(() => [
          createBaseVNode("span", {
            class: normalizeClass(["va-button__content", wrapperClassComputed.value])
          }, [
            renderSlot(_ctx.$slots, "prepend", normalizeProps(guardReactiveProps({ icon: __props.icon, iconAttributes: iconAttributesComputed.value })), () => [
              __props.icon ? (openBlock(), createBlock(unref(VaIcon), mergeProps({
                key: 0,
                class: "va-button__left-icon",
                name: __props.icon
              }, iconAttributesComputed.value), null, 16, ["name"])) : createCommentVNode("", true)
            ]),
            renderSlot(_ctx.$slots, "default"),
            renderSlot(_ctx.$slots, "append", normalizeProps(guardReactiveProps({ icon: __props.iconRight, iconAttributes: iconAttributesComputed.value })), () => [
              __props.iconRight ? (openBlock(), createBlock(unref(VaIcon), mergeProps({
                key: 0,
                class: "va-button__right-icon",
                name: __props.iconRight
              }, iconAttributesComputed.value), null, 16, ["name"])) : createCommentVNode("", true)
            ])
          ], 2),
          _ctx.loading ? renderSlot(_ctx.$slots, "loading", normalizeProps(mergeProps({ key: 0 }, {
            size: iconSizeComputed.value,
            color: unref(textColorComputed)
          })), () => [
            createVNode(unref(VaProgressCircle), {
              class: "va-button__loader",
              size: iconSizeComputed.value,
              color: unref(textColorComputed),
              thickness: 0.15,
              indeterminate: ""
            }, null, 8, ["size", "color"])
          ]) : createCommentVNode("", true)
        ]),
        _: 3
      }, 16, ["class", "style"]);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-button/VaButton.js
var _style_04 = ':root,\n:host {\n  /* General */\n  --va-button-display: inline-flex;\n  --va-button-justify-content: center;\n  --va-button-align-items: center;\n  --va-button-background-image: none;\n  --va-button-box-shadow: none;\n  --va-button-border-width: 0;\n  --va-button-border-color: unset;\n  --va-button-border-style: none;\n  --va-button-font-weight: 600;\n  --va-button-transition: none;\n  --va-button-padding: 0;\n  --va-button-cursor: pointer;\n  /* Small */\n  --va-button-sm-size: 1.5rem;\n  --va-button-sm-content-py: 0.25rem;\n  --va-button-sm-content-px: 0.375rem;\n  --va-button-sm-only-icon-content-px: 0.25rem;\n  --va-button-sm-font-size: 0.8125rem;\n  --va-button-sm-letter-spacing: 0;\n  --va-button-sm-line-height: 1rem;\n  --va-button-sm-border-radius: 0.125rem;\n  --va-button-sm-icon-side-padding: var(--va-button-sm-content-py);\n  --va-button-sm-icons-spacing: 0.125rem;\n  /* Medium */\n  --va-button-size: 2.25rem;\n  --va-button-content-py: 0.5rem;\n  --va-button-content-px: 0.75rem;\n  --va-button-only-icon-content-px: 0.5rem;\n  --va-button-font-size: 1rem;\n  --va-button-letter-spacing: 0;\n  --va-button-line-height: 1.25rem;\n  --va-button-border-radius: 0.25rem;\n  --va-button-icon-side-padding: var(--va-button-content-py);\n  --va-button-icons-spacing: 0.25rem;\n  /* Large */\n  --va-button-lg-size: 3rem;\n  --va-button-lg-content-py: 0.75rem;\n  --va-button-lg-content-px: 1rem;\n  --va-button-lg-only-icon-content-px: 1rem;\n  --va-button-lg-font-size: 1.05rem;\n  --va-button-lg-letter-spacing: 0;\n  --va-button-lg-line-height: 1.5rem;\n  --va-button-lg-border-radius: 0.5rem;\n  --va-button-lg-icon-side-padding: var(--va-button-lg-content-py);\n  --va-button-lg-icons-spacing: 0.25rem;\n  /* Bordered */\n  --va-button-bordered-border: 1px;\n  --va-button-bordered-style: solid;\n}\n.va-button {\n  position: relative;\n  padding: var(--va-button-padding);\n  display: var(--va-button-display);\n  justify-content: var(--va-button-justify-content);\n  align-items: var(--va-button-align-items);\n  border-width: var(--va-button-border-width);\n  border-color: var(--va-button-border-color);\n  border-style: var(--va-button-border-style);\n  background-image: var(--va-button-background-image);\n  box-shadow: var(--va-button-box-shadow);\n  font-family: var(--va-font-family);\n  font-weight: var(--va-button-font-weight);\n  text-decoration: none;\n  text-transform: initial;\n  transition: var(--va-button-transition);\n  box-sizing: border-box;\n  cursor: var(--va-button-cursor);\n  z-index: 0;\n  vertical-align: top;\n}\n.va-button::after, .va-button::before {\n  content: "";\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  border-radius: inherit;\n  left: 0;\n  top: 0;\n  z-index: -1;\n}\n.va-button::before {\n  background: var(--16fe6bdb);\n  opacity: var(--7b55b0a0);\n}\n.va-button::after {\n  background-color: var(--455e2762);\n  opacity: var(--48a629f7);\n}\n.va-button__content {\n  height: 100%;\n  display: flex;\n  align-items: center;\n  z-index: 1;\n}\n.va-button__content--loading {\n  opacity: 0;\n}\n.va-button--small {\n  line-height: var(--va-button-sm-line-height);\n  border-radius: var(--va-button-sm-border-radius);\n  letter-spacing: var(--va-button-sm-letter-spacing);\n  min-height: var(--va-button-sm-size);\n  min-width: var(--va-button-sm-size);\n}\n.va-button--small .va-button__content {\n  font-size: var(--va-button-sm-font-size);\n  padding: var(--va-button-sm-content-py) var(--va-button-sm-content-px);\n}\n.va-button--small .va-button__left-icon {\n  margin-right: var(--va-button-sm-icons-spacing);\n}\n.va-button--small .va-button__right-icon {\n  margin-left: var(--va-button-sm-icons-spacing);\n}\n.va-button--small.va-button--bordered .va-button__content {\n  padding-top: calc(var(--va-button-sm-content-py) - var(--va-button-bordered-border));\n  padding-bottom: calc(var(--va-button-sm-content-py) - var(--va-button-bordered-border));\n}\n.va-button--small.va-button--left-icon .va-button__content {\n  padding-left: var(--va-button-sm-icon-side-padding);\n}\n.va-button--small.va-button--right-icon .va-button__content {\n  padding-right: var(--va-button-sm-icon-side-padding);\n}\n.va-button--normal {\n  line-height: var(--va-button-line-height);\n  border-radius: var(--va-button-border-radius);\n  letter-spacing: var(--va-button-letter-spacing);\n  min-height: var(--va-button-size);\n  min-width: var(--va-button-size);\n}\n.va-button--normal .va-button__content {\n  font-size: var(--va-button-font-size);\n  padding: var(--va-button-content-py) var(--va-button-content-px);\n  line-height: var(--va-button-line-height);\n}\n.va-button--normal .va-button__left-icon {\n  margin-right: var(--va-gap-medium);\n}\n.va-button--normal .va-button__right-icon {\n  margin-left: var(--va-gap-medium);\n}\n.va-button--normal.va-button--bordered .va-button__content {\n  padding-top: calc(var(--va-button-content-py) - var(--va-button-bordered-border));\n  padding-bottom: calc(var(--va-button-content-py) - var(--va-button-bordered-border));\n}\n.va-button--large {\n  line-height: var(--va-button-lg-line-height);\n  border-radius: var(--va-button-lg-border-radius);\n  letter-spacing: var(--va-button-lg-letter-spacing);\n  min-height: var(--va-button-lg-size);\n  min-width: var(--va-button-lg-size);\n}\n.va-button--large .va-button__content {\n  font-size: var(--va-button-lg-font-size);\n  padding: var(--va-button-lg-content-py) var(--va-button-lg-content-px);\n}\n.va-button--large .va-button__left-icon {\n  margin-right: var(--va-button-lg-icons-spacing);\n}\n.va-button--large .va-button__right-icon {\n  margin-left: var(--va-button-lg-icons-spacing);\n}\n.va-button--large.va-button--bordered .va-button__content {\n  padding-top: calc(var(--va-button-lg-content-py) - var(--va-button-bordered-border));\n  padding-bottom: calc(var(--va-button-lg-content-py) - var(--va-button-bordered-border));\n}\n.va-button--large.va-button--left-icon .va-button__content {\n  padding-left: var(--va-button-lg-icon-side-padding);\n}\n.va-button--large.va-button--right-icon .va-button__content {\n  padding-right: var(--va-button-lg-icon-side-padding);\n}\n.va-button--small.va-button--icon-only .va-button__content, .va-button--normal.va-button--icon-only .va-button__content, .va-button--large.va-button--icon-only .va-button__content {\n  padding-right: 0;\n  padding-left: 0;\n}\n.va-button--plain {\n  min-width: auto;\n  min-height: auto;\n}\n.va-button--plain .va-button__content {\n  padding: 0;\n  z-index: unset;\n}\n.va-button--round {\n  border-radius: 999px;\n}\n.va-button--bordered {\n  border-width: var(--va-button-bordered-border);\n  border-style: var(--va-button-bordered-style);\n}\n.va-button.va-button--disabled {\n  cursor: default;\n  opacity: 0.4;\n  pointer-events: none;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n          user-select: none;\n}\n.va-button--icon-only .va-button__left-icon,\n.va-button--icon-only .va-button__right-icon {\n  margin-left: 0;\n  margin-right: 0;\n}\n.va-button--icon-only .va-button__content {\n  padding: 0;\n}\n.va-button:focus-visible {\n  outline: 2px solid var(--va-focus) !important;\n  border-radius: "inherit";\n}\n.va-button--loading {\n  pointer-events: none;\n}\n.va-button--block {\n  display: flex;\n  min-width: 100%;\n}\n.va-button__loader {\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n}';
var _VaButton = _export_sfc(_sfc_main5, [["styles", [_style_04]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-button/index.js
var VaButton = withConfigTransport$1(_VaButton);

// node_modules/vuestic-ui/dist/web-components/src/composables/useCurrentComponentId.js
var useCurrentComponentId = () => {
  const instance = getCurrentInstance();
  if (!instance.appContext.app) {
    return String(instance.uid);
  }
  return `${instance.appContext.app._uid}_${instance.uid}`;
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-modal/hooks/useBlur.js
var openedModals = [];
var useBlur = (shouldBlur, isModalShown) => {
  const id = useCurrentComponentId();
  const document2 = useDocument();
  const blur = () => {
    var _a2;
    if (openedModals.includes(id)) {
      return;
    }
    openedModals.push(id);
    (_a2 = document2.value) == null ? void 0 : _a2.body.classList.add("va-modal-overlay-background--blurred");
  };
  const removeBlur = () => {
    var _a2;
    const modalIndex = openedModals.indexOf(id);
    if (modalIndex === -1) {
      return;
    }
    openedModals.splice(modalIndex, 1);
    if (openedModals.length === 0) {
      (_a2 = document2.value) == null ? void 0 : _a2.body.classList.remove("va-modal-overlay-background--blurred");
    }
  };
  watchEffect(() => {
    if (!shouldBlur.value) {
      return;
    }
    if (isModalShown.value) {
      blur();
    } else {
      removeBlur();
    }
  });
  onBeforeUnmount(removeBlur);
};

// node_modules/vuestic-ui/dist/web-components/src/composables/useZIndex.js
var createInstance = () => {
  return generateUniqueId();
};
var zIndexStack = shallowReactive([]);
var useZIndex = (isVisible) => {
  const instance = createInstance();
  const register = () => {
    if (zIndexStack.includes(instance)) {
      return;
    }
    zIndexStack.push(instance);
  };
  const unregister = () => {
    const index = zIndexStack.findIndex((item) => item === instance);
    if (index !== -1) {
      zIndexStack.splice(index, 1);
    }
  };
  const zIndex = computed(() => {
    const index = zIndexStack.findIndex((item) => item === instance);
    if (index === -1) {
      return -1;
    }
    return index + 1;
  });
  const isTop = computed(() => zIndex.value === zIndexStack.length - 1);
  const isLowest = computed(() => zIndex.value === 0);
  onMounted(() => {
    if (isVisible.value) {
      register();
    }
  });
  onBeforeUnmount(() => {
    unregister();
  });
  watch(isVisible, (value) => {
    if (value) {
      register();
    } else {
      unregister();
    }
  });
  return {
    zIndex,
    isTop,
    isLowest,
    register,
    unregister
  };
};

// node_modules/vuestic-ui/dist/web-components/src/composables/useUserProvidedProp.js
var NOT_PROVIDED = Symbol("NOT_PROVIDED");
var useUserProvidedProp = (propName, props) => {
  const vm = getCurrentInstance();
  return computed(() => {
    if (!(vm == null ? void 0 : vm.vnode.props)) {
      return NOT_PROVIDED;
    }
    const originalProp = props[propName];
    return propName in vm.vnode.props ? originalProp : NOT_PROVIDED;
  });
};

// node_modules/vuestic-ui/dist/web-components/src/composables/useStateful.js
var useStatefulProps = {
  stateful: { type: Boolean, default: false },
  modelValue: { type: void 0 }
};
var createStatefulProps = (statefulDefault = false) => {
  return {
    stateful: { type: Boolean, default: statefulDefault }
  };
};
var useStatefulEmits = ["update:modelValue"];
var useStateful = (props, emit, key = "modelValue", options = {}) => {
  const { eventName, defaultValue } = options;
  const event = eventName || `update:${key.toString()}`;
  const passedProp = useUserProvidedProp(key, props);
  const defaultValuePassed = "defaultValue" in options;
  const valueState = ref(
    passedProp.value === NOT_PROVIDED ? defaultValuePassed ? defaultValue : props[key] : passedProp.value
  );
  let unwatchModelValue;
  const watchModelValue = () => {
    unwatchModelValue = watch(() => props[key], (modelValue) => {
      valueState.value = modelValue;
    });
  };
  watch(() => props.stateful, (stateful) => {
    stateful ? watchModelValue() : unwatchModelValue == null ? void 0 : unwatchModelValue();
  }, { immediate: true });
  const valueComputed = computed({
    get: () => {
      if (props.stateful) {
        return valueState.value;
      }
      return props[key];
    },
    set: (value) => {
      if (props.stateful) {
        valueState.value = value;
      }
      emit(event, value);
    }
  });
  Object.defineProperty(valueComputed, "stateful", {
    get: () => props.stateful
  });
  Object.defineProperty(valueComputed, "userProvided", {
    get: () => passedProp.value !== NOT_PROVIDED
  });
  return { valueComputed };
};

// node_modules/vuestic-ui/dist/web-components/src/composables/useTrapFocus.js
var FOCUSABLE_ELEMENTS_SELECTOR = ":where(a, button, input, textarea, select):not([disabled]), *[tabindex]";
var trapInEl = null;
var useTrapFocus = () => {
  const document2 = useDocument();
  const window2 = useWindow();
  let focusableElements = [];
  let firstFocusableElement = null;
  let lastFocusableElement = null;
  const isFocusIn = (evt) => {
    return (trapInEl == null ? void 0 : trapInEl.contains(evt.target)) || false;
  };
  const focusFirstElement = () => {
    firstFocusableElement == null ? void 0 : firstFocusableElement.focus();
  };
  const focusLastElement = () => {
    lastFocusableElement == null ? void 0 : lastFocusableElement.focus();
  };
  const onKeydown = (evt) => {
    var _a2, _b;
    const isTabPressed = evt.code === "Tab";
    const isShiftPressed = evt.shiftKey;
    if (!isTabPressed) {
      return;
    }
    if (!isFocusIn(evt)) {
      evt.preventDefault();
      isShiftPressed ? focusLastElement() : focusFirstElement();
      return;
    }
    if (((_a2 = document2.value) == null ? void 0 : _a2.activeElement) === lastFocusableElement && !isShiftPressed) {
      evt.preventDefault();
      focusFirstElement();
      return;
    }
    if (((_b = document2.value) == null ? void 0 : _b.activeElement) === firstFocusableElement && isShiftPressed) {
      evt.preventDefault();
      focusLastElement();
    }
  };
  const trapFocusIn = (el) => {
    trapInEl = el;
    freeFocus();
    trapFocus();
  };
  const trapFocus = () => {
    var _a2;
    if (!trapInEl) {
      return;
    }
    focusableElements = Array.from(trapInEl.querySelectorAll(FOCUSABLE_ELEMENTS_SELECTOR));
    firstFocusableElement = focusableElements[0];
    lastFocusableElement = focusableElements[focusableElements.length - 1];
    (_a2 = window2.value) == null ? void 0 : _a2.addEventListener("keydown", onKeydown);
  };
  const freeFocus = () => {
    var _a2;
    focusableElements = [];
    firstFocusableElement = null;
    lastFocusableElement = null;
    (_a2 = window2.value) == null ? void 0 : _a2.removeEventListener("keydown", onKeydown);
  };
  return {
    trapFocus,
    freeFocus,
    trapFocusIn
  };
};

// node_modules/vuestic-ui/dist/web-components/src/composables/useModalLevel.js
var modalsStack = shallowReactive([]);
var useModalLevel = () => {
  const modalId = uniqueId$1();
  const modalLevel = computed(
    () => modalsStack.findIndex(({ id }) => id === modalId)
  );
  const registerModal = () => {
    if (modalLevel.value !== -1) {
      return;
    }
    modalsStack.push({
      id: modalId
    });
  };
  const unregisterModal = () => {
    if (modalLevel.value === -1) {
      return;
    }
    modalsStack.splice(modalLevel.value, 1);
  };
  const isTopLevelModal = computed(
    () => modalLevel.value !== -1 && modalLevel.value === modalsStack.length - 1
  );
  const isLowestLevelModal = computed(
    () => modalLevel.value === 0
  );
  const isMoreThenOneModalOpen = computed(() => modalsStack.length > 1);
  return {
    modalId,
    modalLevel,
    registerModal,
    unregisterModal,
    isTopLevelModal,
    isLowestLevelModal,
    isMoreThenOneModalOpen
  };
};

// node_modules/vuestic-ui/dist/web-components/src/composables/useTeleported.js
var TELEPORT_FROM_ATTR = "data-va-teleported-from";
var TELEPORT_ATTR = "data-va-teleported";
var findTeleportedFrom = (el) => {
  if (!el) {
    return null;
  }
  const teleportId = el.getAttribute(TELEPORT_ATTR);
  if (teleportId === null) {
    return findTeleportedFrom(el.parentElement);
  }
  return document.querySelector(`[${TELEPORT_FROM_ATTR}="${teleportId}"]`);
};
var useTeleported = () => {
  var _a2;
  const componentId = useCurrentComponentId();
  const scopedDataV = (_a2 = getCurrentInstance()) == null ? void 0 : _a2.vnode.scopeId;
  return {
    teleportFromAttrs: {
      [TELEPORT_FROM_ATTR]: componentId
    },
    teleportedAttrs: {
      [TELEPORT_ATTR]: componentId,
      [`data-v-${scopedDataV}`]: ""
    },
    findTeleportedFrom
  };
};

// node_modules/vuestic-ui/dist/web-components/src/composables/useClickOutside.js
var checkIfElementChild = (parent2, child) => {
  if (!child) {
    return false;
  }
  if (child.parentElement === parent2) {
    return true;
  }
  return parent2.contains(child);
};
var safeArray = (a) => Array.isArray(a) ? a : [a];
var useClickOutside = (elements, cb) => {
  useCaptureEvent("mousedown", (event) => {
    const clickTarget = event.target;
    if (event.target.shadowRoot) {
      return;
    }
    const teleportParent = findTeleportedFrom(clickTarget);
    const isClickInside = safeArray(elements).some((element) => {
      const el = unwrapEl(unref(element));
      if (!el) {
        return false;
      }
      if (!teleportParent) {
        return checkIfElementChild(el, clickTarget);
      }
      return checkIfElementChild(el, clickTarget) || checkIfElementChild(el, teleportParent);
    });
    if (!isClickInside) {
      cb(clickTarget);
    }
  });
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-modal/VaModal.vue_vue_type_script_setup_true_lang.js
var _hoisted_13 = ["aria-labelledby"];
var _hoisted_23 = {
  key: 2,
  class: "va-modal__inner"
};
var _hoisted_32 = { class: "va-modal__header" };
var _hoisted_42 = {
  key: 0,
  class: "va-modal__message"
};
var _hoisted_52 = {
  key: 1,
  class: "va-modal__message"
};
var _hoisted_62 = {
  key: 2,
  class: "va-modal__footer"
};
var _hoisted_72 = {
  key: 3,
  class: "va-modal__footer"
};
var WithTransition = defineComponent({
  name: "ModalElement",
  inheritAttrs: false,
  props: {
    ...useComponentPresetProp,
    isTransition: { type: Boolean, default: true }
  },
  setup: (props, { slots, attrs }) => () => {
    var _a2;
    return props.isTransition ? h(Transition, { ...attrs }, slots) : (_a2 = slots.default) == null ? void 0 : _a2.call(slots, attrs);
  }
});
var _sfc_main6 = defineComponent({
  ...{
    name: "VaModal",
    inheritAttrs: false
  },
  __name: "VaModal",
  props: {
    ...useStatefulProps,
    modelValue: { type: Boolean, default: false },
    attachElement: { type: String, default: "body" },
    allowBodyScroll: { type: Boolean, default: false },
    disableAttachment: { type: Boolean, default: false },
    title: { type: String, default: "" },
    message: { type: String, default: "" },
    okText: { type: String, default: "$t:ok" },
    cancelText: { type: String, default: "$t:cancel" },
    hideDefaultActions: { type: Boolean, default: false },
    fullscreen: { type: Boolean, default: false },
    closeButton: { type: Boolean, default: false },
    mobileFullscreen: { type: Boolean, default: true },
    noDismiss: { type: Boolean, default: false },
    noOutsideDismiss: { type: Boolean, default: false },
    noEscDismiss: { type: Boolean, default: false },
    maxWidth: { type: String, default: "" },
    maxHeight: { type: String, default: "" },
    anchorClass: { type: String },
    size: {
      type: String,
      default: "medium"
    },
    sizesConfig: {
      type: Object,
      default: () => ({
        defaultSize: "medium",
        sizes: {
          small: 576,
          medium: 768,
          large: 992,
          auto: "max-content"
        }
      })
    },
    fixedLayout: { type: Boolean, default: false },
    withoutTransitions: { type: Boolean, default: false },
    overlay: { type: Boolean, default: true },
    overlayOpacity: { type: [Number, String], default: 0.6 },
    showNestedOverlay: { type: Boolean, default: false },
    blur: { type: Boolean, default: false },
    zIndex: { type: [Number, String], default: void 0 },
    backgroundColor: { type: String, default: "background-secondary" },
    noPadding: { type: Boolean, default: false },
    beforeClose: { type: Function },
    beforeOk: { type: Function },
    beforeCancel: { type: Function },
    ariaCloseLabel: { type: String, default: "$t:close" }
  },
  emits: [
    ...useStatefulEmits,
    "cancel",
    "ok",
    "before-open",
    "open",
    "before-close",
    "close",
    "click-outside"
  ],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const rootElement = shallowRef();
    const modalDialog = shallowRef();
    const { trapFocusIn, freeFocus } = useTrapFocus();
    const {
      registerModal,
      unregisterModal,
      isTopLevelModal,
      isLowestLevelModal
    } = useModalLevel();
    const { getColor } = useColors();
    const { textColorComputed } = useTextColor(toRef(props, "backgroundColor"));
    const { valueComputed } = useStateful(props, emit);
    const computedClass = computed(() => ({
      "va-modal--fullscreen": props.fullscreen,
      "va-modal--mobile-fullscreen": props.mobileFullscreen,
      "va-modal--fixed-layout": props.fixedLayout,
      "va-modal--no-padding": props.noPadding
    }));
    const {
      zIndex: zIndexInherited
    } = useZIndex(valueComputed);
    const zIndexComputed = computed(() => {
      if (props.zIndex) {
        return Number(props.zIndex);
      }
      return zIndexInherited.value;
    });
    const sizeComputed = useSizeRef(props);
    const computedDialogStyle = computed(() => ({
      maxWidth: props.maxWidth || sizeComputed.value,
      maxHeight: props.maxHeight,
      color: textColorComputed.value,
      background: getColor(props.backgroundColor)
    }));
    const computedOverlayClass = computed(() => ({
      "va-modal__overlay--lowest": isLowestLevelModal.value,
      "va-modal__overlay--top": isTopLevelModal.value
    }));
    const getOverlayOpacity = () => {
      if (props.showNestedOverlay && !isLowestLevelModal.value) {
        return "var(--va-modal-overlay-nested-opacity)";
      }
      return "var(--va-modal-overlay-opacity)";
    };
    const computedOverlayStyles = computed(() => {
      if (!props.overlay) {
        return;
      }
      if (isTopLevelModal.value || props.showNestedOverlay) {
        return {
          "background-color": "var(--va-modal-overlay-color)",
          opacity: getOverlayOpacity()
        };
      }
      return "";
    });
    const show = () => {
      valueComputed.value = true;
    };
    const hide = (cb) => {
      const _hide = () => {
        valueComputed.value = false;
        cb == null ? void 0 : cb();
      };
      props.beforeClose ? props.beforeClose(_hide) : _hide();
    };
    const toggle = () => {
      valueComputed.value = !valueComputed.value;
    };
    const cancel = () => {
      const _hide = () => {
        hide(() => emit("cancel"));
      };
      props.beforeCancel ? props.beforeCancel(_hide) : _hide();
    };
    const ok = () => {
      const _hide = () => {
        hide(() => emit("ok"));
      };
      props.beforeOk ? props.beforeOk(_hide) : _hide();
    };
    const trapFocusInModal = () => {
      nextTick(() => {
        if (modalDialog.value) {
          trapFocusIn(modalDialog.value);
        }
      });
    };
    const onBeforeEnterTransition = (el) => emit("before-open", el);
    const onAfterEnterTransition = (el) => emit("open", el);
    const onBeforeLeaveTransition = (el) => emit("before-close", el);
    const onAfterLeaveTransition = (el) => emit("close", el);
    const listenKeyUp = (e) => {
      const hideModal = () => {
        if (e.code === "Escape" && !props.noEscDismiss && !props.noDismiss && isTopLevelModal.value) {
          cancel();
        }
      };
      setTimeout(hideModal);
    };
    useClickOutside([modalDialog], () => {
      if (!valueComputed.value || props.noOutsideDismiss || props.noDismiss || !isTopLevelModal.value) {
        return;
      }
      emit("click-outside");
      cancel();
    });
    const window2 = useWindow();
    watchEffect(() => {
      var _a2, _b;
      if (valueComputed.value) {
        (_a2 = window2.value) == null ? void 0 : _a2.addEventListener("keyup", listenKeyUp);
      } else {
        (_b = window2.value) == null ? void 0 : _b.removeEventListener("keyup", listenKeyUp);
      }
    });
    useBlur(toRef(props, "blur"), valueComputed);
    const documentRef = useDocument();
    const setBodyOverflow = (overflow) => {
      if (!documentRef.value || props.allowBodyScroll) {
        return;
      }
      if (overflow === "hidden") {
        documentRef.value.body.classList.add("va-modal-open");
      } else {
        documentRef.value.body.classList.remove("va-modal-open");
      }
    };
    const onShow = () => {
      registerModal();
      setBodyOverflow("hidden");
    };
    const onHide = () => {
      if (isLowestLevelModal.value) {
        freeFocus();
        setBodyOverflow("");
      }
      unregisterModal();
    };
    watch(valueComputed, (newValue) => {
      if (newValue) {
        onShow();
      } else {
        onHide();
      }
    });
    onMounted(() => {
      if (valueComputed.value) {
        onShow();
      }
      if (isTopLevelModal.value) {
        trapFocusInModal();
      }
    });
    onBeforeUnmount(() => {
      onHide();
    });
    watch(isTopLevelModal, (newIsTopLevelModal) => {
      if (newIsTopLevelModal) {
        trapFocusInModal();
      }
    }, { immediate: true });
    __expose({
      show,
      hide,
      toggle,
      cancel,
      ok,
      onBeforeEnterTransition,
      onAfterEnterTransition,
      onBeforeLeaveTransition,
      onAfterLeaveTransition,
      listenKeyUp
    });
    const { tp } = useTranslation();
    const {
      teleportFromAttrs,
      teleportedAttrs
    } = useTeleported();
    const slotBind = { show, hide, toggle, cancel, ok };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        ref_key: "rootElement",
        ref: rootElement,
        class: normalizeClass(["va-modal-entry", _ctx.$props.anchorClass])
      }, [
        _ctx.$slots.anchor ? (openBlock(), createElementBlock("div", mergeProps({
          key: 0,
          class: "va-modal__anchor"
        }, unref(teleportFromAttrs)), [
          renderSlot(_ctx.$slots, "anchor", normalizeProps(guardReactiveProps(slotBind)))
        ], 16)) : createCommentVNode("", true),
        (openBlock(), createBlock(Teleport, {
          to: __props.attachElement,
          disabled: _ctx.$props.disableAttachment
        }, [
          createVNode(unref(WithTransition), mergeProps({
            name: "va-modal",
            isTransition: !_ctx.$props.withoutTransitions,
            duration: 300,
            style: { zIndex: zIndexComputed.value },
            appear: ""
          }, { ..._ctx.$attrs, ...unref(teleportedAttrs) }, {
            onBeforeEnter: onBeforeEnterTransition,
            onAfterEnter: onAfterEnterTransition,
            onBeforeLeave: onBeforeLeaveTransition,
            onAfterLeave: onAfterLeaveTransition
          }), {
            default: withCtx(() => [
              unref(valueComputed) ? (openBlock(), createElementBlock("div", {
                key: 0,
                "aria-labelledby": __props.title,
                class: normalizeClass([computedClass.value, "va-modal"]),
                role: "dialog",
                "aria-modal": "true"
              }, [
                _ctx.$props.overlay ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  class: normalizeClass(["va-modal__overlay", computedOverlayClass.value]),
                  style: normalizeStyle(computedOverlayStyles.value)
                }, null, 6)) : createCommentVNode("", true),
                createBaseVNode("div", {
                  ref_key: "modalDialog",
                  ref: modalDialog,
                  class: "va-modal__dialog",
                  style: normalizeStyle([computedDialogStyle.value])
                }, [
                  _ctx.$props.fullscreen || _ctx.$props.closeButton ? (openBlock(), createBlock(unref(VaIcon), {
                    key: 0,
                    name: "va-close",
                    class: normalizeClass(["va-modal__close", { "va-modal__close--fullscreen": _ctx.$props.fullscreen }]),
                    role: "button",
                    "aria-label": unref(tp)(_ctx.$props.ariaCloseLabel),
                    tabindex: "0",
                    onClick: cancel,
                    onKeydown: [
                      withKeys(cancel, ["space"]),
                      withKeys(cancel, ["enter"])
                    ]
                  }, null, 8, ["class", "aria-label"])) : createCommentVNode("", true),
                  _ctx.$slots.content ? renderSlot(_ctx.$slots, "content", normalizeProps(mergeProps({ key: 1 }, slotBind))) : (openBlock(), createElementBlock("div", _hoisted_23, [
                    createBaseVNode("div", _hoisted_32, [
                      renderSlot(_ctx.$slots, "header", normalizeProps(guardReactiveProps(slotBind)), () => [
                        __props.title ? (openBlock(), createElementBlock("div", {
                          key: 0,
                          class: "va-modal__title",
                          style: normalizeStyle({ color: unref(getColor)("primary") })
                        }, toDisplayString(_ctx.$props.title), 5)) : createCommentVNode("", true)
                      ])
                    ]),
                    _ctx.$props.message ? (openBlock(), createElementBlock("div", _hoisted_42, toDisplayString(_ctx.$props.message), 1)) : createCommentVNode("", true),
                    _ctx.$slots.default ? (openBlock(), createElementBlock("div", _hoisted_52, [
                      renderSlot(_ctx.$slots, "default", normalizeProps(guardReactiveProps(slotBind)))
                    ])) : createCommentVNode("", true),
                    (_ctx.$props.cancelText || _ctx.$props.okText) && !_ctx.$props.hideDefaultActions ? (openBlock(), createElementBlock("div", _hoisted_62, [
                      _ctx.$props.cancelText ? (openBlock(), createBlock(unref(VaButton), {
                        key: 0,
                        preset: "secondary",
                        color: "secondary",
                        class: "va-modal__default-cancel-button",
                        onClick: cancel
                      }, {
                        default: withCtx(() => [
                          createTextVNode(toDisplayString(unref(tp)(_ctx.$props.cancelText)), 1)
                        ]),
                        _: 1
                      })) : createCommentVNode("", true),
                      createVNode(unref(VaButton), { onClick: ok }, {
                        default: withCtx(() => [
                          createTextVNode(toDisplayString(unref(tp)(_ctx.$props.okText)), 1)
                        ]),
                        _: 1
                      })
                    ])) : createCommentVNode("", true),
                    _ctx.$slots.footer ? (openBlock(), createElementBlock("div", _hoisted_72, [
                      renderSlot(_ctx.$slots, "footer", normalizeProps(guardReactiveProps(slotBind)))
                    ])) : createCommentVNode("", true)
                  ]))
                ], 4)
              ], 10, _hoisted_13)) : createCommentVNode("", true)
            ]),
            _: 3
          }, 16, ["isTransition", "style"])
        ], 8, ["to", "disabled"]))
      ], 2);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-modal/VaModal.js
var _style_05 = ":root,\n:host {\n  --va-modal-title-margin-bottom: 1.5rem;\n  --va-modal-position: fixed;\n  --va-modal-top: 0;\n  --va-modal-left: 0;\n  --va-modal-display: flex;\n  --va-modal-width: 100%;\n  --va-modal-height: 100%;\n  --va-modal-align-items: center;\n  --va-modal-justify-content: center;\n  --va-modal-overflow: hidden;\n  --va-modal-outline: 0;\n  --va-modal-z-index: unset;\n  --va-modal-container-z-index: 100;\n  --va-modal-basic-duration: 0.3s;\n  --va-modal-opacity-transition: calc(var(--va-modal-basic-duration) * 0.5) cubic-bezier(1, 0.5, 0.8, 1);\n  --va-modal-transform-transition: var(--va-modal-basic-duration) ease;\n  --va-modal-overlay-background-blur-radius: 4px;\n  --va-modal-padding: var(--va-modal-padding-top) var(--va-modal-padding-right) var(--va-modal-padding-bottom) var(--va-modal-padding-left);\n  --va-modal-padding-top: 1.5rem;\n  --va-modal-padding-right: 1.5rem;\n  --va-modal-padding-bottom: 1.5rem;\n  --va-modal-padding-left: 1.5rem;\n  /* Dialog */\n  --va-modal-dialog-min-height: 3.125rem;\n  --va-modal-dialog-height: fit-content;\n  --va-modal-dialog-border-radius: 0.375rem;\n  --va-modal-dialog-margin: 1rem;\n  --va-modal-dialog-box-shadow: 0 4px 70px -18px var(--va-shadow);\n  /* Fullscreen */\n  --va-modal-overlay-opacity-transition: opacity calc(2 * var(--va-modal-basic-duration) / 3) cubic-bezier(1, 0.5, 0.8, 1);\n  --va-modal-overlay-color: rgb(0, 0, 0);\n  --va-modal-overlay-opacity: 0.6;\n  --va-modal-overlay-nested-opacity: 0.1;\n  /* Footer */\n  --va-modal-footer-justify-content: flex-end;\n}\nbody.va-modal-open {\n  overflow: hidden;\n}\n.va-modal-overlay-background--blurred > :not(div[class*=va-]) {\n  filter: blur(var(--va-modal-overlay-background-blur-radius));\n  position: absolute;\n  height: 100%;\n  width: 100%;\n}\n.va-modal {\n  position: var(--va-modal-position);\n  display: var(--va-modal-display);\n  align-items: var(--va-modal-align-items);\n  justify-content: var(--va-modal-justify-content);\n  width: var(--va-modal-width);\n  height: var(--va-modal-height);\n  top: var(--va-modal-top);\n  left: var(--va-modal-left);\n  overflow: var(--va-modal-overflow);\n  outline: var(--va-modal-outline);\n  font-family: var(--va-font-family);\n}\n.va-modal__title {\n  margin-bottom: 1.5rem;\n  font-size: 0.625rem;\n  letter-spacing: 0.6px;\n  line-height: 1.2;\n  font-weight: 700;\n  text-transform: uppercase;\n}\n.va-modal-enter-from .va-modal__dialog, .va-modal-leave-to .va-modal__dialog {\n  opacity: 0;\n  transform: translateY(-30%);\n}\n.va-modal-enter-active .va-modal__dialog, .va-modal-leave-active .va-modal__dialog {\n  transition: opacity var(--va-modal-opacity-transition), transform var(--va-modal-transform-transition);\n}\n.va-modal__dialog {\n  min-height: var(--va-modal-dialog-min-height);\n  max-height: calc(100% - var(--va-modal-dialog-margin));\n  height: var(--va-modal-dialog-height);\n  border-radius: var(--va-modal-dialog-border-radius, var(--va-block-border-radius));\n  margin: var(--va-modal-dialog-margin);\n  box-shadow: var(--va-modal-dialog-box-shadow, var(--va-block-box-shadow));\n  position: relative;\n  overflow: auto;\n  display: flex;\n  flex-direction: column;\n  width: 100%;\n  z-index: 1;\n}\n.va-modal__overlay {\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100vw;\n  height: 100vh;\n  z-index: 0;\n  will-change: opacity;\n}\n.va-modal-enter-from .va-modal__overlay--lowest, .va-modal-leave-to .va-modal__overlay--lowest {\n  opacity: 0 !important;\n}\n.va-modal-leave-active .va-modal__overlay.va-modal__overlay--lowest, .va-modal-enter-active .va-modal__overlay.va-modal__overlay--lowest {\n  transition: opacity var(--va-modal-opacity-transition);\n}\n.va-modal-leave-active .va-modal__overlay:not(.va-modal__overlay--lowest) {\n  display: none;\n}\n.va-modal--fullscreen .va-modal__dialog {\n  min-width: 100vw !important;\n  max-width: 100vw;\n  min-height: 100vh !important;\n  border-radius: 0;\n  margin: 0;\n}\n@media all and (max-width: 576px) {\n.va-modal--mobile-fullscreen .va-modal__dialog {\n    margin: 0 !important;\n    min-width: 100vw !important;\n    min-height: 100vh !important;\n    border-radius: 0;\n}\n}\n.va-modal--fixed-layout .va-modal__inner {\n  overflow: hidden;\n  padding: var(--va-modal-padding-top) 0 var(--va-modal-padding-bottom);\n  max-height: calc(100vh - 2rem);\n}\n.va-modal--fixed-layout .va-modal__inner .va-modal__header,\n.va-modal--fixed-layout .va-modal__inner .va-modal__footer,\n.va-modal--fixed-layout .va-modal__inner .va-modal__title {\n  padding: 0 var(--va-modal-padding-right) 0 var(--va-modal-padding-left);\n}\n.va-modal--fixed-layout .va-modal__inner .va-modal__message {\n  padding: 0 var(--va-modal-padding-right) 0 var(--va-modal-padding-left);\n  overflow: auto;\n}\n.va-modal--fixed-layout .va-modal__dialog {\n  overflow: hidden;\n}\n.va-modal--no-padding .va-modal__inner {\n  padding: 0;\n}\n.va-modal__message {\n  margin-bottom: calc(var(--va-modal-padding-bottom) / 2);\n}\n.va-modal__inner {\n  padding: var(--va-modal-padding);\n  overflow: auto;\n  display: flex;\n  flex-flow: column;\n}\n.va-modal__inner > div:last-of-type {\n  margin-bottom: 0;\n}\n.va-modal__close {\n  cursor: pointer;\n  position: absolute;\n  top: calc(var(--va-modal-padding-top) / 2);\n  right: calc(var(--va-modal-padding-right) / 2);\n  color: var(--va-secondary);\n  z-index: 1;\n  justify-self: flex-end;\n}\n.va-modal__close--fullscreen {\n  position: fixed;\n}\n.va-modal__default-cancel-button {\n  margin-right: 0.75rem;\n}\n.va-modal__footer {\n  margin-top: auto;\n  min-height: -moz-fit-content;\n  min-height: fit-content;\n  display: flex;\n  flex-wrap: wrap;\n  justify-content: var(--va-modal-footer-justify-content);\n}\n.va-modal__footer:last-of-type {\n  margin-bottom: 0;\n}";
var _VaModal = _export_sfc(_sfc_main6, [["styles", [_style_05]]]);
var VaModal = withConfigTransport$1(_VaModal);

// node_modules/vuestic-ui/dist/web-components/src/components/va-modal/modal.js
var getNodeProps2 = (vNode) => {
  var _a2;
  return ((_a2 = vNode.component) == null ? void 0 : _a2.props) || {};
};
var destroy2 = (el, vNode) => {
  if (el) {
    render(null, el);
    el.remove();
  }
  el = null;
};
var mount2 = (component, { props, appContext } = {}) => {
  const el = document == null ? void 0 : document.createElement("div");
  let vNode;
  const onClose = (event) => {
    var _a2;
    (_a2 = props == null ? void 0 : props.onClose) == null ? void 0 : _a2.call(props, event);
    destroy2(el);
  };
  const onUpdateModelValue = (value) => {
    var _a2;
    (_a2 = props == null ? void 0 : props["onUpdate:modelValue"]) == null ? void 0 : _a2.call(props, value);
    if ((props == null ? void 0 : props.withoutTransitions) && !value) {
      nextTick(() => {
        destroy2(el);
      });
    }
  };
  vNode = h(component, {
    ...props,
    stateful: (props == null ? void 0 : props.stateful) ?? true,
    modelValue: true,
    onClose,
    "onUpdate:modelValue": onUpdateModelValue
  });
  if (appContext) {
    vNode.appContext = appContext;
  }
  if (el) {
    render(vNode, el);
  }
  return { vNode, el };
};
var getModalOptions = (options) => typeof options === "string" ? { message: options } : options;
var createModalInstance = (customProps, appContext) => {
  const { vNode, el } = mount2(VaModal, { appContext, props: getModalOptions(customProps) });
  if (el && vNode.el && getNodeProps2(vNode)) {
    document.body.appendChild(el.childNodes[0]);
  }
  return vNode;
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-modal/plugin/index.js
var createVaModalPlugin = (app) => ({
  init(options) {
    return createModalInstance(options, app == null ? void 0 : app._context);
  },
  confirm(options) {
    if (typeof options === "string") {
      return new Promise((resolve) => {
        createModalInstance({
          message: options,
          onOk() {
            resolve(true);
          },
          onCancel() {
            resolve(false);
          }
        }, app == null ? void 0 : app._context);
      });
    }
    return new Promise((resolve) => {
      createModalInstance({
        ...options,
        onOk() {
          var _a2;
          (_a2 = options == null ? void 0 : options.onOk) == null ? void 0 : _a2.call(options);
          resolve(true);
        },
        onCancel() {
          var _a2;
          (_a2 = options == null ? void 0 : options.onCancel) == null ? void 0 : _a2.call(options);
          resolve(false);
        }
      }, app == null ? void 0 : app._context);
    });
  }
});
var VaModalPlugin = defineVuesticPlugin(() => ({
  install(app) {
    defineGlobalProperty(app, "$vaModal", createVaModalPlugin(app));
  }
}));

// node_modules/vuestic-ui/dist/web-components/src/services/colors-classes/plugin/index.js
var getColorsClassesHelpers = (helpers, colors) => {
  const colorsEntries = Object.entries(colors);
  return helpers.reduce((acc, helper) => acc.concat(
    colorsEntries.map(([colorName, colorValue]) => ({
      ...helper,
      postfix: helper.postfix ?? colorName,
      value: helper.value ?? colorValue
    }))
  ), []);
};
var getColorsClassesStyles = (helpers) => {
  return helpers.reduce((styles, helper) => {
    const style = [helper.property].flat().map((prop) => `${prop}: ${helper.value};`).join("");
    styles += `.va-${helper.prefix}--${helper.postfix} { ${style} }`;
    return styles;
  }, "");
};
var handleConfigUpdate = (helpers, colors) => {
  const coloredHelpers = getColorsClassesHelpers(helpers, colors);
  addOrUpdateStyleElement(
    "va-color-helpers",
    () => getColorsClassesStyles(coloredHelpers)
  );
};
var createColorHelpersPlugin = () => {
  if (isServer()) {
    return;
  }
  const { globalConfig } = useGlobalConfig();
  watch(() => globalConfig.value.colorsClasses, (newHelpers) => {
    if (newHelpers.length) {
      handleConfigUpdate(newHelpers, globalConfig.value.colors.variables);
    }
  }, { immediate: true, deep: true });
  watch(() => globalConfig.value.colors.variables, (newColors) => {
    if (!newColors) {
      return;
    }
    handleConfigUpdate(globalConfig.value.colorsClasses, newColors);
  }, { immediate: true, deep: true });
  return {
    renderColorHelpers: () => {
      const coloredHelpers = getColorsClassesHelpers(globalConfig.value.colorsClasses, globalConfig.value.colors.variables);
      return getColorsClassesStyles(coloredHelpers);
    }
  };
};
var ColorsClassesPlugin = defineVuesticPlugin(() => ({
  install(app) {
    defineGlobalProperty(app, "$vaColorsClasses", createColorHelpersPlugin());
  }
}));

// node_modules/vuestic-ui/dist/web-components/src/components/va-accordion/hooks/useAccordion.js
var AccordionServiceKey = Symbol("AccordionService");
var useAccordion = (props, state) => {
  const items2 = ref([]);
  const makeState = () => {
    const correctItemsCount = Math.max(items2.value.length, state.value.length);
    return Array.from({ length: correctItemsCount }, (_, index) => {
      return state.value[index] ?? false;
    });
  };
  const getItemValue = (item) => {
    return state.value[items2.value.indexOf(item)] ?? false;
  };
  const onItemsChanged = () => {
    state.value = makeState();
  };
  const registerItem = (item) => {
    items2.value.push(item);
    onItemsChanged();
  };
  const unregisterItem = (item) => {
    items2.value = items2.value.filter((i) => i !== item);
    nextTick(onItemsChanged);
  };
  const setItemValue = (item, value) => {
    const index = items2.value.indexOf(item);
    if (index === -1) {
      warn("Accordion item is not registered yet");
      return;
    }
    if (!props.multiple) {
      state.value = makeState().map((el, i) => {
        if (i === index) {
          return value;
        }
        return false;
      });
    } else {
      state.value[index] = value;
    }
  };
  provide(AccordionServiceKey, {
    registerItem,
    unregisterItem,
    getItemValue,
    setItemValue,
    props: computed(() => props)
  });
  return { items: items2 };
};
var useAccordionItem = () => {
  const accordion = inject(AccordionServiceKey, void 0);
  if (!accordion) {
    return { accordionProps: ref({}) };
  }
  const item = {};
  accordion.registerItem(item);
  onBeforeUnmount(() => accordion.unregisterItem(item));
  const accordionItemValue = computed({
    get: () => accordion.getItemValue(item),
    set: (value) => accordion.setItemValue(item, value)
  });
  return {
    accordionItemValue,
    accordionProps: accordion.props
  };
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-accordion/VaAccordion.vue_vue_type_script_setup_true_lang.js
var _hoisted_14 = { class: "va-accordion" };
var _sfc_main7 = defineComponent({
  ...{
    name: "VaAccordion"
  },
  __name: "VaAccordion",
  props: {
    ...useStatefulProps,
    ...useComponentPresetProp,
    modelValue: { type: Array, default: () => [] },
    multiple: { type: Boolean, default: false },
    inset: { type: Boolean, default: false },
    stateful: { type: Boolean, default: true },
    popout: { type: Boolean, default: false }
  },
  emits: [...useStatefulEmits],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const { valueComputed } = useStateful(props, emit, "modelValue");
    const { items: items2 } = useAccordion(props, valueComputed);
    const collapses = items2;
    const value = valueComputed;
    __expose({
      collapses,
      value
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_14, [
        renderSlot(_ctx.$slots, "default")
      ]);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-accordion/VaAccordion.js
var _style_06 = ".va-accordion {\n  font-family: var(--va-font-family);\n}\n.va-accordion > .va-collapse:not(:first-child, :last-child) .va-collapse__header {\n  border-radius: 0;\n}\n.va-accordion > .va-collapse.va-collapse--expanded:last-child .va-collapse__header {\n  border-radius: 0;\n}";
var _VaAccordion = _export_sfc(_sfc_main7, [["styles", [_style_06]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-accordion/index.js
var VaAccordion = withConfigTransport$1(_VaAccordion);

// node_modules/vuestic-ui/dist/web-components/src/components/va-affix/VaAffix-utils.js
function getWindowHeight() {
  return document.documentElement.clientHeight || window.innerHeight || document.body.clientHeight;
}
function computeAffixedState({
  coordinates,
  offsetTop,
  offsetBottom,
  target
}) {
  let isTopAffixed = false;
  let isBottomAffixed = false;
  const windowHeight = getWindowHeight();
  if (offsetTop != null && windowHeight) {
    if (target === window) {
      isTopAffixed = coordinates.top <= offsetTop;
    } else {
      const { top } = target.getBoundingClientRect();
      isTopAffixed = coordinates.top - top <= offsetTop;
    }
  }
  if (offsetBottom != null && windowHeight) {
    if (target === window) {
      isBottomAffixed = coordinates.bottom >= windowHeight - offsetBottom;
    } else {
      const { bottom } = target.getBoundingClientRect();
      isBottomAffixed = bottom - coordinates.bottom <= offsetBottom;
    }
  }
  return {
    isTopAffixed,
    isBottomAffixed
  };
}
function checkAffixedStateChange(currentState, nextState) {
  return currentState.isTopAffixed !== nextState.isTopAffixed || currentState.isBottomAffixed !== nextState.isBottomAffixed;
}
function handleThrottledEvent(eventName, context) {
  const { target, element, offsetTop, offsetBottom, setState, getState, initialPosition } = context;
  if (!element) {
    return;
  }
  const isInitialCall = !eventName;
  const coordinates = element.getBoundingClientRect();
  const options = {
    offsetBottom,
    offsetTop,
    target
  };
  const nextState = isInitialCall && initialPosition ? computeAffixedState({ coordinates: initialPosition, ...options }) : computeAffixedState({ coordinates, ...options });
  const prevState = getState();
  if (checkAffixedStateChange(prevState, nextState)) {
    setState({ ...nextState, width: coordinates.width });
  } else if (prevState.width !== coordinates.width) {
    setState({ ...prevState, width: coordinates.width });
  }
}
function useCaptureDefault(eventName) {
  return eventName === "scroll";
}
function useEventsHandlerWithThrottle(events, {
  handler,
  useCapture = useCaptureDefault,
  wait = 50
}) {
  const clearHandlersArray = events.map((eventName) => {
    const _handler = throttle$1((event) => handler(eventName, event), wait);
    window.addEventListener(eventName, _handler, useCapture(eventName));
    return () => window.removeEventListener(eventName, _handler, useCapture(eventName));
  });
  return () => clearHandlersArray.forEach((clear) => clear());
}

// node_modules/vuestic-ui/dist/web-components/src/components/va-affix/VaAffix.vue_vue_type_script_setup_true_lang.js
var _sfc_main8 = defineComponent({
  ...{
    name: "VaAffix"
  },
  __name: "VaAffix",
  props: {
    ...useComponentPresetProp,
    offsetTop: { type: Number, default: void 0 },
    offsetBottom: { type: Number, default: void 0 },
    target: { type: [Object, Function], default: getWindow }
  },
  emits: ["change"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const element = shallowRef();
    const getTargetElement2 = () => typeof props.target === "function" ? props.target() : props.target;
    const isAffixed = computed(() => state.value.isTopAffixed || state.value.isBottomAffixed);
    const state = ref({
      isTopAffixed: false,
      isBottomAffixed: false
    });
    const getState = () => state.value;
    const setState = (newState) => {
      state.value = newState;
      emit("change", isAffixed);
    };
    const calculateTop = () => {
      const target = getTargetElement2();
      if (!target) {
        return 0;
      }
      if (props.offsetTop === void 0) {
        return;
      }
      if (!(target instanceof Window)) {
        const { top } = target.getBoundingClientRect();
        return top + props.offsetTop;
      }
      return props.offsetTop;
    };
    const calculateBottom = () => {
      const target = getTargetElement2();
      if (!target) {
        return 0;
      }
      if (props.offsetBottom === void 0) {
        return;
      }
      if (!(target instanceof Window)) {
        const { bottom } = target.getBoundingClientRect();
        const { borderTopWidth, borderBottomWidth } = getComputedStyle(target);
        const { offsetHeight, clientHeight } = target;
        const scrollBarHeight = offsetHeight - clientHeight - parseInt(borderTopWidth) - parseInt(borderBottomWidth);
        return getWindowHeight() - (bottom - props.offsetBottom) + scrollBarHeight;
      }
      return props.offsetBottom;
    };
    const convertToPixels = (calculate) => {
      const result = calculate();
      return result === void 0 ? void 0 : `${result}px`;
    };
    const computedClass = computed(() => [{ "va-affix--affixed": isAffixed }]);
    const computedStyle = computed(() => ({
      top: state.value.isTopAffixed ? convertToPixels(calculateTop) : void 0,
      bottom: state.value.isBottomAffixed ? convertToPixels(calculateBottom) : void 0,
      width: `${state.value.width}px`
    }));
    const initialPosition = ref();
    const throttledEventHandler = (eventName, event) => {
      const context = {
        ...props,
        initialPosition: initialPosition.value,
        element: element.value,
        target: getTargetElement2(),
        setState,
        getState
      };
      if (!eventName || eventName === "resize") {
        handleThrottledEvent(eventName, context);
      } else if (event && event.target) {
        const target = getTargetElement2();
        if (target === event.target || target instanceof Window) {
          handleThrottledEvent(eventName, context);
        } else {
          setState({
            isBottomAffixed: false,
            isTopAffixed: false
          });
        }
      }
    };
    let clearEventListeners = noop$1;
    onMounted(() => {
      var _a2;
      initialPosition.value = (_a2 = element.value) == null ? void 0 : _a2.getBoundingClientRect();
      const events = ["scroll", "resize"];
      clearEventListeners = useEventsHandlerWithThrottle(events, {
        handler: throttledEventHandler
      });
      nextTick(() => {
        throttledEventHandler(null);
      });
    });
    onBeforeUnmount(clearEventListeners);
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        ref_key: "element",
        ref: element,
        class: "va-affix"
      }, [
        createBaseVNode("div", {
          style: normalizeStyle({ visibility: isAffixed.value ? "hidden" : "inherit" })
        }, [
          renderSlot(_ctx.$slots, "default")
        ], 4),
        isAffixed.value ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: normalizeClass(computedClass.value),
          style: normalizeStyle(computedStyle.value)
        }, [
          renderSlot(_ctx.$slots, "default")
        ], 6)) : createCommentVNode("", true)
      ], 512);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-affix/VaAffix.js
var _style_07 = ":root,\n:host {\n  --va-affix-affixed-z-index: 10;\n  --va-affix-affixed-position: fixed;\n}\n.va-affix {\n  font-family: var(--va-font-family);\n}\n.va-affix--affixed {\n  position: var(--va-affix-affixed-position);\n  z-index: var(--va-affix-affixed-z-index);\n}";
var _VaAffix = _export_sfc(_sfc_main8, [["styles", [_style_07]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-affix/index.js
var VaAffix = withConfigTransport$1(_VaAffix);

// node_modules/vuestic-ui/dist/web-components/src/composables/useElementTextColor.js
var useElementTextColor = (background) => {
  const { textColorComputed } = useTextColor(background);
  return textColorComputed;
};

// node_modules/vuestic-ui/dist/web-components/src/composables/useElementBackground.js
var parseRgba = (rgba) => {
  let values;
  if (rgba.startsWith("rgba")) {
    values = rgba.substring(5, rgba.length - 1).split(",");
  } else {
    values = rgba.substring(4, rgba.length - 1).split(",");
  }
  values[0] = Number(values[0]);
  values[1] = Number(values[1]);
  values[2] = Number(values[2]);
  if (values[3] === void 0) {
    values[3] = 1;
  } else {
    values[3] = Number(values[3]);
  }
  return values;
};
var toHex = (color) => {
  return "#" + (color[0] | 1 << 8).toString(16).slice(1) + (color[1] | 1 << 8).toString(16).slice(1) + (color[2] | 1 << 8).toString(16).slice(1) + (color[3] * 255 | 1 << 8).toString(16).slice(1);
};
var getParentsWithBackground = (el) => {
  const parents = [];
  let currentEl = el;
  while (currentEl) {
    if (!(currentEl instanceof HTMLElement) || !currentEl) {
      return parents;
    }
    const { backgroundColor, willChange } = window.getComputedStyle(currentEl);
    const bgWillChange = willChange.includes("background");
    const parsedColor = parseRgba(backgroundColor);
    if (parsedColor[3] === 1 && !bgWillChange) {
      parents.push(currentEl);
      return parents;
    }
    if (parsedColor[3] !== 0 || bgWillChange) {
      parents.push(currentEl);
    }
    currentEl = currentEl.parentElement;
  }
  return parents;
};
var WATCHER_CLASS = "va-background-watcher";
var watchElementBackground = (el, cb) => {
  el.className = WATCHER_CLASS + " " + el.className;
  el.addEventListener("transitionend", (e) => {
    if (e.target !== el) {
      return;
    }
    cb();
  });
  return () => {
    el.className = el.className.replace(WATCHER_CLASS, "");
    el.removeEventListener("transitionend", cb);
  };
};
var watchElementsBackground = (els, cb) => {
  const unwatchers = els.map((el) => watchElementBackground(el, cb));
  return () => {
    unwatchers.forEach((unwatch) => unwatch());
  };
};
var applyColors2 = (color1, color2) => {
  const weight = color2[3];
  if (weight === 1) {
    return color2;
  }
  if (weight === 0) {
    return color1;
  }
  const c1 = Math.round(color1[0] * (1 - weight) + color2[0] * weight);
  const c2 = Math.round(color1[1] * (1 - weight) + color2[1] * weight);
  const c3 = Math.round(color1[2] * (1 - weight) + color2[2] * weight);
  return [c1, c2, c3, 1];
};
var getColorFromElements = (els) => {
  let currentColor = [0, 0, 0, 0];
  for (let i = els.length - 1; i >= 0; i--) {
    currentColor = applyColors2(currentColor, parseRgba(window.getComputedStyle(els[i]).backgroundColor));
  }
  return currentColor;
};
var useElementBackground = (el) => {
  const color = ref("#000000");
  let unWatchAll = () => void 0;
  watchEffect(() => {
    unWatchAll();
    if (el.value) {
      const parents = getParentsWithBackground(el.value);
      unWatchAll = watchElementsBackground(parents, () => {
        color.value = toHex(getColorFromElements(parents));
      });
      color.value = toHex(getColorFromElements(parents));
    }
  });
  return color;
};

// node_modules/vuestic-ui/dist/web-components/src/composables/useCurrentElement.js
var useCurrentElement = (el) => {
  if (el) {
    return el;
  }
  const vm = getCurrentInstance();
  const currentEl = shallowRef();
  onMounted(() => {
    currentEl.value = vm.proxy.$el ?? void 0;
  });
  onUpdated(() => {
    currentEl.value = vm.proxy.$el ?? void 0;
  });
  onBeforeUnmount(() => {
    currentEl.value = vm.proxy.$el ?? void 0;
  });
  return currentEl;
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-alert/useAlertStyles.js
var useAlertStyles = (props) => {
  const { getColor } = useColors();
  const isTransparentBackground = computed(() => Boolean(props.outline || props.border));
  const { textColorComputed } = useTextColor(toRef(props, "color"), isTransparentBackground);
  const colorComputed = computed(() => getColor(props.color));
  const alertStyle = computed(() => {
    let background = colorComputed.value;
    let boxShadow = "none";
    if (props.outline) {
      background = "transparent";
    }
    if (props.border) {
      background = "var(--va-background-primary)";
      boxShadow = "var(--va-alert-box-shadow)";
    }
    return {
      border: props.outline ? `1px solid ${colorComputed.value}` : "",
      padding: props.dense ? "var(--va-alert-padding-y-dense) var(--va-alert-padding-x)" : "",
      backgroundColor: background,
      boxShadow
    };
  });
  const currentColor = useElementTextColor(useElementBackground(useCurrentElement()));
  const contentStyle = computed(() => {
    return {
      alignItems: props.center ? "center" : "",
      color: props.border || props.outline ? currentColor.value : textColorComputed.value
    };
  });
  const titleStyle = computed(() => {
    return { color: textColorComputed.value };
  });
  const borderStyle = computed(() => ({
    backgroundColor: props.borderColor ? getColor(props.borderColor) : colorComputed.value
  }));
  return {
    alertStyle,
    contentStyle,
    titleStyle,
    borderStyle
  };
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-alert/VaAlert.vue_vue_type_script_setup_true_lang.js
var _hoisted_15 = {
  key: 1,
  class: "va-alert__close"
};
var _hoisted_24 = ["aria-label"];
var _sfc_main9 = defineComponent({
  ...{
    name: "VaAlert"
  },
  __name: "VaAlert",
  props: {
    ...useStatefulProps,
    ...useComponentPresetProp,
    modelValue: { type: Boolean, default: true },
    stateful: { type: Boolean, default: true },
    color: { type: String, default: "primary" },
    textColor: { type: String, default: "" },
    title: { type: String, default: "" },
    description: { type: String, default: "" },
    icon: { type: String, default: "" },
    closeText: { type: String, default: "" },
    closeIcon: { type: String, default: "close" },
    closeable: { type: Boolean, default: false },
    dense: { type: Boolean, default: false },
    outline: { type: Boolean, default: false },
    center: { type: Boolean, default: false },
    borderColor: { type: String, default: "" },
    border: {
      type: String,
      default: "",
      validator: (value) => ["top", "right", "bottom", "left", ""].includes(value)
    }
  },
  emits: [...useStatefulEmits],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const {
      contentStyle,
      titleStyle,
      alertStyle,
      borderStyle
    } = useAlertStyles(props);
    const { valueComputed } = useStateful(props, emit);
    const hide = () => {
      valueComputed.value = false;
    };
    const show = () => {
      valueComputed.value = true;
    };
    const slots = useSlots();
    const hasIcon = computed(() => props.icon || slots.icon);
    const hasTitle = computed(() => props.title || slots.title);
    const borderClass = computed(() => `va-alert__border--${props.border}`);
    const { tp, t } = useTranslation();
    __expose({
      hide,
      show
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(Transition, { name: "fade" }, {
        default: withCtx(() => [
          unref(valueComputed) ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: "va-alert",
            style: normalizeStyle(unref(alertStyle)),
            role: "alert"
          }, [
            createBaseVNode("div", {
              style: normalizeStyle(unref(borderStyle)),
              class: normalizeClass([borderClass.value, "va-alert__border"])
            }, null, 6),
            hasIcon.value ? (openBlock(), createElementBlock("div", {
              key: 0,
              style: normalizeStyle(unref(contentStyle)),
              class: "va-alert__icon",
              "aria-hidden": "true"
            }, [
              renderSlot(_ctx.$slots, "icon", {}, () => [
                createVNode(unref(VaIcon), { name: __props.icon }, null, 8, ["name"])
              ])
            ], 4)) : createCommentVNode("", true),
            createBaseVNode("div", {
              style: normalizeStyle(unref(contentStyle)),
              class: "va-alert__content"
            }, [
              hasTitle.value ? (openBlock(), createElementBlock("div", {
                key: 0,
                style: normalizeStyle(unref(titleStyle)),
                class: "va-alert__title"
              }, [
                renderSlot(_ctx.$slots, "title", {}, () => [
                  createTextVNode(toDisplayString(__props.title), 1)
                ])
              ], 4)) : createCommentVNode("", true),
              createBaseVNode("span", null, [
                renderSlot(_ctx.$slots, "default", {}, () => [
                  createTextVNode(toDisplayString(_ctx.$props.description), 1)
                ])
              ])
            ], 4),
            __props.closeable ? (openBlock(), createElementBlock("div", _hoisted_15, [
              createBaseVNode("div", {
                role: "button",
                class: "va-alert__close--closeable",
                tabindex: "0",
                "aria-label": __props.closeText || unref(t)("closeAlert"),
                style: normalizeStyle(unref(contentStyle)),
                onClick: hide,
                onKeydown: [
                  withKeys(hide, ["space"]),
                  withKeys(hide, ["enter"])
                ]
              }, [
                renderSlot(_ctx.$slots, "close", {}, () => [
                  !__props.closeText ? (openBlock(), createBlock(unref(VaIcon), {
                    key: 0,
                    name: __props.closeIcon
                  }, null, 8, ["name"])) : createCommentVNode("", true),
                  createTextVNode(" " + toDisplayString(__props.closeText), 1)
                ])
              ], 44, _hoisted_24)
            ])) : createCommentVNode("", true)
          ], 4)) : createCommentVNode("", true)
        ]),
        _: 3
      });
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-alert/VaAlert.js
var _style_08 = ':root,\n:host {\n  /* General */\n  --va-alert-position: relative;\n  --va-alert-display: flex;\n  --va-alert-align-items: center;\n  --va-alert-margin-y: 0.25rem;\n  --va-alert-padding-x: 0.75rem;\n  --va-alert-padding-y: 0.75rem;\n  --va-alert-padding-y-dense: 0.25rem;\n  --va-alert-border-width: 0;\n  --va-alert-border-radius: 4px;\n  --va-alert-box-shadow: var(--va-box-shadow);\n  --va-alert-color: transparent;\n  --va-alert-title-font-weight: 600;\n  --va-alert-top-border-radius: 4px 4px 0 0;\n  --va-alert-right-border-radius: 0 4px 4px 0;\n  --va-alert-bottom-border-radius: 0 0 4px 4px;\n  --va-alert-left-border-radius: 4px 0 0 4px;\n  --va-badge-margin-right: 0.5rem;\n  --va-badge-padding-x: 0.5rem;\n  --va-badge-padding-y: 0.125rem;\n  --va-badge-border-radius: 0.5rem;\n  --va-badge-font-size: 0.625rem;\n  --va-badge-letter-spacing: 0.0625rem;\n  --va-alert-close-padding-x: 0.5rem;\n  --va-alert-close-padding-y: 0.0625rem;\n  --va-alert-close-font-size: 1rem;\n  --va-alert-stripe-border-size: var(--va-stripe-border-size);\n}\n.va-alert {\n  position: var(--va-alert-position);\n  padding: var(--va-alert-padding-y) var(--va-alert-padding-x);\n  margin: var(--va-alert-margin-y) auto;\n  display: var(--va-alert-display);\n  align-items: var(--va-alert-align-items);\n  border: var(--va-alert-border-width, var(--va-control-border)) solid transparent;\n  border-radius: var(--va-alert-border-radius, var(--va-block-border-radius));\n  font-family: var(--va-font-family);\n}\n.va-alert__border {\n  content: "";\n  position: absolute;\n}\n.va-alert__border--top {\n  border-radius: var(--va-alert-top-border-radius);\n  width: 100%;\n  height: var(--va-alert-stripe-border-size);\n  top: 0;\n  left: 0;\n}\n.va-alert__border--right {\n  border-radius: var(--va-alert-right-border-radius);\n  height: 100%;\n  width: var(--va-alert-stripe-border-size);\n  bottom: 0;\n  right: 0;\n}\n.va-alert__border--bottom {\n  border-radius: var(--va-alert-bottom-border-radius);\n  width: 100%;\n  height: var(--va-alert-stripe-border-size);\n  bottom: 0;\n  left: 0;\n}\n.va-alert__border--left {\n  border-radius: var(--va-alert-left-border-radius);\n  height: 100%;\n  width: var(--va-alert-stripe-border-size);\n  bottom: 0;\n  left: 0;\n}\n.va-alert__icon {\n  display: flex;\n  align-items: center;\n  padding-right: var(--va-alert-padding-x);\n}\n.va-alert__title {\n  display: flex;\n  align-items: center;\n}\n.va-alert__content {\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  flex-grow: 1;\n  color: var(--va-alert-color);\n}\n.va-alert:focus-visible {\n  outline: 2px solid var(--va-focus) !important;\n  border-radius: "inherit";\n}\n.va-alert__close {\n  padding-left: var(--va-alert-close-padding-x);\n  font-size: var(--va-alert-close-font-size);\n}\n.va-alert__close--closeable {\n  display: flex;\n  align-items: center;\n  cursor: pointer;\n}\n.va-alert__close--closeable:focus-visible {\n  outline: 2px solid var(--va-focus) !important;\n  border-radius: "inherit";\n}\n@media (max-width: 575.98px) {\n.va-alert__content {\n    flex-direction: column;\n    align-items: flex-start;\n}\n.va-alert__close {\n    align-self: flex-start;\n    display: flex;\n    align-items: flex-start;\n    padding: 0 var(--va-alert-close-padding-x) 0 0;\n    margin: 0;\n}\n}';
var _VaAlert = _export_sfc(_sfc_main9, [["styles", [_style_08]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-alert/index.js
var VaAlert = withConfigTransport$1(_VaAlert);

// node_modules/vuestic-ui/dist/web-components/src/composables/useFixedBar.js
var useFixedBarProps = {
  hideOnScroll: { type: Boolean, default: false },
  fixed: { type: Boolean, default: false },
  bottom: { type: Boolean, default: false }
};
function useFixedBar(props, isScrolledDown) {
  const isHiddenComputed = computed(() => isScrolledDown.value ? !!props.hideOnScroll : false);
  const transformComputed = computed(() => {
    if (!props.bottom && !isHiddenComputed.value) {
      return;
    }
    if (props.bottom && isHiddenComputed.value) {
      return "translateY(100%)";
    }
    if (props.bottom) {
      return props.fixed ? "translateY(-100%)" : "translateY(0)";
    }
    return "translateY(-100%)";
  });
  const positionComputed = computed(() => {
    if (props.fixed) {
      return "fixed";
    }
    return isHiddenComputed.value ? "absolute" : void 0;
  });
  const fixedBarStyleComputed = computed(() => {
    const result = {
      top: props.bottom && (isHiddenComputed.value || props.fixed) ? "100%" : void 0,
      transform: props.hideOnScroll || props.fixed ? transformComputed.value : void 0
    };
    positionComputed.value && Object.assign(result, { position: positionComputed.value });
    return result;
  });
  return { fixedBarStyleComputed };
}

// node_modules/vuestic-ui/dist/web-components/src/composables/useScroll.js
function getTargetElement(target) {
  if (!target) {
    throw new Error("No target was provided for `useScroll` hook!");
  }
  return typeof target === "string" ? document.querySelector(target) : target;
}
function setupScroll(fixed, target) {
  const scrollRoot = shallowRef();
  let targetElement;
  const isScrolledDown = ref(false);
  const prevScrollPosition = ref(0);
  const onScroll = (e) => {
    const target2 = e.target;
    const scrollValue = e.target instanceof Window ? target2.scrollY : target2.scrollTop;
    isScrolledDown.value = prevScrollPosition.value < scrollValue;
    prevScrollPosition.value = scrollValue;
  };
  onMounted(() => {
    targetElement = fixed ? window : getTargetElement(target || scrollRoot.value);
    targetElement == null ? void 0 : targetElement.addEventListener("scroll", onScroll, fixed);
  });
  onBeforeUnmount(() => {
    targetElement == null ? void 0 : targetElement.removeEventListener("scroll", onScroll);
  });
  return { scrollRoot, isScrolledDown };
}

// node_modules/vuestic-ui/dist/web-components/src/components/va-app-bar/VaAppBar.vue_vue_type_script_setup_true_lang.js
var _sfc_main10 = defineComponent({
  ...{
    name: "VaAppBar"
  },
  __name: "VaAppBar",
  props: {
    ...useFixedBarProps,
    ...useComponentPresetProp,
    gradient: { type: Boolean, default: false },
    target: { type: [Object, String], default: "" },
    shadowOnScroll: { type: Boolean, default: false },
    shadowColor: { type: String, default: "" },
    color: { type: String, default: "primary" }
  },
  setup(__props) {
    const props = __props;
    const { scrollRoot, isScrolledDown } = setupScroll(props.fixed, props.target);
    const { fixedBarStyleComputed } = useFixedBar(props, isScrolledDown);
    const { getColor, getGradientBackground: getGradientBackground2, getBoxShadowColor: getBoxShadowColor2 } = useColors();
    const colorComputed = computed(() => getColor(props.color));
    const { textColorComputed } = useTextColor(toRef(props, "color"));
    const showShadowComputed = computed(() => isScrolledDown.value ? !!props.shadowOnScroll : false);
    const shadowColorComputed = computed(() => getColor(props.shadowColor, colorComputed.value));
    const computedShadow = computed(() => {
      const shadow = getBoxShadowColor2(props.shadowColor ? shadowColorComputed.value : colorComputed.value);
      return showShadowComputed.value ? `var(--va-app-bar-shadow) ${shadow}` : "";
    });
    const computedStyle = computed(() => ({
      ...fixedBarStyleComputed.value,
      background: props.gradient ? getGradientBackground2(colorComputed.value) : colorComputed.value,
      boxShadow: computedShadow.value,
      color: textColorComputed.value
    }));
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("header", {
        ref_key: "scrollRoot",
        ref: scrollRoot,
        role: "toolbar",
        class: "va-app-bar",
        style: normalizeStyle(computedStyle.value)
      }, [
        renderSlot(_ctx.$slots, "default")
      ], 4);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-app-bar/VaAppBar.js
var _style_09 = ":root,\n:host {\n  --va-app-bar-position: relative;\n  --va-app-bar-height: auto;\n  --va-app-bar-shadow: 0 0 12px 2px;\n  --va-app-bar-z-index: calc(var(--va-z-index-teleport-overlay) - 100);\n  --va-app-bar-transition: transform 0.5s ease;\n}\n.va-app-bar {\n  display: flex;\n  align-items: center;\n  position: var(--va-app-bar-position);\n  transition: all 0.5s ease;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: var(--va-app-bar-height);\n  min-height: var(--va-app-bar-height);\n  min-width: 100%;\n  font-family: var(--va-font-family);\n  z-index: var(--va-app-bar-z-index);\n}\n.va-app-bar--bottom {\n  top: 100%;\n  transform: translateY(-100%);\n}";
var _VaAppBar = _export_sfc(_sfc_main10, [["styles", [_style_09]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-app-bar/index.js
var VaAppBar = withConfigTransport$1(_VaAppBar);

// node_modules/vuestic-ui/dist/web-components/src/components/va-aspect-ratio/VaAspectRatio.vue_vue_type_script_setup_true_lang.js
var _hoisted_16 = { class: "va-aspect-ratio" };
var _sfc_main11 = defineComponent({
  ...{
    name: "VaAspectRatio"
  },
  __name: "VaAspectRatio",
  props: {
    ...useComponentPresetProp,
    ratio: {
      type: [Number, String],
      default: "auto",
      validator: (v) => {
        if (typeof v === "number") {
          return v > 0;
        }
        return v === "auto";
      }
    },
    contentHeight: { type: Number, default: 1 },
    contentWidth: { type: Number, default: 1 },
    maxWidth: {
      type: Number,
      default: 0,
      validator: (v) => v >= 0
    }
  },
  setup(__props) {
    useCssVars((_ctx) => ({
      "26ed1a0b": maxWidthComputed.value
    }));
    const props = __props;
    const aspectRatio = computed(() => {
      if (props.ratio === "auto" && props.contentHeight === 1 && props.contentWidth === 1) {
        return 0;
      }
      if (!isNaN(+props.ratio)) {
        return props.ratio;
      }
      return props.contentWidth / props.contentHeight;
    });
    const stylesComputed = computed(() => {
      if (!aspectRatio.value) {
        return;
      }
      return { paddingBottom: `${1 / aspectRatio.value * 100}%` };
    });
    const maxWidthComputed = computed(() => props.maxWidth ? `${props.maxWidth}px` : void 0);
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_16, [
        stylesComputed.value ? (openBlock(), createElementBlock("div", {
          key: 0,
          style: normalizeStyle(stylesComputed.value)
        }, null, 4)) : createCommentVNode("", true),
        renderSlot(_ctx.$slots, "default")
      ]);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-aspect-ratio/VaAspectRatio.js
var _style_010 = ":root {\n  --va-aspect-ratio-position: relative;\n  --va-aspect-ratio-overflow: visible;\n}\n.va-aspect-ratio {\n  position: var(--va-aspect-ratio-position);\n  overflow: var(--va-aspect-ratio-overflow);\n  display: flex;\n  max-width: var(--26ed1a0b);\n}";
var _VaAspectRatio = _export_sfc(_sfc_main11, [["styles", [_style_010]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-aspect-ratio/index.js
var VaAspectRatio = withConfigTransport$1(_VaAspectRatio);

// node_modules/vuestic-ui/dist/web-components/src/components/va-fallback/VaFallback.vue_vue_type_script_lang.js
var _sfc_main12 = defineComponent({
  name: "VaFallback",
  props: {
    fallbackSrc: {
      type: String
    },
    fallbackText: {
      type: String
    },
    fallbackIcon: {
      type: String
    },
    fallbackRender: {
      type: Function
    }
  },
  components: { VaIcon },
  emits: ["fallback"],
  setup(props, { emit }) {
    onMounted(() => {
      emit("fallback");
    });
    if (props.fallbackIcon) {
      return () => h(VaIcon, {
        name: props.fallbackIcon
      });
    }
    if (props.fallbackSrc) {
      return () => h("img", {
        src: props.fallbackSrc
      });
    }
    if (props.fallbackRender) {
      return () => {
        var _a2;
        return h((_a2 = props.fallbackRender) == null ? void 0 : _a2.call(props));
      };
    }
    return () => h("span", props.fallbackText);
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-fallback/index.js
var VaFallback = withConfigTransport$1(_sfc_main12);

// node_modules/vuestic-ui/dist/web-components/src/utils/component-options/resolve-component-props.js
function normalizeProps2(props) {
  switch (true) {
    case Array.isArray(props):
      return props.reduce((acc, prop) => ({ ...acc, [prop]: null }), {});
    case (typeof props === "object" && props !== null):
      return props;
    default:
      return {};
  }
}
function mergeProps2(to, from, optionsType = "props") {
  const { mixins, extends: extendsOptions } = from;
  extendsOptions && mergeProps2(to, extendsOptions, optionsType);
  mixins && mixins.forEach((m) => mergeProps2(to, m, optionsType));
  const props = normalizeProps2(from[optionsType]);
  for (const key in props) {
    to[key] = props[key];
  }
}
function getComponentOptions(component) {
  if (component.options) {
    return component.options;
  }
  if (component.__vccOpts || component.__b) {
    return { ...component.__vccOpts, ...component.__b };
  }
  return component;
}
function resolveProps(options, optionsType = "props") {
  const mixins = options.mixins ?? [];
  const extendsOptions = options.extends ?? [];
  const result = {};
  mergeProps2(result, extendsOptions, optionsType);
  for (let i = 0; i < mixins.length; i++) {
    mergeProps2(result, mixins[i], optionsType);
  }
  Object.assign(result, normalizeProps2(options[optionsType]));
  return result;
}
var getComponentProps = (component) => {
  return resolveProps(getComponentOptions(component));
};

// node_modules/vuestic-ui/dist/web-components/src/utils/component-options/extract-component-options.js
function extractComponentProps(component, ignoreProps) {
  const props = getComponentProps(component);
  if (ignoreProps) {
    return Object.keys(props).reduce((acc, propName) => {
      if (ignoreProps.includes(propName)) {
        return acc;
      }
      if (props[propName] === void 0) {
        return acc;
      }
      acc[propName] = typeof props[propName] === "string" ? {} : props[propName];
      return acc;
    }, {});
  }
  return props;
}
function extractComponentEmits(component) {
  return [...new Set(component.emits)];
}

// node_modules/vuestic-ui/dist/web-components/src/utils/component-options/filter-props.js
var filterComponentProps = (childProps) => {
  const { props } = getCurrentInstance();
  return computed(() => {
    return Object.keys(childProps).reduce((acc, propName) => {
      acc[propName] = props[propName];
      return acc;
    }, {});
  });
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-avatar/VaAvatar.vue_vue_type_script_setup_true_lang.js
var _hoisted_17 = ["src", "alt"];
var VaFallbackPropsDeclaration = extractComponentProps(VaFallback);
var _sfc_main13 = defineComponent({
  ...{
    name: "VaAvatar"
  },
  __name: "VaAvatar",
  props: {
    ...useLoadingProps,
    ...useSizeProps,
    ...useComponentPresetProp,
    ...VaFallbackPropsDeclaration,
    color: { type: String, default: "primary" },
    textColor: { type: String },
    square: { type: Boolean, default: false },
    fontSize: { type: String, default: "" },
    src: { type: String, default: null },
    icon: { type: String, default: "" },
    alt: { type: String, default: "" }
  },
  emits: ["error", "fallback"],
  setup(__props, { expose: __expose, emit: __emit }) {
    useCssVars((_ctx) => ({
      "ef608708": backgroundColorComputed.value,
      "9ea8b346": unref(textColorComputed),
      "f562da18": unref(sizeComputed)
    }));
    const props = __props;
    const emit = __emit;
    const { getColor } = useColors();
    const colorComputed = computed(() => getColor(props.color));
    const backgroundColorComputed = computed(() => {
      if (props.loading || props.src && !hasLoadError.value) {
        return void 0;
      }
      return colorComputed.value;
    });
    const { sizeComputed, fontSizeComputed } = useSize(props, "VaAvatar");
    const { textColorComputed } = useTextColor(backgroundColorComputed);
    const computedStyle = computed(() => ({
      fontSize: props.fontSize || fontSizeComputed.value
    }));
    const classesComputed = useBem("va-avatar", () => ({
      ...pick$1(props, ["square"])
    }));
    const hasLoadError = ref(false);
    const onLoadError = (event) => {
      hasLoadError.value = true;
      emit("error", event);
    };
    watch(() => props.src, () => {
      hasLoadError.value = false;
    });
    const avatarOptions = computed(() => ({
      hasError: hasLoadError.value,
      onError: onLoadError
    }));
    const VaFallbackProps2 = filterComponentProps(VaFallbackPropsDeclaration);
    __expose({
      hasLoadError
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["va-avatar", unref(classesComputed)]),
        style: normalizeStyle(computedStyle.value)
      }, [
        _ctx.$props.loading ? (openBlock(), createBlock(unref(VaProgressCircle), {
          key: 0,
          size: unref(sizeComputed),
          color: colorComputed.value,
          indeterminate: ""
        }, null, 8, ["size", "color"])) : renderSlot(_ctx.$slots, "default", normalizeProps(mergeProps({ key: 1 }, avatarOptions.value)), () => [
          _ctx.$props.src && !hasLoadError.value ? (openBlock(), createElementBlock("img", {
            key: 0,
            src: _ctx.$props.src,
            alt: _ctx.$props.alt,
            onError: onLoadError
          }, null, 40, _hoisted_17)) : hasLoadError.value && _ctx.$props.src ? renderSlot(_ctx.$slots, "fallback", { key: 1 }, () => [
            createVNode(unref(VaFallback), mergeProps(unref(VaFallbackProps2), {
              onFallback: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("fallback"))
            }), null, 16)
          ]) : _ctx.$props.icon ? (openBlock(), createBlock(unref(VaIcon), {
            key: 2,
            name: _ctx.$props.icon
          }, null, 8, ["name"])) : renderSlot(_ctx.$slots, "fallback", { key: 3 }, () => [
            createVNode(unref(VaFallback), mergeProps(unref(VaFallbackProps2), {
              onFallback: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("fallback"))
            }), null, 16)
          ])
        ])
      ], 6);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-avatar/VaAvatar.js
var _style_011 = ":root,\n:host {\n  /* General */\n  --va-avatar-display: inline-flex;\n  --va-avatar-align-items: center;\n  --va-avatar-justify-content: center;\n  --va-avatar-text-align: center;\n  --va-avatar-vertical-align: middle;\n  --va-avatar-position: relative;\n  --va-avatar-line-height: normal;\n  --va-avatar-border-radius: 50%;\n}\n.va-avatar {\n  align-items: var(--va-avatar-align-items);\n  display: var(--va-avatar-display);\n  justify-content: var(--va-avatar-justify-content);\n  line-height: var(--va-avatar-line-height);\n  position: var(--va-avatar-position);\n  text-align: var(--va-avatar-text-align);\n  vertical-align: var(--va-avatar-vertical-align);\n  border-radius: var(--va-avatar-border-radius);\n  font-family: var(--va-font-family);\n  background-color: var(--ef608708);\n  color: var(--9ea8b346);\n  width: var(--f562da18);\n  min-width: var(--f562da18);\n  height: var(--f562da18);\n}\n.va-avatar--square {\n  --va-avatar-border-radius: 0;\n}\n.va-avatar img,\n.va-avatar svg {\n  border-radius: inherit;\n  display: inline-flex;\n  height: inherit;\n  width: inherit;\n  margin: auto;\n}";
var _VaAvatar = _export_sfc(_sfc_main13, [["styles", [_style_011]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-avatar/index.js
var VaAvatar = withConfigTransport$1(_VaAvatar);

// node_modules/vuestic-ui/dist/web-components/src/components/va-avatar-group/VaAvatarGroup.vue_vue_type_script_setup_true_lang.js
var VaAvatarProps = extractComponentProps(VaAvatar);
var _sfc_main14 = defineComponent({
  ...{
    name: "VaAvatarGroup"
  },
  __name: "VaAvatarGroup",
  props: {
    ...useSizeProps,
    ...useComponentPresetProp,
    ...VaAvatarProps,
    max: {
      type: Number,
      default: 0
    },
    vertical: {
      type: Boolean,
      default: false
    },
    options: {
      type: Array,
      default: () => []
    },
    /** If there are more avatars that can be displayed we show rest number. This prop changes color of rest indicator. */
    restColor: {
      type: String,
      default: "secondary"
    }
  },
  setup(__props) {
    const props = __props;
    const classComputed = useBem("va-avatar-group", () => ({
      ...pick$1(props, ["vertical"])
    }));
    const maxOptions = computed(() => props.max && props.max <= props.options.length ? props.options.slice(0, props.max) : props.options);
    const restOptionsCount = computed(() => {
      const hasOptions = props.options.length > 0;
      const canAddMoreOptions = maxOptions.value.length < props.options.length;
      const remainingOptions = props.options.length - (props.max || 0);
      return hasOptions && canAddMoreOptions ? remainingOptions : 0;
    });
    const { sizeComputed, fontSizeComputed } = useSize(props, "VaAvatarGroup");
    const filteredAvatarProps = filterComponentProps(VaAvatarProps);
    const avatarProps = computed(() => ({
      ...filteredAvatarProps.value,
      fontSize: fontSizeComputed.value,
      size: sizeComputed.value
    }));
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["va-avatar-group", unref(classComputed)]),
        role: "list"
      }, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(maxOptions.value, (option, idx) => {
          return openBlock(), createBlock(unref(VaAvatar), mergeProps({ key: idx }, { ...avatarProps.value, ...option }, { role: "listitem" }), null, 16);
        }), 128)),
        restOptionsCount.value > 0 ? renderSlot(_ctx.$slots, "rest", normalizeProps(mergeProps({ key: 0 }, avatarProps.value)), () => [
          createVNode(unref(VaAvatar), mergeProps(avatarProps.value, {
            color: __props.restColor,
            class: "va-avatar-group__rest",
            role: "listitem"
          }), {
            default: withCtx(() => [
              createTextVNode(" +" + toDisplayString(restOptionsCount.value), 1)
            ]),
            _: 1
          }, 16, ["color"])
        ]) : createCommentVNode("", true)
      ], 2);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-avatar-group/VaAvatarGroup.js
var _style_012 = ":root {\n  --va-avatar-group-gap: -1rem;\n}\n.va-avatar-group {\n  display: flex;\n  flex-wrap: nowrap;\n}\n.va-avatar-group .va-avatar + .va-avatar {\n  margin-left: var(--va-avatar-group-gap);\n}\n.va-avatar-group--vertical {\n  flex-direction: column;\n}\n.va-avatar-group--vertical .va-avatar + .va-avatar {\n  margin-left: 0;\n  margin-top: var(--va-avatar-group-gap);\n}";
var _VaAvatarGroup = _export_sfc(_sfc_main14, [["styles", [_style_012]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-avatar-group/index.js
var VaAvatarGroup = withConfigTransport$1(_VaAvatarGroup);

// node_modules/vuestic-ui/dist/web-components/src/components/va-backtop/VaBacktop.vue_vue_type_script_setup_true_lang.js
var _hoisted_18 = ["aria-label", "onKeydown"];
var _sfc_main15 = defineComponent({
  ...{
    name: "VaBacktop"
  },
  __name: "VaBacktop",
  props: {
    ...useComponentPresetProp,
    target: {
      type: [Object, String],
      default: void 0
    },
    visibilityHeight: { type: Number, default: 300 },
    speed: { type: Number, default: 50 },
    verticalOffset: { type: String, default: "1rem" },
    horizontalOffset: { type: String, default: "1rem" },
    color: { type: String, default: "" },
    horizontalPosition: {
      type: String,
      default: "right",
      validator: (value) => ["right", "left"].includes(value)
    },
    verticalPosition: {
      type: String,
      default: "bottom",
      validator: (value) => ["bottom", "top"].includes(value)
    },
    ariaLabel: { type: String, default: "$t:backToTop" }
  },
  setup(__props) {
    const props = __props;
    const targetScrollValue = ref(0);
    const computedStyle = computed(() => ({
      [props.verticalPosition]: props.verticalOffset,
      [props.horizontalPosition]: props.horizontalOffset
    }));
    let targetElement;
    const getTargetElement2 = () => {
      if (!props.target) {
        return window;
      }
      if (typeof props.target === "string") {
        const target = document.querySelector(props.target);
        if (!target) {
          warn(`Target element [${props.target}] is not found, falling back to window.`);
          return window;
        }
        return target;
      }
      return props.target;
    };
    const scrolled = ref(false);
    const interval = ref(0);
    const scrollToTop = () => {
      if (scrolled.value) {
        return;
      }
      scrolled.value = true;
      if (targetElement instanceof Window) {
        window.scrollTo({
          top: 0,
          behavior: "smooth"
        });
        return;
      }
      interval.value = window.setInterval(() => {
        if (targetElement instanceof Element) {
          if (targetElement.scrollTop === 0) {
            clearInterval(interval.value);
            scrolled.value = false;
          } else {
            const next = Math.floor(targetElement.scrollTop - props.speed);
            targetElement.scrollTo(0, next);
          }
        }
      }, 15);
    };
    const handleScroll = () => {
      targetScrollValue.value = targetElement instanceof Window ? targetElement.scrollY : targetElement.scrollTop;
    };
    const server = isServer();
    const visible = computed(() => {
      if (server) {
        return false;
      }
      return targetScrollValue.value > props.visibilityHeight;
    });
    if (!server) {
      onMounted(() => {
        targetElement = getTargetElement2();
        targetElement.addEventListener("scroll", handleScroll, true);
      });
      onBeforeUnmount(() => targetElement == null ? void 0 : targetElement.removeEventListener("scroll", handleScroll));
    }
    const { tp, t } = useTranslation();
    return (_ctx, _cache) => {
      return visible.value ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: "va-backtop",
        role: "button",
        "aria-label": unref(tp)(_ctx.$props.ariaLabel),
        tabindex: "1",
        style: normalizeStyle(computedStyle.value),
        onClick: scrollToTop,
        onKeydown: withKeys(withModifiers(scrollToTop, ["stop"]), ["enter"])
      }, [
        renderSlot(_ctx.$slots, "default", {}, () => [
          createVNode(unref(VaButton), {
            "aria-hidden": "true",
            icon: "va-arrow-up",
            color: __props.color
          }, null, 8, ["color"])
        ])
      ], 44, _hoisted_18)) : createCommentVNode("", true);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-backtop/VaBacktop.js
var _style_013 = ":root,\n:host {\n  --va-backtop-position: fixed;\n  --va-backtop-top: auto;\n  --va-backtop-left: auto;\n  --va-backtop-right: auto;\n  --va-backtop-bottom: auto;\n  --va-backtop-cursor: pointer;\n  --va-backtop-z-index: 3;\n}\n.va-backtop {\n  position: var(--va-backtop-position);\n  top: var(--va-backtop-top);\n  left: var(--va-backtop-left);\n  right: var(--va-backtop-right);\n  bottom: var(--va-backtop-bottom);\n  cursor: var(--va-backtop-cursor);\n  z-index: var(--va-backtop-z-index);\n  font-family: var(--va-font-family);\n}";
var _VaBacktop = _export_sfc(_sfc_main15, [["styles", [_style_013]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-backtop/index.js
var VaBacktop = withConfigTransport$1(_VaBacktop);

// node_modules/vuestic-ui/dist/web-components/src/composables/usePlacementAliases.js
var verticalPlacement = ["top", "bottom"];
var horizontalPlacement = ["left", "right"];
var placementPosition = [...verticalPlacement, ...horizontalPlacement];
var placementAlignment = ["start", "end", "center"];
var placementsPositions = placementPosition.reduce((acc, position) => {
  acc.push(position);
  placementAlignment.forEach((alignment) => acc.push(`${position}-${alignment}`));
  return acc;
}, ["auto"]);
var placementAliasesPositions = verticalPlacement.reduce((acc, yPosition) => {
  horizontalPlacement.forEach((xPosition) => {
    acc.push(`${yPosition}-${xPosition}`);
    acc.push(`${xPosition}-${yPosition}`);
  });
  return acc;
}, []);
var placementsPositionsWithAliases = [...placementsPositions, ...placementAliasesPositions];
var aliasToPlacement = {
  "top-left": "top-start",
  "left-top": "top-start",
  "top-right": "top-end",
  "right-top": "top-end",
  "bottom-left": "bottom-start",
  "left-bottom": "bottom-start",
  "bottom-right": "bottom-end",
  "right-bottom": "bottom-end"
};
var usePlacementAliasesProps = {
  placement: {
    type: String,
    default: "auto",
    validator: (position) => placementsPositionsWithAliases.includes(position)
  }
};
var usePlacementAliases = (props) => {
  const placementArray = computed(() => {
    const placement = aliasToPlacement[props.placement] || props.placement;
    return placement.split("-");
  });
  const position = computed(() => {
    const position2 = placementArray.value[0];
    return position2 === "auto" ? "bottom" : position2;
  });
  const align = computed(() => {
    return placementArray.value[1] || "center";
  });
  return { position, align };
};

// node_modules/vuestic-ui/dist/web-components/src/composables/useParsableMeasure.js
var useParsableMeasure = () => {
  const isParsableMeasure2 = (value) => {
    if (typeof value === "string") {
      return !isNaN(+value) || value.endsWith("px") || value.endsWith("rem");
    }
    return false;
  };
  const isParsablePositiveMeasure2 = (value) => {
    if (typeof value === "number") {
      return value >= 0;
    }
    return isParsableMeasure2(value) && parseInt(value) >= 0;
  };
  const parseSizeValue3 = (value, pageFontSize = 16) => {
    const valueUnref = unref(value);
    if (typeof valueUnref === "string") {
      const parsedValue = parseInt(valueUnref);
      if (isNaN(parsedValue)) {
        return 0;
      }
      return valueUnref.endsWith("rem") ? parsedValue * unref(pageFontSize) : parsedValue;
    }
    return valueUnref;
  };
  return { isParsableMeasure: isParsableMeasure2, isParsablePositiveMeasure: isParsablePositiveMeasure2, parseSizeValue: parseSizeValue3 };
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-badge/hooks/useFloatingPositionStyles.js
var { isParsableMeasure, parseSizeValue } = useParsableMeasure();
var useFloatingPositionProps = {
  overlap: { type: Boolean, default: false },
  placement: {
    type: String,
    default: "top-end",
    validator: (position) => placementsPositionsWithAliases.includes(position)
  },
  offset: {
    type: [Number, String, Array],
    default: 0,
    validator: (value) => {
      if (Array.isArray(value)) {
        return value.every(isParsableMeasure);
      }
      if (typeof value === "string") {
        return isParsableMeasure(value);
      }
      return !isNaN(value);
    }
  }
};
var useFloatingPosition = (props, floating) => {
  if (!floating.value) {
    return {};
  }
  const { position, align } = usePlacementAliases(props);
  const alignmentShiftComputed = computed(() => {
    const alignOptions = {
      start: props.overlap ? "-50%" : "-100%",
      center: "-50%",
      end: props.overlap ? "-50%" : "0%"
    };
    return alignOptions[align.value];
  });
  const offsetMarginComputed = computed(() => {
    if (!props.offset) {
      return {};
    }
    const mainAxis = ["left", "right"].includes(position.value) ? "top" : "left";
    const crossAxis = mainAxis === "top" ? "left" : "top";
    if (Array.isArray(props.offset)) {
      const [x, y] = props.offset.map(parseSizeValue);
      return {
        [`margin-${mainAxis}`]: `${x}px`,
        [`margin-${crossAxis}`]: `${y}px`
      };
    }
    const offset2 = parseSizeValue(props.offset);
    return {
      [`margin-${crossAxis}`]: `${offset2}px`
    };
  });
  const alignmentComputed = computed(() => {
    const mainAxis = ["left", "right"].includes(position.value) ? "top" : "left";
    const crossAxis = mainAxis === "top" ? "left" : "top";
    let shiftValue = "0%";
    if (crossAxis === "top" && position.value === "bottom") {
      shiftValue = "100%";
    }
    if (crossAxis === "left" && position.value === "right") {
      shiftValue = "100%";
    }
    const alignmentOptions = {
      start: { [mainAxis]: "0%", [crossAxis]: shiftValue },
      center: { [mainAxis]: "50%", [crossAxis]: shiftValue },
      end: { [mainAxis]: "100%", [crossAxis]: shiftValue }
    };
    return alignmentOptions[align.value];
  });
  const transformComputed = computed(() => {
    const coords = {
      top: {
        x: alignmentShiftComputed.value,
        y: props.overlap ? "-50%" : "-100%"
      },
      bottom: {
        x: alignmentShiftComputed.value,
        y: props.overlap ? "-50%" : "0%"
      },
      left: {
        x: props.overlap ? "-50%" : "-100%",
        y: alignmentShiftComputed.value
      },
      right: {
        x: props.overlap ? "-50%" : "0%",
        y: alignmentShiftComputed.value
      }
    };
    const { x, y } = coords[position.value];
    return { transform: `translate(${x}, ${y})` };
  });
  return computed(() => ({
    ...alignmentComputed.value,
    ...transformComputed.value,
    ...offsetMarginComputed.value
  }));
};

// node_modules/vuestic-ui/dist/web-components/src/composables/useDeprecated.js
var OPTIONS_LIST = {
  props: "prop",
  attrs: "prop",
  slots: "slot"
};
var useDeprecated = (deprecatedList, deprecationSource = ["props", "attrs"]) => {
  if (!isDev) {
    return void 0;
  }
  const instance = getCurrentInstance();
  if (!instance) {
    throw new Error("`useDeprecated` hook must be used only inside of setup function!");
  }
  const instanceName = instance.type.name;
  const deprecatedItems = unref(deprecatedList);
  deprecationSource.every((source) => {
    var _a2;
    const option = OPTIONS_LIST[source];
    const throwWarning = (key) => console.warn(`The '${key}' ${option} (${instanceName} component) is deprecated! Please, check the documentation.`);
    if (source === "props") {
      const propsOptions = ((_a2 = instance.propsOptions) == null ? void 0 : _a2[0]) || {};
      const propsValues = instance.props || {};
      deprecatedItems.forEach((propName) => {
        propsOptions[propName] && propsValues[propName] !== propsOptions[propName].default && throwWarning(propName);
      });
      return true;
    }
    Object.keys({ ...instance[source] }).forEach((key) => {
      if (deprecatedItems.includes(key)) {
        throwWarning(key);
      }
    });
    return true;
  });
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-badge/VaBadge.vue_vue_type_script_setup_true_lang.js
var _hoisted_19 = ["aria-labelledby"];
var _hoisted_25 = { class: "va-badge__text" };
var _sfc_main16 = defineComponent({
  ...{
    name: "VaBadge"
  },
  __name: "VaBadge",
  props: {
    ...useComponentPresetProp,
    ...useFloatingPositionProps,
    color: { type: String, default: "danger" },
    textColor: { type: String },
    text: { type: [String, Number], default: "" },
    multiLine: { type: Boolean, default: false },
    visibleEmpty: { type: Boolean, default: false },
    dot: { type: Boolean, default: false },
    // TODO: Remove after 1.8.0
    transparent: { type: Boolean, default: false }
  },
  setup(__props) {
    const props = __props;
    useDeprecated(["transparent"]);
    const slots = useSlots();
    const isEmpty = computed(() => !(props.text || props.visibleEmpty || props.dot || slots.text));
    const isFloating = computed(() => !!(slots.default || props.dot));
    const badgeClass = useBem("va-badge", () => ({
      ...pick$1(props, ["visibleEmpty", "dot", "multiLine"]),
      empty: isEmpty.value,
      floating: isFloating.value
    }));
    const { getColor } = useColors();
    const colorComputed = computed(() => getColor(props.color));
    const { textColorComputed } = useTextColor(colorComputed);
    const positionStylesComputed = useFloatingPosition(props, isFloating);
    const stylesComputed = computed(() => ({
      color: textColorComputed.value,
      borderColor: colorComputed.value,
      backgroundColor: colorComputed.value,
      opacity: props.transparent ? 0.5 : 1,
      ...unref(positionStylesComputed)
    }));
    const ariaLabelledByComputed = computed(() => props.text ? String(props.text) : void 0);
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["va-badge", unref(badgeClass)]),
        role: "status",
        "aria-labelledby": ariaLabelledByComputed.value
      }, [
        createBaseVNode("span", {
          class: "va-badge__text-wrapper",
          style: normalizeStyle(stylesComputed.value)
        }, [
          createBaseVNode("span", _hoisted_25, [
            renderSlot(_ctx.$slots, "text", {}, () => [
              createTextVNode(toDisplayString(__props.text), 1)
            ])
          ])
        ], 4),
        renderSlot(_ctx.$slots, "default")
      ], 10, _hoisted_19);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-badge/VaBadge.js
var _style_014 = ":root,\n:host {\n  /* General */\n  --va-badge-py: 0;\n  --va-badge-font-size: 0.563rem;\n  --va-badge-border: 0.125rem;\n  --va-badge-size: calc(var(--va-badge-font-size) * var(--va-badge-line-height) + var(--va-badge-border) * 2);\n  --va-badge-line-height: 1.4;\n  --va-badge-margin: 0;\n  --va-badge-width: fit-content;\n  /* Dot */\n  --va-badge-dot-size: 0.5rem;\n  /* Text wrapper */\n  --va-badge-text-wrapper-transition: 0.2s cubic-bezier(0.4, 0, 0.6, 1);\n  --va-badge-text-wrapper-display: inline-flex;\n  --va-badge-text-wrapper-border: solid 0.125rem;\n  --va-badge-text-wrapper-border-radius: 0.125rem;\n  --va-badge-text-wrapper-font-weight: 700;\n  --va-badge-text-wrapper-line-height: 1.4;\n  --va-badge-text-wrapper-letter-spacing: 0.0375rem;\n  --va-badge-text-wrapper-justify-content: center;\n  --va-badge-text-wrapper-white-space: nowrap;\n  --va-badge-text-wrapper-width: min-content;\n  --va-badge-text-wrapper-height: auto;\n  --va-badge-text-wrapper-min-width: initial;\n  --va-badge-text-wrapper-min-height: initial;\n  --va-badge-text-wrapper-margin: 0;\n  --va-badge-text-transform: uppercase;\n  /* Text */\n  --va-badge-text-py: 0;\n  --va-badge-text-px: 0.25rem;\n}\n.va-badge {\n  display: inline-flex;\n  position: relative;\n  font-family: var(--va-font-family);\n  width: var(--va-badge-width);\n}\n.va-badge__text-wrapper {\n  transition: var(--va-badge-text-wrapper-transition, var(--va-transition));\n  display: var(--va-badge-text-wrapper-display);\n  border: var(--va-badge-text-wrapper-border, var(--va-control-border));\n  border-radius: var(--va-badge-text-wrapper-border-radius);\n  font-weight: var(--va-badge-text-wrapper-font-weight);\n  line-height: var(--va-badge-text-wrapper-line-height);\n  letter-spacing: var(--va-badge-text-wrapper-letter-spacing, var(--va-letter-spacing));\n  justify-content: var(--va-badge-text-wrapper-justify-content);\n  white-space: var(--va-badge-text-wrapper-white-space);\n  width: var(--va-badge-text-wrapper-width);\n  height: var(--va-badge-text-wrapper-height);\n  min-width: var(--va-badge-text-wrapper-min-width);\n  min-height: var(--va-badge-text-wrapper-min-height);\n  margin: var(--va-badge-text-wrapper-margin);\n}\n.va-badge--visible-empty .va-badge__text-wrapper {\n  min-width: var(--va-badge-size);\n  min-height: var(--va-badge-size);\n}\n.va-badge--dot .va-badge__text-wrapper {\n  min-width: var(--va-badge-dot-size);\n  min-height: var(--va-badge-dot-size);\n  border-width: 0;\n  border-radius: 100%;\n  padding: 0;\n}\n.va-badge--empty .va-badge__text-wrapper {\n  width: 0;\n  height: 0;\n  min-width: 0;\n  min-height: 0;\n  border-width: 0;\n}\n.va-badge--multi-line .va-badge__text-wrapper {\n  white-space: normal;\n}\n.va-badge--floating .va-badge__text-wrapper {\n  position: absolute;\n  z-index: 2;\n}\n.va-badge__text {\n  margin: var(--va-badge-margin);\n  text-transform: var(--va-badge-text-transform);\n  overflow: hidden;\n  min-width: calc(var(--va-badge-font-size) * var(--va-badge-line-height));\n  padding: var(--va-badge-text-py) var(--va-badge-text-px);\n  text-align: center;\n  display: inline-flex;\n  justify-content: center;\n  text-overflow: clip;\n  white-space: nowrap;\n  font-size: var(--va-badge-font-size);\n}\n.va-badge--multi-line .va-badge__text {\n  overflow: auto;\n  max-height: initial;\n  text-align: initial;\n  text-overflow: initial;\n  white-space: normal;\n}\n.va-badge--dot .va-badge__text {\n  display: none;\n}\n.va-badge--floating .va-badge__text {\n  align-items: center;\n  padding: var(--va-badge-py) 0.15rem;\n}";
var _VaBadge = _export_sfc(_sfc_main16, [["styles", [_style_014]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-badge/index.js
var VaBadge = withConfigTransport$1(_VaBadge);

// node_modules/vuestic-ui/dist/web-components/src/utils/has-own-property.js
var hasOwnProperty2 = (object, key) => {
  return Object.prototype.hasOwnProperty.call(object, key);
};

// node_modules/vuestic-ui/dist/web-components/src/utils/resolveSlot.js
var resolveSlot = (slot) => {
  return slot && isFunction$4(slot) ? slot() : slot;
};

// node_modules/vuestic-ui/dist/web-components/src/composables/useAlign.js
var useAlignProps = {
  align: {
    type: String,
    default: "left"
  },
  vertical: {
    type: Boolean,
    default: false
  }
};
var horizontalMap = {
  left: "flex-start",
  center: "center",
  right: "flex-end",
  between: "space-between",
  around: "space-around"
};
var verticalMap = {
  left: "flex-start",
  center: "center",
  right: "flex-end",
  stretch: "stretch"
};
var justify = (align, vertical) => {
  return vertical ? "center" : align ? horizontalMap[align] : "flex-start";
};
var items = (align, vertical) => {
  return vertical ? verticalMap[align] : "center";
};
function useAlign(props) {
  const alignComputed = computed(() => {
    return {
      display: "flex",
      flexDirection: props.vertical ? "column" : "row",
      justifyContent: justify(props.align, props.vertical),
      alignItems: items(props.align, props.vertical)
    };
  });
  return {
    alignComputed
  };
}

// node_modules/vuestic-ui/dist/web-components/src/components/va-breadcrumbs/VaBreadcrumbs.vue_vue_type_script_lang.js
var _sfc_main17 = defineComponent({
  name: "VaBreadcrumbs",
  props: {
    ...useAlignProps,
    ...useComponentPresetProp,
    separator: { type: String, default: "/" },
    color: { type: String, default: null },
    disabledColor: { type: String, default: "secondary" },
    activeColor: { type: String, default: null },
    separatorColor: { type: String, default: null },
    ariaLabel: { type: String, default: "$t:breadcrumbs" }
  },
  setup(props, { slots }) {
    const { alignComputed } = useAlign(props);
    const { getColor } = useColors();
    const computedThemesSeparatorColor = computed(() => {
      return props.separatorColor ? getColor(props.separatorColor) : null;
    });
    const computedThemesColor = computed(() => props.color ? getColor(props.color) : null);
    const computedThemesActiveColor = computed(() => {
      return props.activeColor ? getColor(props.activeColor) : null;
    });
    const childNodeFilter = (result, node) => {
      const nodes = node && node.type === Fragment && node.children ? node.children : [node];
      return [
        ...result,
        ...nodes.filter((node2) => {
          var _a2, _b;
          return !!((_b = (_a2 = node2 == null ? void 0 : node2.type) == null ? void 0 : _a2.name) == null ? void 0 : _b.match(/VaBreadcrumbsItem$/));
        })
      ];
    };
    const createSeparatorComponent = () => {
      const separatorNode = resolveSlot(slots.separator) || [props.separator];
      return h("span", {
        "aria-hidden": true,
        class: ["va-breadcrumbs__separator"],
        style: [{ color: computedThemesSeparatorColor.value }]
      }, separatorNode);
    };
    const isDisabledChild = (child) => {
      const childPropData = child == null ? void 0 : child.props;
      if (!childPropData || !hasOwnProperty2(childPropData, "disabled")) {
        return false;
      }
      if (childPropData.disabled === "") {
        return true;
      }
      return Boolean(childPropData.disabled);
    };
    const isAllChildLinks = ref(true);
    const getChildren = () => {
      const defaultSlotContent = resolveSlot(slots.default);
      if (!defaultSlotContent) {
        return;
      }
      const childNodes = defaultSlotContent.reduce(childNodeFilter, []) || [];
      const childNodesLength = childNodes.length;
      const isLastIndexChildNodes = (index) => index === childNodesLength - 1;
      const isChildLink = (child) => {
        const childPropData = child == null ? void 0 : child.props;
        if (!childPropData || !hasOwnProperty2(childPropData, "to")) {
          return false;
        }
        return !!(childPropData.to && !childPropData.disabled);
      };
      const createChildComponent = (child, index) => h(
        "span",
        {
          class: ["va-breadcrumbs__item", { "va-breadcrumbs__item--disabled": isDisabledChild(child) }],
          "aria-current": isLastIndexChildNodes(index) && isChildLink(child) ? "location" : false,
          style: {
            color: isDisabledChild(child) ? getColor(props.disabledColor) : isLastIndexChildNodes(index) ? computedThemesActiveColor.value : computedThemesColor.value
          }
        },
        [child]
      );
      const children = [];
      if (childNodesLength) {
        childNodes.forEach((child, index) => {
          if (isAllChildLinks.value && !isChildLink(child)) {
            isAllChildLinks.value = false;
          }
          children.push(createChildComponent(child, index));
          if (!isLastIndexChildNodes(index)) {
            children.push(createSeparatorComponent());
          }
        });
      }
      return children;
    };
    const { tp } = useTranslation();
    return () => h("div", {
      class: "va-breadcrumbs",
      style: alignComputed.value,
      role: isAllChildLinks.value ? "navigation" : void 0,
      "aria-label": isAllChildLinks.value ? tp(props.ariaLabel) : void 0
    }, getChildren());
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-breadcrumbs/VaBreadcrumbs.js
var _style_015 = ":root,\n:host {\n  /* General */\n  --va-breadcrumbs-display: flex;\n  --va-breadcrumbs-width: 100%;\n  --va-breadcrumbs-justify-content: center;\n  /* Item */\n  --va-breadcrumbs-item-display: inline-flex;\n  /* Separator */\n  --va-breadcrumbs-separator-padding: var(--va-breadcrumbs-separator-py) var(--va-breadcrumbs-separator-px);\n  --va-breadcrumbs-separator-py: 0;\n  --va-breadcrumbs-separator-px: 0.5rem;\n  --va-breadcrumbs-separator-display: inline-flex;\n}\n.va-breadcrumbs {\n  display: var(--va-breadcrumbs-display);\n  width: var(--va-breadcrumbs-width);\n  justify-content: var(--va-breadcrumbs-justify-content);\n  font-family: var(--va-font-family);\n}\n.va-breadcrumbs__item {\n  display: var(--va-breadcrumbs-item-display);\n}\n.va-breadcrumbs__separator {\n  padding: var(--va-breadcrumbs-separator-padding);\n  display: var(--va-breadcrumbs-separator-display);\n}";
var _VaBreadcrumbs = _export_sfc(_sfc_main17, [["styles", [_style_015]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-breadcrumbs/VaBreadcrumbsItem/VaBreadcrumbsItem.vue_vue_type_script_setup_true_lang.js
var _sfc_main18 = defineComponent({
  ...{
    name: "VaBreadcrumbsItem"
  },
  __name: "VaBreadcrumbsItem",
  props: {
    ...useRouterLinkProps,
    disabled: { type: Boolean, default: false },
    label: { type: String, default: "" }
  },
  setup(__props) {
    const props = __props;
    const { tagComputed, hrefComputed, isLinkTag } = useRouterLink(props);
    const classComputed = computed(() => ({
      "va-breadcrumb-item--link": isLinkTag.value
    }));
    return (_ctx, _cache) => {
      return openBlock(), createBlock(resolveDynamicComponent(unref(tagComputed)), {
        class: normalizeClass(["va-breadcrumb-item", classComputed.value]),
        "active-class": _ctx.$props.activeClass,
        href: unref(hrefComputed),
        to: _ctx.$props.to,
        target: _ctx.$props.target,
        replace: _ctx.$props.replace,
        append: _ctx.$props.append,
        exact: _ctx.$props.exact,
        "exact-active-class": _ctx.$props.exactActiveClass
      }, {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default", {}, () => [
            createTextVNode(toDisplayString(__props.label), 1)
          ])
        ]),
        _: 3
      }, 8, ["class", "active-class", "href", "to", "target", "replace", "append", "exact", "exact-active-class"]);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-breadcrumbs/VaBreadcrumbsItem/VaBreadcrumbsItem.js
var _style_016 = ":root,\n:host {\n  /* General */\n  --va-breadcrumb-item-display: inline-flex;\n  --va-breadcrumb-item-color: inherit;\n  /* Hovered */\n  --va-breadcrumb-item-hover-opacity: 0.7;\n  /* Focused */\n  --va-breadcrumb-item-focus-text-decoration: underline;\n}\n.va-breadcrumb-item {\n  display: var(--va-breadcrumb-item-display);\n  color: var(--va-breadcrumb-item-color);\n}\n.va-breadcrumb-item--link {\n  color: inherit;\n}\n.va-breadcrumb-item--link:hover {\n  opacity: var(--va-breadcrumb-item-hover-opacity);\n}\n.va-breadcrumb-item--link:focus {\n  -webkit-text-decoration: var(--va-breadcrumb-item-focus-text-decoration);\n          text-decoration: var(--va-breadcrumb-item-focus-text-decoration);\n}";
var _VaBreadcrumbsItem = _export_sfc(_sfc_main18, [["styles", [_style_016]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-breadcrumbs/index.js
var VaBreadcrumbsItem = withConfigTransport$1(_VaBreadcrumbsItem);
var VaBreadcrumbs = withConfigTransport$1(_VaBreadcrumbs);

// node_modules/vuestic-ui/dist/web-components/src/components/va-button-group/VaButtonGroup.vue_vue_type_script_setup_true_lang.js
var VaButtonProps = omit$1(extractComponentProps(VaButton), ["block", "gradient"]);
var _sfc_main19 = defineComponent({
  ...{
    name: "VaButtonGroup"
  },
  __name: "VaButtonGroup",
  props: {
    ...VaButtonProps,
    ...useComponentPresetProp,
    grow: { type: Boolean, default: false },
    gradient: { type: Boolean, default: false }
  },
  setup(__props) {
    useCssVars((_ctx) => ({
      "094c61f0": backgroundColor.value
    }));
    const props = __props;
    const { getColor, getGradientBackground: getGradientBackground2 } = useColors();
    const colorComputed = computed(() => getColor(props.color));
    const { textColorComputed } = useTextColor(colorComputed);
    const filteredProps = filterComponentProps(VaButtonProps);
    const buttonConfig = computed(() => ({
      VaButton: {
        ...filteredProps.value,
        ...props.gradient && {
          color: "#00000000",
          textColor: textColorComputed.value
        }
      }
    }));
    const computedClass = useBem("va-button-group", () => ({
      square: !props.round,
      grow: props.grow,
      small: props.size === "small",
      large: props.size === "large"
    }));
    const backgroundColor = computed(
      () => props.gradient ? getGradientBackground2(colorComputed.value) : "transparent"
    );
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["va-button-group", unref(computedClass)])
      }, [
        createVNode(unref(_sfc_main), { components: buttonConfig.value }, {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "default")
          ]),
          _: 3
        }, 8, ["components"])
      ], 2);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-button-group/VaButtonGroup.js
var _style_017 = ':root,\n:host {\n  --va-button-group-display: flex;\n  --va-button-group-justify-content: stretch;\n  --va-button-group-border-radius: 999px;\n  --va-button-group-gap: 0.25rem;\n  /* Button */\n  --va-button-group-button-margin: 0;\n  --va-button-group-button-width: auto;\n  --va-button-group-button-padding: 0.25rem;\n}\n.va-button-group {\n  display: var(--va-button-group-display);\n  justify-content: var(--va-button-group-justify-content);\n  border-radius: var(--va-button-group-border-radius);\n  font-family: var(--va-font-family);\n  width: -moz-max-content;\n  width: max-content;\n  background: var(--094c61f0);\n}\n.va-button-group--grow {\n  width: 100%;\n  --va-button-group-button-width: 100%;\n}\n.va-button-group--square {\n  border-radius: var(--va-button-border-radius);\n}\n.va-button-group--small.va-button-group--square {\n  border-radius: var(--va-button-sm-border-radius);\n}\n.va-button-group--large.va-button-group--square {\n  border-radius: var(--va-button-lg-border-radius);\n}\n.va-button-group .va-button {\n  margin: var(--va-button-group-button-margin);\n  width: var(--va-button-group-button-width);\n  box-shadow: none;\n  outline: none;\n}\n.va-button-group .va-button:focus-visible {\n  outline: none !important;\n}\n.va-button-group .va-button:focus-visible::before {\n  outline: 2px solid var(--va-focus) !important;\n  border-radius: "inherit";\n  outline-offset: -2px;\n}\n.va-button-group > .va-button:last-child {\n  padding-right: var(--va-button-group-button-padding);\n}\n.va-button-group > .va-button:first-child {\n  padding-left: var(--va-button-group-button-padding);\n}\n.va-button-group > .va-button:not(:last-child) {\n  padding-right: var(--va-button-group-gap);\n  border-top-right-radius: 0;\n  border-bottom-right-radius: 0;\n  border-right: 0;\n}\n.va-button-group > .va-button:not(:last-child) .va-button__content {\n  margin-right: 0;\n}\n.va-button-group > .va-button + .va-button {\n  padding-left: var(--va-button-group-gap);\n  border-top-left-radius: 0;\n  border-bottom-left-radius: 0;\n  border-left: 0;\n}\n.va-button-group > .va-button + .va-button .va-button__content {\n  margin-left: 0;\n}';
var _VaButtonGroup = _export_sfc(_sfc_main19, [["styles", [_style_017]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-button-group/index.js
var VaButtonGroup = withConfigTransport$1(_VaButtonGroup);

// node_modules/vuestic-ui/dist/web-components/src/composables/useDebounce.js
var useDebounceFn = (timeout) => {
  let callback = null;
  const createDebounced = () => {
    return debounce$2(() => {
      callback == null ? void 0 : callback();
      callback = null;
    }, unref(timeout));
  };
  let debounced = createDebounced();
  if (isRef(timeout)) {
    watch(timeout, () => {
      debounced = createDebounced();
    });
  }
  return {
    // todo check if we need to create proxy here
    debounced: (cb) => {
      callback = cb;
      debounced();
    },
    cancel: () => debounced.cancel()
  };
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-dropdown/hooks/useDropdownNavigation.js
var isTyping = (e) => {
  const target = e.target;
  if (!(target.tagName === "INPUT" || target.tagName === "TEXTAREA")) {
    return false;
  }
  if (target.attributes.getNamedItem("readonly")) {
    return false;
  }
  return true;
};
var isReadonlyArray = (arr) => {
  return Array.isArray(arr);
};
var useNavigation = (isOpen, anchorRef, contentRef, props) => {
  const normalizeTriggerName = (t) => {
    t = t.replace(/-/g, "").toLowerCase();
    if (t === "space") {
      return " ";
    }
    if (t === "rightclick") {
      return "contextmenu";
    }
    return t;
  };
  const normalizedTriggers = computed(() => {
    if (isReadonlyArray(props.trigger)) {
      return props.trigger.map((t) => normalizeTriggerName(t));
    }
    return [normalizeTriggerName(props.trigger)];
  });
  useEvent("keydown", (e) => {
    if (props.disabled) {
      return;
    }
    if (e.key === "Escape" && isOpen.value) {
      isOpen.value = false;
      e.preventDefault();
    }
    if (isTyping(e)) {
      return;
    }
    if (normalizedTriggers.value.includes(normalizeTriggerName(e.key))) {
      isOpen.value = !isOpen.value;
      e.preventDefault();
    }
  }, anchorRef);
  useEvent("keydown", (e) => {
    if (props.disabled) {
      return;
    }
    if (e.key === "Escape" && isOpen.value) {
      isOpen.value = false;
      e.preventDefault();
    }
  }, contentRef);
  useEvent(["click", "contextmenu", "dblclick"], (e) => {
    if (props.disabled) {
      return;
    }
    if (isTyping(e)) {
      return;
    }
    if (normalizedTriggers.value.includes(normalizeTriggerName(e.type))) {
      e.preventDefault();
      if (isOpen.value && props.closeOnAnchorClick) {
        isOpen.value = false;
        if (props.cursor) {
          setTimeout(() => {
            isOpen.value = true;
          }, 16);
        }
      } else {
        isOpen.value = true;
      }
    }
  }, anchorRef);
  useEvent(["click", "contextmenu", "dblclick"], (e) => {
    if (props.closeOnContentClick) {
      isOpen.value = false;
    }
  }, contentRef);
  const { debounced: debounceHover, cancel: cancelHoverDebounce } = useDebounceFn(toRef(props, "hoverOverTimeout"));
  const { debounced: debounceUnHover, cancel: cancelUnHoverDebounce } = useDebounceFn(toRef(props, "hoverOutTimeout"));
  const onMouseHover = (e) => {
    if (props.disabled) {
      return;
    }
    if (!normalizedTriggers.value.includes("hover")) {
      return;
    }
    if (e.type === "mouseleave") {
      cancelHoverDebounce();
      if (!props.isContentHoverable) {
        isOpen.value = false;
        return;
      }
      debounceUnHover(() => {
        isOpen.value = false;
      });
    } else {
      cancelUnHoverDebounce();
      debounceHover(() => {
        isOpen.value = true;
      });
    }
  };
  useEvent(["mouseleave", "mouseenter"], onMouseHover, anchorRef);
  useEvent(["mouseleave", "mouseenter"], onMouseHover, contentRef);
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-dropdown/hooks/useAnchorSelector.js
var useAnchorSelector = (props) => {
  const anchorRef = ref();
  const document2 = useDocument();
  const isMounted = useIsMounted();
  const computedAnchorRef = computed({
    set(v) {
      anchorRef.value = unwrapEl(v);
    },
    get() {
      var _a2, _b, _c;
      isMounted.value;
      if (typeof props.anchor === "string") {
        return ((_a2 = document2.value) == null ? void 0 : _a2.querySelector(props.anchor)) ?? anchorRef.value;
      }
      if (typeof props.anchor === "object") {
        return props.anchor;
      }
      if (props.anchorSelector) {
        return ((_b = document2.value) == null ? void 0 : _b.querySelector(props.anchorSelector)) ?? anchorRef.value;
      } else if (props.innerAnchorSelector && anchorRef.value) {
        return ((_c = anchorRef.value) == null ? void 0 : _c.querySelector(props.innerAnchorSelector)) ?? anchorRef.value;
      }
      return anchorRef.value;
    }
  });
  return {
    anchorRef: computedAnchorRef
  };
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-dropdown/hooks/useCursorAnchor.js
var useCursorAnchor = (anchorRef, enabled) => {
  const position = reactive({ x: 0, y: 0 });
  useEvent(["mousemove", "mousedown", "mouseup"], (e) => {
    var _a2;
    if (!enabled.value) {
      return;
    }
    const { x, y } = ((_a2 = anchorRef.value) == null ? void 0 : _a2.getBoundingClientRect()) ?? { x: 0, y: 0 };
    position.x = e.clientX - x;
    position.y = e.clientY - y;
  }, anchorRef);
  return computed(() => {
    return {
      getBoundingClientRect() {
        var _a2;
        const { x, y } = ((_a2 = anchorRef.value) == null ? void 0 : _a2.getBoundingClientRect()) ?? { x: 0, y: 0 };
        const resX = position.x + x;
        const resY = position.y + y;
        return {
          width: 0,
          height: 0,
          x: resX,
          y: resY,
          top: resY,
          right: resX,
          bottom: resY,
          left: resX
        };
      },
      contextElement: anchorRef.value
    };
  });
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-dropdown/hooks/useDropdown.js
var useDropdown = (anchorComputed, floating, target, options) => {
  const placementComputed = computed(() => {
    const { position, align } = usePlacementAliases({ placement: options.value.placement });
    return `${position.value}-${align.value}`;
  });
  const offsetComputed = computed(() => {
    const dropdownOffset = options.value.offset;
    const result = { mainAxis: 0, crossAxis: 0 };
    if (Array.isArray(dropdownOffset)) {
      result.mainAxis = dropdownOffset[0];
      result.crossAxis = dropdownOffset[1];
    }
    if (typeof dropdownOffset === "number") {
      result.mainAxis = dropdownOffset;
    }
    return result;
  });
  const middlewareComputed = computed(() => {
    const { autoPlacement, stickToEdges, keepAnchorWidth, verticalScrollOnOverflow } = options.value;
    const result = [
      offset(offsetComputed.value)
    ];
    if (autoPlacement) {
      result.push(
        // boundary doesn't work with ssr (trying to access document)
        flip({
          boundary: target.value
        })
      );
    }
    if (stickToEdges) {
      result.push(
        shift()
      );
    }
    if (keepAnchorWidth || verticalScrollOnOverflow) {
      result.push(size({
        apply({ elements, availableHeight }) {
          if (keepAnchorWidth) {
            const reference = elements.reference;
            const availableWidth = reference.getBoundingClientRect().width;
            Object.assign(elements.floating.style, {
              // Don't set width here, because some plugin applies width 100% and it breaks layout
              maxWidth: `${availableWidth}px`,
              minWidth: `${availableWidth}px`
            });
          }
          if (verticalScrollOnOverflow) {
            Object.assign(elements.floating.style, {
              maxHeight: `${availableHeight}px`
            });
          }
        }
      }));
    }
    return result;
  });
  const { floatingStyles, isPositioned } = typeof document === "undefined" ? { floatingStyles: {}, isPositioned: ref(false) } : useFloating(anchorComputed, floating, {
    placement: placementComputed,
    whileElementsMounted: autoUpdate,
    middleware: middlewareComputed,
    transform: true
  });
  return {
    // Because floating ui by default set top and left to 0 before position calculated, dropdown jumps to the left top corner
    // If user wants to make focus on el as soon as Dropdown is opened, page will be scrolled on the left top corner
    floatingStyles: computed(() => {
      if (!isPositioned.value) {
        return {
          position: "fixed"
        };
      }
      return floatingStyles.value;
    }),
    isPositioned
  };
};

// node_modules/vuestic-ui/dist/web-components/src/composables/useFocusOutside.js
var checkIfElementChild2 = (parent2, child) => {
  if (!child) {
    return false;
  }
  if (child instanceof Window) {
    return false;
  }
  if (child.parentElement === parent2) {
    return true;
  }
  return parent2.contains(child);
};
var safeArray2 = (a) => Array.isArray(a) ? a : [a];
var useFocusOutside = (elements, cb, options = {}) => {
  let previouslyClicked2 = false;
  if (options.onlyKeyboard) {
    useEvent("mousedown", (e) => {
      previouslyClicked2 = true;
      setTimeout(() => {
        previouslyClicked2 = false;
      }, 200);
    }, true);
  }
  useEvent("focus", (event) => {
    if (options.onlyKeyboard && previouslyClicked2) {
      return;
    }
    const focusTarget = event.target;
    if (event.target.shadowRoot) {
      return;
    }
    const isFocusInside = safeArray2(elements).some((element) => {
      const el = unwrapEl(unref(element));
      return el && checkIfElementChild2(el, focusTarget);
    });
    if (!isFocusInside) {
      cb(focusTarget);
    }
  }, true);
};

// node_modules/vuestic-ui/dist/web-components/src/composables/useHTMLElementSelector.js
var useHTMLElementSelector = (key) => {
  return computed(() => {
    if (typeof (key == null ? void 0 : key.value) === "string") {
      return document.querySelector(key.value);
    }
    return unwrapEl(key == null ? void 0 : key.value);
  });
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-dropdown/VaDropdown.vue_vue_type_script_lang.js
var _sfc_main20 = defineComponent({
  name: "VaDropdown",
  props: {
    ...usePlacementAliasesProps,
    ...createStatefulProps(true),
    modelValue: { type: Boolean, default: false },
    anchor: { type: [String, Object], default: void 0 },
    anchorSelector: { type: String, default: "" },
    innerAnchorSelector: { type: String, default: "" },
    trigger: {
      type: [String, Array],
      default: () => ["click", "space", "enter", "arrow-down", "arrow-up"]
    },
    disabled: { type: Boolean },
    readonly: { type: Boolean },
    closeOnClickOutside: { type: Boolean, default: true },
    closeOnFocusOutside: { type: Boolean, default: true },
    closeOnAnchorClick: { type: Boolean, default: true },
    closeOnContentClick: { type: Boolean, default: true },
    hoverOverTimeout: { type: Number, default: 30 },
    hoverOutTimeout: { type: Number, default: 200 },
    isContentHoverable: { type: Boolean, default: true },
    offset: { type: [Array, Number], default: 0 },
    keepAnchorWidth: { type: Boolean, default: false },
    verticalScrollOnOverflow: { type: Boolean, default: true },
    cursor: { type: [Boolean, Object], default: false },
    autoPlacement: { type: Boolean, default: true },
    stickToEdges: { type: Boolean, default: false },
    /** Viewport where dropdown will be rendered. Autoplacement will be calculated relative to `target` */
    target: { type: [String, Object], default: void 0 },
    /** Element where dropdown content will be rendered. */
    teleport: { type: [String, Object], default: void 0 },
    /** Not reactive */
    keyboardNavigation: { type: Boolean, default: true },
    ariaLabel: { type: String, default: "$t:toggleDropdown" },
    role: { type: String, default: "button" }
  },
  emits: [...useStatefulEmits, "anchor-click", "anchor-right-click", "content-click", "click-outside", "focus-outside", "close", "open", "anchor-dblclick"],
  setup(props, { emit }) {
    const { valueComputed } = useStateful(props, emit, "modelValue");
    watch(valueComputed, (isOpened) => {
      if (isOpened) {
        emit("open");
      } else {
        emit("close");
      }
    });
    const isMounted = useIsMounted();
    const { anchorRef } = useAnchorSelector(props);
    const cursorAnchor = useCursorAnchor(anchorRef, computed(() => Boolean(props.cursor)));
    const floating = useHTMLElement("floating");
    const body = useHTMLElementSelector(ref("body"));
    const target = useHTMLElementSelector(computed(() => props.target));
    const teleport = useHTMLElementSelector(computed(() => props.teleport));
    const anchorClass = useBem("va-dropdown", () => pick$1(props, ["disabled"]));
    const teleportTarget = computed(() => {
      if (teleport.value) {
        return teleport.value;
      }
      if (target.value) {
        return target.value;
      }
      if (anchorRef.value) {
        const root2 = anchorRef.value.getRootNode();
        if (root2 instanceof ShadowRoot) {
          const el = [...root2.children].find((c) => c.tagName !== "STYLE");
          if (el) {
            return el;
          }
        }
      }
      return body.value;
    });
    const showFloating = computed(() => isMounted.value && valueComputed.value);
    useNavigation(
      valueComputed,
      anchorRef,
      floating,
      props
    );
    const emitAndClose = (eventName, close, e) => {
      emit(eventName, e);
      if (close) {
        valueComputed.value = false;
      }
    };
    useClickOutside([anchorRef, floating], () => {
      if (props.closeOnClickOutside && valueComputed.value) {
        emitAndClose("click-outside", props.closeOnClickOutside);
      }
    });
    useFocusOutside([floating], () => {
      if (props.closeOnFocusOutside && valueComputed.value) {
        emitAndClose("focus-outside", props.closeOnFocusOutside);
      }
    }, { onlyKeyboard: true });
    const anchorComputed = computed(() => {
      if (typeof props.cursor === "object") {
        return props.cursor;
      }
      return props.cursor ? cursorAnchor.value : anchorRef.value;
    });
    const { floatingStyles } = useDropdown(
      anchorComputed,
      floating,
      target,
      computed(() => ({
        placement: props.placement,
        offset: props.offset,
        autoPlacement: props.autoPlacement,
        stickToEdges: props.stickToEdges,
        keepAnchorWidth: props.keepAnchorWidth,
        verticalScrollOnOverflow: props.verticalScrollOnOverflow
      }))
    );
    const hide = () => {
      valueComputed.value = false;
    };
    const show = () => {
      valueComputed.value = true;
    };
    const {
      zIndex
    } = useZIndex(valueComputed);
    watch(valueComputed, (isOpened) => {
      if (!props.keyboardNavigation) {
        return;
      }
      if (isOpened) {
        nextTick(() => {
          const el = unwrapEl(floating.value);
          if (!el) {
            return;
          }
          focusFirstFocusableChild(el);
        });
      } else {
        if (!anchorRef.value) {
          return;
        }
        focusFirstFocusableChild(anchorRef.value);
      }
    });
    return {
      ...useTranslation(),
      ...useTeleported(),
      anchorRef,
      anchorClass,
      floating,
      floatingStyles,
      showFloating,
      teleportTarget,
      isMounted,
      valueComputed,
      hide,
      show,
      zIndex
    };
  },
  render() {
    const slotBind = {
      isOpened: this.valueComputed,
      hide: this.hide,
      show: this.show,
      toggle: () => this.valueComputed ? this.hide() : this.show(),
      getAnchorWidth: () => {
        var _a2;
        return ((_a2 = this.anchorRef) == null ? void 0 : _a2.offsetWidth) + "px";
      },
      getAnchorHeight: () => {
        var _a2;
        return ((_a2 = this.anchorRef) == null ? void 0 : _a2.offsetHeight) + "px";
      }
    };
    const floatingSlotNode = this.showFloating && renderSlotNode(this.$slots.default, slotBind, {
      ref: "floating",
      class: "va-dropdown__content-wrapper",
      style: [this.floatingStyles, { zIndex: this.zIndex }],
      ...this.teleportedAttrs
    });
    const anchorSlotVNode = renderSlotNode(this.$slots.anchor, slotBind, {
      ref: "anchorRef",
      role: this.$props.role,
      class: ["va-dropdown", ...this.anchorClass.asArray.value],
      style: { position: "relative" },
      "aria-label": this.tp(this.$props.ariaLabel),
      "aria-disabled": this.$props.disabled,
      "aria-expanded": this.$props.role && this.$props.role !== "none" ? !!this.showFloating : void 0,
      ...this.teleportFromAttrs,
      ...this.$attrs
    });
    if (typeof this.$props.cursor === "object" && floatingSlotNode) {
      return h(
        Teleport,
        {
          to: this.teleportTarget,
          disabled: this.$props.disabled
        },
        [floatingSlotNode]
      );
    }
    if (!this.$props.anchorSelector && !anchorSlotVNode) {
      warn("VaDropdown: #anchor slot is missing");
      return;
    }
    if (this.showFloating && !floatingSlotNode) {
      warn("VaDropdown: default slot is missing");
      return;
    }
    return h(Fragment, {}, [
      anchorSlotVNode,
      floatingSlotNode && h(
        Teleport,
        {
          to: this.teleportTarget,
          disabled: this.$props.disabled
        },
        [floatingSlotNode]
      )
    ]);
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-dropdown/VaDropdown.js
var _style_018 = ":root,\n:host {\n  --va-dropdown-line-height: 1;\n  --va-dropdown-content-wrapper-z-index: var(--va-z-index-teleport-overlay, 9);\n  --va-dropdown-display: inline-flex;\n}\n.va-dropdown {\n  /* Solved the alignment problem (if we try to align inline and block elements) */\n  line-height: var(--va-dropdown-line-height);\n  font-family: var(--va-font-family);\n  display: var(--va-dropdown-display);\n  position: relative;\n  max-width: 100%;\n  vertical-align: middle;\n}\n.va-dropdown--disabled {\n  cursor: default;\n  opacity: 0.4;\n  pointer-events: none;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n          user-select: none;\n}\n.va-dropdown__content-wrapper {\n  z-index: var(--va-dropdown-content-wrapper-z-index);\n  font-family: var(--va-font-family);\n  top: 0;\n  left: 0;\n  position: absolute;\n}";
var _VaDropdown = _export_sfc(_sfc_main20, [["styles", [_style_018]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-dropdown/index.js
var VaDropdown = withConfigTransport$1(_VaDropdown);

// node_modules/vuestic-ui/dist/web-components/src/components/va-dropdown/components/VaDropdownContent/VaDropdownContent.vue_vue_type_script_setup_true_lang.js
var _sfc_main21 = defineComponent({
  ...{
    name: "VaDropdownContent"
  },
  __name: "VaDropdownContent",
  props: {
    noPadding: { type: Boolean, default: false },
    background: { type: String, default: "background-secondary" },
    textColor: { type: String }
  },
  setup(__props) {
    const props = __props;
    const { getColor } = useColors();
    const { textColorComputed } = useTextColor(toRef(props, "background"));
    const computedStyle = computed(() => ({
      background: getColor(props.background, void 0, true),
      color: textColorComputed.value,
      padding: props.noPadding ? 0 : void 0
    }));
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: "va-dropdown__content",
        style: normalizeStyle(computedStyle.value),
        role: "listbox"
      }, [
        renderSlot(_ctx.$slots, "default")
      ], 4);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-dropdown/components/VaDropdownContent/VaDropdownContent.js
var _style_019 = ":root,\n:host {\n  --va-dropdown-content-padding: 0.5rem;\n  --va-dropdown-content-box-shadow: var(--va-box-shadow);\n  --va-dropdown-content-border-radius: 4px;\n}\n.va-dropdown__content {\n  overflow-y: auto;\n  padding: var(--va-dropdown-content-padding);\n  box-shadow: var(--va-dropdown-content-box-shadow);\n  border-radius: var(--va-dropdown-content-border-radius);\n  font-family: var(--va-font-family);\n}";
var _VaDropdownContent = _export_sfc(_sfc_main21, [["styles", [_style_019]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-dropdown/components/VaDropdownContent/index.js
var VaDropdownContent = withConfigTransport$1(_VaDropdownContent);

// node_modules/vuestic-ui/dist/web-components/src/composables/useEmitProxy.js
var getEvent = (event) => typeof event === "object" ? event.listen : event;
var getEmit = (event) => typeof event === "object" ? event.emit : event;
var useEmitProxy = (events) => {
  const createEmits3 = () => events.map(getEmit);
  const eventToListenerName = (event) => {
    const eventName = event.charAt(0).toUpperCase() + event.slice(1);
    return `on${eventName}`;
  };
  const createListeners3 = (emit) => {
    return events.reduce((acc, key) => ({
      ...acc,
      [eventToListenerName(getEvent(key))]: (...args) => emit(getEmit(key), ...args)
    }), {});
  };
  const createVOnListeners = (emit) => {
    return events.reduce((acc, key) => ({
      ...acc,
      [getEvent(key)]: (...args) => emit(getEmit(key), ...args)
    }), {});
  };
  return {
    createListeners: createListeners3,
    createVOnListeners,
    createEmits: createEmits3
  };
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-button-dropdown/VaButtonDropdown.vue_vue_type_script_setup_true_lang.js
var { createEmits, createVOnListeners: createListeners } = useEmitProxy(["click"]);
var { createEmits: createMainButtonEmits, createVOnListeners: createMainButtonListeners } = useEmitProxy(
  [{ listen: "click", emit: "main-button-click" }]
);
var VaButtonProps2 = omit$1(extractComponentProps(VaButton), ["iconRight", "block"]);
var VaDropdownProps = extractComponentProps(VaDropdown);
var _sfc_main22 = defineComponent({
  ...{
    name: "VaButtonDropdown"
  },
  __name: "VaButtonDropdown",
  props: {
    ...useComponentPresetProp,
    ...VaButtonProps2,
    ...VaDropdownProps,
    ...useStatefulProps,
    ...usePlacementAliasesProps,
    modelValue: { type: Boolean, default: false },
    stateful: { type: Boolean, default: true },
    icon: { type: String, default: "va-arrow-down" },
    openedIcon: { type: String, default: "va-arrow-up" },
    hideIcon: { type: Boolean, default: false },
    leftIcon: { type: Boolean, default: false },
    iconColor: { type: String, default: "" },
    disabled: { type: Boolean, default: false },
    disableButton: { type: Boolean, default: false },
    disableDropdown: { type: Boolean, default: false },
    offset: { type: [Number, Array], default: 2 },
    keepAnchorWidth: { type: Boolean, default: false },
    closeOnContentClick: { type: Boolean, default: true },
    split: { type: Boolean },
    splitTo: { type: String, default: "" },
    splitHref: { type: String, default: "" },
    loading: { type: Boolean, default: false },
    label: { type: String },
    ariaLabel: { type: String, default: "$t:toggleDropdown" }
  },
  emits: ["update:modelValue", ...createEmits(), ...createMainButtonEmits()],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const { valueComputed } = useStateful(props, emit);
    const computedIcon = computed(() => valueComputed.value ? props.openedIcon : props.icon);
    const computedClass = useBem("va-button-dropdown", () => ({
      split: props.split
    }));
    const slots = useSlots();
    const computedButtonIcons = computed(() => {
      if (props.hideIcon) {
        return {};
      }
      const propName = (props.label || slots.label) && !props.leftIcon ? "icon-right" : "icon";
      return { [propName]: computedIcon.value };
    });
    const buttonPropsFiltered = computed(() => {
      let ignoredProps = ["to", "href", "loading", "icon"];
      const presetProps = [
        "plain",
        "textOpacity",
        "backgroundOpacity",
        "hoverOpacity",
        "hoverBehavior",
        "hoverOpacity",
        "pressedOpacity",
        "pressedBehavior",
        "pressedOpacity"
      ];
      if (props.preset) {
        ignoredProps = [...ignoredProps, ...presetProps];
      }
      const filteredProps = omit$1(VaButtonProps2, ignoredProps);
      return Object.keys(filteredProps);
    });
    const buttonPropsComputed = computed(
      () => Object.entries(props).filter(([key, _]) => buttonPropsFiltered.value.includes(key)).reduce((acc, [key, value]) => {
        Object.assign(acc, { [key]: value });
        return acc;
      }, {})
    );
    const computedMainButtonProps = computed(() => ({
      to: props.splitTo,
      href: props.splitHref,
      loading: props.loading
    }));
    const hideDropdown = () => {
      valueComputed.value = false;
    };
    const vaDropdownProps = filterComponentProps(VaDropdownProps);
    const listeners = createListeners(emit);
    const mainButtonListeners = createMainButtonListeners(emit);
    const { t, tp } = useTranslation();
    __expose({
      hideDropdown
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["va-button-dropdown", unref(computedClass)])
      }, [
        !_ctx.$props.split ? (openBlock(), createBlock(unref(VaDropdown), mergeProps({ key: 0 }, unref(vaDropdownProps), {
          modelValue: unref(valueComputed),
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => isRef(valueComputed) ? valueComputed.value = $event : null),
          disabled: _ctx.$props.disabled || _ctx.$props.disableDropdown
        }), {
          anchor: withCtx(() => [
            createVNode(unref(VaButton), mergeProps({
              "aria-label": unref(tp)(_ctx.$props.ariaLabel)
            }, { ...computedButtonIcons.value, ...buttonPropsComputed.value }, toHandlers(unref(listeners))), {
              default: withCtx(() => [
                renderSlot(_ctx.$slots, "label", {}, () => [
                  createTextVNode(toDisplayString(__props.label), 1)
                ])
              ]),
              _: 3
            }, 16, ["aria-label"])
          ]),
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "content", {}, () => [
              createVNode(unref(VaDropdownContent), null, {
                default: withCtx(() => [
                  renderSlot(_ctx.$slots, "default")
                ]),
                _: 3
              })
            ])
          ]),
          _: 3
        }, 16, ["modelValue", "disabled"])) : (openBlock(), createBlock(unref(VaButtonGroup), normalizeProps(mergeProps({ key: 1 }, buttonPropsComputed.value)), {
          default: withCtx(() => [
            !_ctx.$props.leftIcon ? (openBlock(), createBlock(unref(VaButton), mergeProps({
              key: 0,
              disabled: _ctx.$props.disabled || _ctx.$props.disableButton
            }, computedMainButtonProps.value, toHandlers(unref(mainButtonListeners))), {
              default: withCtx(() => [
                renderSlot(_ctx.$slots, "label", {}, () => [
                  createTextVNode(toDisplayString(__props.label), 1)
                ])
              ]),
              _: 3
            }, 16, ["disabled"])) : createCommentVNode("", true),
            createVNode(unref(VaDropdown), mergeProps(unref(vaDropdownProps), {
              modelValue: unref(valueComputed),
              "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => isRef(valueComputed) ? valueComputed.value = $event : null),
              disabled: _ctx.$props.disabled || _ctx.$props.disableDropdown,
              teleport: _ctx.$el
            }), {
              anchor: withCtx(() => [
                createVNode(unref(VaButton), mergeProps({
                  "aria-label": _ctx.$props.ariaLabel || unref(t)("toggleDropdown"),
                  disabled: _ctx.$props.disabled || _ctx.$props.disableDropdown,
                  icon: computedIcon.value,
                  "icon-color": _ctx.$props.iconColor
                }, toHandlers(unref(listeners)), {
                  onKeydown: withKeys(withModifiers(hideDropdown, ["prevent"]), ["esc"])
                }), null, 16, ["aria-label", "disabled", "icon", "icon-color", "onKeydown"])
              ]),
              default: withCtx(() => [
                createVNode(unref(VaDropdownContent), null, {
                  default: withCtx(() => [
                    renderSlot(_ctx.$slots, "default")
                  ]),
                  _: 3
                })
              ]),
              _: 3
            }, 16, ["modelValue", "disabled", "teleport"]),
            _ctx.$props.leftIcon ? (openBlock(), createBlock(unref(VaButton), mergeProps({
              key: 1,
              disabled: _ctx.$props.disabled || _ctx.$props.disableButton
            }, computedMainButtonProps.value, toHandlers(unref(mainButtonListeners))), {
              default: withCtx(() => [
                renderSlot(_ctx.$slots, "label", {}, () => [
                  createTextVNode(toDisplayString(__props.label), 1)
                ])
              ]),
              _: 3
            }, 16, ["disabled"])) : createCommentVNode("", true)
          ]),
          _: 3
        }, 16))
      ], 2);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-button-dropdown/VaButtonDropdown.js
var _style_020 = ':root,\n:host {\n  --va-button-dropdown-button-margin: 0;\n}\n.va-button-dropdown {\n  display: inline-block;\n  font-family: var(--va-font-family);\n  vertical-align: middle;\n}\n.va-button-dropdown .va-button {\n  margin: var(--va-button-dropdown-button-margin);\n}\n.va-button-dropdown--split .va-button:focus-visible {\n  outline: 2px solid var(--va-focus) !important;\n  border-radius: "inherit";\n  outline-offset: -2px;\n}';
var _VaButtonDropdown = _export_sfc(_sfc_main22, [["styles", [_style_020]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-button-dropdown/index.js
var VaButtonDropdown = withConfigTransport$1(_VaButtonDropdown);

// node_modules/vuestic-ui/dist/web-components/src/utils/isNilValue.js
var isNilValue = (value) => {
  return [null, void 0, ""].includes(value);
};

// node_modules/vuestic-ui/dist/web-components/src/utils/value-by-key.js
var getNestedValue = (option, propsArray) => {
  if (propsArray.length === 0) {
    return option;
  }
  const nestedItem = option[propsArray[0]];
  if (!isObject$d(nestedItem)) {
    if (propsArray.length === 1) {
      return nestedItem;
    }
    return void 0;
  }
  return getNestedValue(nestedItem, propsArray.slice(1));
};
var getValueByPath = (option, prop) => {
  if (prop in option) {
    return option[prop];
  }
  prop = prop.replace(/^\./, "");
  return getNestedValue(option, prop.split("."));
};
var getValueByKey = (option, prop) => {
  if (isNilValue(option) || typeof option !== "object" || Array.isArray(option)) {
    return void 0;
  }
  if (!prop) {
    return option;
  }
  if (typeof prop === "string") {
    return getValueByPath(option, prop);
  }
  if (typeof prop === "function") {
    return prop(option);
  }
  return option;
};

// node_modules/vuestic-ui/dist/web-components/src/utils/is-object.js
var isObject3 = (obj) => {
  return obj !== null && typeof obj === "object";
};

// node_modules/vuestic-ui/dist/web-components/src/composables/useSelectableList.js
var useSelectableListProps = {
  options: { type: Array, default: () => [] },
  textBy: { type: [String, Function], default: "text" },
  valueBy: { type: [String, Function], default: "" },
  trackBy: { type: [String, Function], default: "" },
  disabledBy: { type: [String, Function], default: "disabled" },
  groupBy: { type: [String, Function], default: "group" }
};
function useSelectableList(props) {
  const tryResolveByValue = (value) => {
    const options = props.options;
    for (let i = 0; i < options.length; i++) {
      if (getValue2(options[i]) === value) {
        return options[i];
      }
    }
    return value;
  };
  const getOptionProperty = (option, prop) => {
    if (!isObject3(option)) {
      return option;
    }
    return getValueByKey(option, prop);
  };
  const getTrackBy = (option) => {
    return props.trackBy ? getOptionProperty(option, props.trackBy) : getValue2(option);
  };
  const getDisabled = (option) => {
    if (!isObject3(option)) {
      return false;
    }
    return getOptionProperty(option, props.disabledBy);
  };
  const getText = (option) => {
    const optionText = getOptionProperty(option, props.textBy);
    if (["number", "boolean"].includes(typeof optionText)) {
      return String(optionText);
    }
    return optionText;
  };
  const getGroupBy = (option) => {
    if (!isObject3(option)) {
      return void 0;
    }
    return getOptionProperty(option, props.groupBy);
  };
  const getValue2 = (option) => getOptionProperty(option, props.valueBy);
  return {
    tryResolveByValue,
    getValue: getValue2,
    getText,
    getDisabled,
    getTrackBy,
    getGroupBy
  };
}

// node_modules/vuestic-ui/dist/web-components/src/components/va-button-toggle/VaButtonToggle.vue_vue_type_script_setup_true_lang.js
var VaButtonGroupProps = extractComponentProps(VaButtonGroup);
var _sfc_main23 = defineComponent({
  ...{
    name: "VaButtonToggle"
  },
  __name: "VaButtonToggle",
  props: {
    ...VaButtonGroupProps,
    ...useComponentPresetProp,
    ...useSelectableListProps,
    modelValue: { type: [String, Number, Boolean], default: "" },
    options: {
      type: Array,
      required: true
    },
    activeButtonTextColor: { type: String },
    toggleColor: { type: String, default: "" },
    textBy: { type: [String, Function], default: "label" },
    valueBy: { type: [String, Function], default: "value" }
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const { getText, getTrackBy } = useSelectableList(props);
    const { getColor, shiftHSLAColor: shiftHSLAColor2 } = useColors();
    const colorComputed = computed(() => getColor(props.color));
    const isToggled = (value) => getTrackBy(value) === props.modelValue;
    const activeButtonColor = computed(() => {
      if (props.toggleColor) {
        return getColor(props.toggleColor);
      }
      return shiftHSLAColor2(colorComputed.value, { l: props.plain ? -16 : -6 });
    });
    const activeButtonBackgroundOpacityComputed = computed(() => {
      if (!props.preset || props.preset === "default") {
        return {};
      }
      return { backgroundOpacity: props.pressedOpacity };
    });
    const activeButtonPropsComputed = computed(() => ({
      color: activeButtonColor.value,
      textColor: props.activeButtonTextColor,
      ...activeButtonBackgroundOpacityComputed.value
    }));
    const getButtonProps = (option = {}) => {
      const iconsProps = { icon: option.icon, iconRight: option.iconRight };
      if (!isToggled(option)) {
        return iconsProps;
      }
      return {
        ...isToggled(option) && activeButtonPropsComputed.value,
        ...iconsProps
      };
    };
    const buttonGroupPropsComputed = filterComponentProps(VaButtonGroupProps);
    const changeValue = (value) => emit("update:modelValue", getTrackBy(value));
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(VaButtonGroup), mergeProps({ class: "va-button-toggle" }, unref(buttonGroupPropsComputed)), {
        default: withCtx(() => [
          (openBlock(true), createElementBlock(Fragment, null, renderList(__props.options, (option) => {
            return openBlock(), createBlock(unref(VaButton), mergeProps({
              key: unref(getTrackBy)(option),
              "aria-pressed": isToggled(option)
            }, getButtonProps(option), {
              onClick: ($event) => changeValue(option)
            }), {
              default: withCtx(() => [
                createTextVNode(toDisplayString(unref(getText)(option)), 1)
              ]),
              _: 2
            }, 1040, ["aria-pressed", "onClick"]);
          }), 128))
        ]),
        _: 1
      }, 16);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-button-toggle/VaButtonToggle.js
var _style_021 = '.va-button-toggle .va-button {\n  height: auto;\n}\n.va-button-toggle .va-button:focus-visible {\n  outline: 2px solid var(--va-focus) !important;\n  border-radius: "inherit";\n  outline-offset: -2px;\n}';
var _VaButtonToggle = _export_sfc(_sfc_main23, [["styles", [_style_021]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-button-toggle/index.js
var VaButtonToggle = withConfigTransport$1(_VaButtonToggle);

// node_modules/vuestic-ui/dist/web-components/src/components/va-card/VaCard.vue_vue_type_script_setup_true_lang.js
var _sfc_main24 = defineComponent({
  ...{
    name: "VaCard"
  },
  __name: "VaCard",
  props: {
    ...useRouterLinkProps,
    ...useComponentPresetProp,
    tag: { type: String, default: "div" },
    square: { type: Boolean, default: false },
    outlined: { type: Boolean, default: false },
    bordered: { type: Boolean, default: true },
    disabled: { type: Boolean, default: false },
    href: { type: String, default: "" },
    target: { type: String, default: "" },
    stripe: { type: Boolean, default: false },
    stripeColor: { type: String, default: "" },
    gradient: { type: Boolean, default: false },
    textColor: { type: String },
    color: { type: String, default: "background-secondary" }
  },
  setup(__props) {
    useCssVars((_ctx) => ({
      "790ac25a": stripeColorComputed.value
    }));
    const props = __props;
    const { getColor } = useColors();
    const { isLinkTag, tagComputed, hrefComputed } = useRouterLink(props);
    const { textColorComputed } = useTextColor(computed(() => getColor(props.color)));
    const stripeColorComputed = computed(() => getColor(props.stripeColor));
    const classComputed = useBem("va-card", () => ({
      ...pick$1(props, ["square", "outlined", "disabled", "stripe"]),
      noBorder: !props.bordered,
      link: isLinkTag.value
    }));
    const cardStyles = computed(() => {
      const background = props.gradient && props.color ? getGradientBackground(getColor(props.color)) : getColor(props.color);
      return {
        background,
        color: textColorComputed.value
      };
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(resolveDynamicComponent(unref(tagComputed)), {
        class: normalizeClass(["va-card", unref(classComputed)]),
        style: normalizeStyle(cardStyles.value),
        href: unref(hrefComputed),
        target: __props.target,
        to: _ctx.to,
        replace: _ctx.replace,
        exact: _ctx.exact,
        "active-class": _ctx.activeClass,
        "exact-active-class": _ctx.exactActiveClass
      }, {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 8, ["class", "style", "href", "target", "to", "replace", "exact", "active-class", "exact-active-class"]);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-card/VaCard.js
var _style_022 = ':root,\n:host {\n  --va-card-display: block;\n  --va-card-position: relative;\n  --va-card-overflow: visible;\n  --va-card-box-shadow: var(--va-box-shadow);\n  --va-card-border-radius: 0.375rem;\n  --va-card-color: #34495e;\n  --va-card-background-color: var(--va-background-secondary);\n  --va-card-padding: 1.25rem;\n  /* Outlined */\n  --va-card-outlined-border: 3px solid var(--va-background-element);\n  --va-card-outlined-box-shadow: none;\n  /* Stripe */\n  --va-card-stripe-border-size: var(--va-stripe-border-size);\n  /* Dark */\n  --va-card-dark-color: #ffffff;\n  --va-card-dark-background-color: #34495e;\n  /* Actions */\n  --va-card-actions-btn-margin: 4px;\n}\n.va-card {\n  display: var(--va-card-display);\n  position: var(--va-card-position);\n  overflow: var(--va-card-overflow);\n  box-shadow: var(--va-card-box-shadow, var(--va-block-box-shadow));\n  border-radius: var(--va-card-border-radius, var(--va-block-border-radius));\n  color: var(--va-card-color);\n  background-color: var(--va-card-background-color);\n  font-family: var(--va-font-family);\n}\n.va-card > div:first-child {\n  border-top-right-radius: var(--va-card-border-radius);\n  border-top-left-radius: var(--va-card-border-radius);\n}\n.va-card > div:last-child {\n  border-bottom-right-radius: var(--va-card-border-radius);\n  border-bottom-left-radius: var(--va-card-border-radius);\n}\n.va-card--square {\n  border-radius: 0;\n}\n.va-card--outlined {\n  box-shadow: var(--va-card-outlined-box-shadow);\n  border: var(--va-card-outlined-border, var(--va-block-border));\n}\n.va-card--no-border {\n  border: none;\n}\n.va-card--disabled {\n  cursor: default;\n  opacity: 0.4;\n  pointer-events: none;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n          user-select: none;\n}\n.va-card--link {\n  cursor: pointer;\n}\n.va-card--stripe::after {\n  content: "";\n  position: absolute;\n  width: 100%;\n  height: var(--va-card-stripe-border-size);\n  top: 0;\n  left: 0;\n  background: var(--790ac25a);\n  border-top-right-radius: var(--va-card-border-radius);\n  border-top-left-radius: var(--va-card-border-radius);\n}';
var _VaCard = _export_sfc(_sfc_main24, [["styles", [_style_022]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-card/components/va-card-content/VaCardContent.vue_vue_type_script_setup_true_lang.js
var _hoisted_110 = { class: "va-card__content" };
var _sfc_main25 = defineComponent({
  ...{
    name: "VaCardContent"
  },
  __name: "VaCardContent",
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_110, [
        renderSlot(_ctx.$slots, "default")
      ]);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-card/components/va-card-content/VaCardContent.js
var _style_023 = ".va-card__title, .va-card__content, .va-card__actions, .va-card__actions--vertical {\n  padding: var(--va-card-padding);\n}\n.va-card__title + .va-card__title,\n.va-card__title + .va-card__content,\n.va-card__title + .va-card__actions,\n.va-card__title + .va-card_actions__vertical, .va-card__content + .va-card__title,\n.va-card__content + .va-card__content,\n.va-card__content + .va-card__actions,\n.va-card__content + .va-card_actions__vertical, .va-card__actions + .va-card__title,\n.va-card__actions + .va-card__content,\n.va-card__actions + .va-card__actions,\n.va-card__actions + .va-card_actions__vertical, .va-card__actions--vertical + .va-card__title,\n.va-card__actions--vertical + .va-card__content,\n.va-card__actions--vertical + .va-card__actions,\n.va-card__actions--vertical + .va-card_actions__vertical {\n  padding-top: 0;\n}\n.va-card__content .va-card-block {\n  flex: 1;\n}";
var VaCardContentBase = _export_sfc(_sfc_main25, [["styles", [_style_023]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-card/components/va-card-title/VaCardTitle.vue_vue_type_script_setup_true_lang.js
var _sfc_main26 = defineComponent({
  ...{
    name: "VaCardTitle"
  },
  __name: "VaCardTitle",
  props: {
    ...useComponentPresetProp,
    textColor: { type: String }
  },
  setup(__props) {
    const props = __props;
    const { getColor } = useColors();
    const titleStyles = computed(() => ({
      color: props.textColor ? getColor(props.textColor) : ""
    }));
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: "va-card-title va-card__title",
        style: normalizeStyle(titleStyles.value)
      }, [
        renderSlot(_ctx.$slots, "default", {}, void 0, true)
      ], 4);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-card/components/va-card-title/VaCardTitle.js
var _style_024 = ".va-card__title[data-v-5cd66b25] {\n  display: flex;\n  align-items: center;\n  font-size: 0.625rem;\n  letter-spacing: 0.6px;\n  line-height: 1.2;\n  font-weight: 700;\n  text-transform: uppercase;\n}\n.va-card__title[data-v-5cd66b25], .va-card__content[data-v-5cd66b25], .va-card__actions[data-v-5cd66b25], .va-card__actions--vertical[data-v-5cd66b25] {\n  padding: var(--va-card-padding);\n}\n.va-card__title + .va-card__title[data-v-5cd66b25],\n.va-card__title + .va-card__content[data-v-5cd66b25],\n.va-card__title + .va-card__actions[data-v-5cd66b25],\n.va-card__title + .va-card_actions__vertical[data-v-5cd66b25], .va-card__content + .va-card__title[data-v-5cd66b25],\n.va-card__content + .va-card__content[data-v-5cd66b25],\n.va-card__content + .va-card__actions[data-v-5cd66b25],\n.va-card__content + .va-card_actions__vertical[data-v-5cd66b25], .va-card__actions + .va-card__title[data-v-5cd66b25],\n.va-card__actions + .va-card__content[data-v-5cd66b25],\n.va-card__actions + .va-card__actions[data-v-5cd66b25],\n.va-card__actions + .va-card_actions__vertical[data-v-5cd66b25], .va-card__actions--vertical + .va-card__title[data-v-5cd66b25],\n.va-card__actions--vertical + .va-card__content[data-v-5cd66b25],\n.va-card__actions--vertical + .va-card__actions[data-v-5cd66b25],\n.va-card__actions--vertical + .va-card_actions__vertical[data-v-5cd66b25] {\n  padding-top: 0;\n}";
var VaCardTitleBase = _export_sfc(_sfc_main26, [["styles", [_style_024]], ["__scopeId", "data-v-5cd66b25"]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-card/components/va-card-actions/VaCardActions.vue_vue_type_script_setup_true_lang.js
var _sfc_main27 = defineComponent({
  ...{
    name: "VaCardActions"
  },
  __name: "VaCardActions",
  props: {
    ...useAlignProps,
    ...useComponentPresetProp
  },
  setup(__props) {
    const props = __props;
    const { alignComputed } = useAlign(props);
    const classComputed = useBem("va-card__actions", () => ({
      ...pick$1(props, ["vertical"])
    }));
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["va-card__actions", unref(classComputed)]),
        style: normalizeStyle(unref(alignComputed))
      }, [
        renderSlot(_ctx.$slots, "default")
      ], 6);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-card/components/va-card-actions/VaCardActions.js
var _style_025 = ".va-card__title, .va-card__content, .va-card__actions, .va-card__actions--vertical {\n  padding: var(--va-card-padding);\n}\n.va-card__title + .va-card__title,\n.va-card__title + .va-card__content,\n.va-card__title + .va-card__actions,\n.va-card__title + .va-card_actions__vertical, .va-card__content + .va-card__title,\n.va-card__content + .va-card__content,\n.va-card__content + .va-card__actions,\n.va-card__content + .va-card_actions__vertical, .va-card__actions + .va-card__title,\n.va-card__actions + .va-card__content,\n.va-card__actions + .va-card__actions,\n.va-card__actions + .va-card_actions__vertical, .va-card__actions--vertical + .va-card__title,\n.va-card__actions--vertical + .va-card__content,\n.va-card__actions--vertical + .va-card__actions,\n.va-card__actions--vertical + .va-card_actions__vertical {\n  padding-top: 0;\n}\n.va-card__actions button,\n.va-card__actions .va-button {\n  margin: 0 var(--va-card-actions-btn-margin);\n}\n.va-card__actions button:first-child,\n.va-card__actions .va-button:first-child {\n  margin-left: 0;\n}\n.va-card__actions button:last-child,\n.va-card__actions .va-button:last-child {\n  margin-right: 0;\n}\n.va-card__actions--vertical button,\n.va-card__actions--vertical .va-button {\n  margin: var(--va-card-actions-btn-margin) 0;\n}\n.va-card__actions--vertical button:first-child,\n.va-card__actions--vertical .va-button:first-child {\n  margin-top: 0;\n}\n.va-card__actions--vertical button:last-child,\n.va-card__actions--vertical .va-button:last-child {\n  margin-bottom: 0;\n}";
var VaCardActionsBase = _export_sfc(_sfc_main27, [["styles", [_style_025]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-card/components/va-card-block/VaCardBlock.vue_vue_type_script_setup_true_lang.js
var _sfc_main28 = defineComponent({
  ...{
    name: "VaCardBlock"
  },
  __name: "VaCardBlock",
  props: {
    horizontal: {
      type: Boolean,
      default: false
    }
  },
  setup(__props) {
    const props = __props;
    const classComputed = computed(() => ({
      "va-card-block--horizontal": props.horizontal
    }));
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["va-card-block", classComputed.value])
      }, [
        renderSlot(_ctx.$slots, "default")
      ], 2);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-card/components/va-card-block/VaCardBlock.js
var _style_026 = ".va-card-block {\n  display: flex;\n  flex-direction: column;\n}\n.va-card-block > div:first-child {\n  border-top-right-radius: var(--va-card-border-radius);\n  border-top-left-radius: var(--va-card-border-radius);\n}\n.va-card-block > div:last-child {\n  border-bottom-right-radius: var(--va-card-border-radius);\n  border-bottom-left-radius: var(--va-card-border-radius);\n}\n.va-card-block > div {\n  flex: auto;\n}\n.va-card-block--horizontal {\n  flex-direction: row;\n}\n.va-card-block--horizontal > div:first-child {\n  border-top-left-radius: var(--va-card-border-radius);\n  border-top-right-radius: 0;\n  border-bottom-right-radius: 0;\n  border-bottom-left-radius: var(--va-card-border-radius);\n}\n.va-card-block--horizontal > div:last-child {\n  border-top-left-radius: 0;\n  border-bottom-left-radius: 0;\n  border-top-right-radius: var(--va-card-border-radius);\n  border-bottom-right-radius: var(--va-card-border-radius);\n}\n.va-card-block--horizontal > .va-divider {\n  flex: 0;\n}";
var VaCardBlockBase = _export_sfc(_sfc_main28, [["styles", [_style_026]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-card/index.js
var VaCardContent = withConfigTransport$1(VaCardContentBase);
var VaCardTitle = withConfigTransport$1(VaCardTitleBase);
var VaCardActions = withConfigTransport$1(VaCardActionsBase);
var VaCardBlock = withConfigTransport$1(VaCardBlockBase);
var VaCard = withConfigTransport$1(_VaCard);

// node_modules/vuestic-ui/dist/web-components/src/components/va-carousel/hooks/useCarousel.js
var useCarousel = (props, currentSlide) => {
  const goTo = (index) => {
    currentSlide.value = index;
  };
  const prev = () => {
    if (props.infinite) {
      if (currentSlide.value <= 0) {
        currentSlide.value = props.items.length - 1;
        return;
      }
    }
    currentSlide.value -= 1;
  };
  const next = () => {
    if (props.infinite) {
      if (currentSlide.value >= props.items.length - 1) {
        currentSlide.value = 0;
        return;
      }
    }
    currentSlide.value += 1;
  };
  const doShowDirectionButtons = computed(() => props.items.length > 1);
  const doShowPrevButton = computed(() => currentSlide.value > 0 || props.infinite);
  const doShowNextButton = computed(() => currentSlide.value < props.items.length - 1 || props.infinite);
  return {
    doShowPrevButton,
    doShowNextButton,
    doShowDirectionButtons,
    goTo,
    prev,
    next
  };
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-carousel/hooks/useCarouselAnimation.js
var useCarouselAnimation = (props, currentSlide) => {
  let animationInterval = -1;
  const start = () => {
    if (!props.autoscroll) {
      return;
    }
    clearInterval(animationInterval);
    animationInterval = setInterval(() => {
      currentSlide.value += 1;
      if (currentSlide.value >= props.items.length) {
        currentSlide.value = 0;
      }
    }, props.autoscrollInterval);
  };
  let pauseTimeout;
  const pause = () => {
    if (!props.autoscroll) {
      return;
    }
    clearInterval(animationInterval);
    pauseTimeout = setTimeout(() => {
      start();
      clearTimeout(pauseTimeout);
    }, props.autoscrollPauseDuration);
  };
  const stop = () => {
    clearInterval(animationInterval);
    clearTimeout(pauseTimeout);
  };
  onMounted(() => start());
  onBeforeUnmount(() => stop());
  const withPause = (fn) => {
    return (...args) => {
      pause();
      fn(...args);
    };
  };
  const slidesContainerStyle = ref({
    transition: void 0
  });
  const sliderToBeShown = ref(0);
  const computedSlidesStyle = computed(() => {
    if (props.effect === "fade") {
      return {
        ...slidesContainerStyle.value,
        transition: "none"
      };
    }
    if (props.vertical) {
      return {
        ...slidesContainerStyle.value,
        transform: `translateY(${sliderToBeShown.value * -100}%)`
      };
    }
    return {
      ...slidesContainerStyle.value,
      transform: `translateX(${sliderToBeShown.value * -100}%)`
    };
  });
  const animator = {
    isAnimating: false,
    speed: 0.3,
    order: [],
    move(from, to) {
      const last2 = props.items.length - 1;
      const firstAfterLast = props.items.length;
      if (to === 0 && from === last2) {
        this.order.push({ to: firstAfterLast });
        this.order.push({ to: 0, animate: false });
      } else if (to === last2 && from === 0) {
        this.order.push({ to: firstAfterLast, animate: false });
        this.order.push({ to });
      } else {
        this.order.push({ to });
      }
      if (!this.isAnimating) {
        this.runAnimation();
      }
    },
    runAnimation() {
      this.isAnimating = true;
      const animation = this.order.shift();
      if (!animation) {
        this.isAnimating = false;
        return;
      }
      sliderToBeShown.value = animation == null ? void 0 : animation.to;
      if (animation.animate || animation.animate === void 0) {
        slidesContainerStyle.value.transition = `all ${this.speed}s linear`;
        setTimeout(() => {
          this.runAnimation();
        }, this.speed * 1e3);
      } else {
        slidesContainerStyle.value.transition = "none";
        setTimeout(() => {
          this.runAnimation();
        }, 16);
      }
    }
  };
  watch(currentSlide, (newValue, oldValue) => {
    animator.move(oldValue, newValue);
  });
  const slides = computed(() => {
    if (props.effect === "fade") {
      return [props.items[currentSlide.value]];
    }
    if (props.infinite || props.autoscroll) {
      return [...props.items, props.items[0]];
    }
    return props.items;
  });
  return {
    start,
    pause,
    stop,
    withPause,
    computedSlidesStyle,
    slides
  };
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-carousel/hooks/useCarouselColors.js
var useCarouselColor = () => {
  const { setHSLAColor: setHSLAColor2, getColor } = useColors();
  return {
    computedColor: computed(() => setHSLAColor2(getColor("background-element"), { a: 0.7 })),
    computedHoverColor: computed(() => setHSLAColor2(getColor("primary"), { a: 0.7 })),
    computedActiveColor: computed(() => getColor("primary"))
  };
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-image/hooks/useNativeImgAttributes.js
var useNativeImgAttributesProps = {
  src: { type: String, required: true },
  alt: { type: String, default: "" },
  title: { type: String, default: "" },
  sizes: { type: String, default: "" },
  srcset: { type: String, default: "" },
  draggable: { type: Boolean, default: true },
  loading: {
    type: String
  },
  crossorigin: {
    type: String
  },
  decoding: {
    type: String
  },
  fetchpriority: {
    type: String,
    default: "auto"
  },
  referrerpolicy: {
    type: String
  }
};
var useNativeImgAttributes = (props) => {
  return computed(
    () => pick$1(props, ["src", "alt", "title", "sizes", "srcset", "loading", "referrerpolicy", "fetchpriority", "decoding", "crossorigin", "draggable"])
  );
};

// node_modules/vuestic-ui/dist/web-components/src/composables/useIntersectionObserver.js
var useIntersectionObserver = (cb, options = ref({}), target = ref([]), enabled = true) => {
  const observer = ref();
  const disconnectObserver = () => {
    var _a2;
    (_a2 = observer.value) == null ? void 0 : _a2.disconnect();
  };
  const observeTarget = (target2) => {
    var _a2;
    const disclosedTarget = unwrapEl(unref(target2));
    disclosedTarget && ((_a2 = observer.value) == null ? void 0 : _a2.observe(disclosedTarget));
  };
  const observeAll = (targets) => {
    targets.forEach(observeTarget);
  };
  const initObserver = () => {
    observer.value = new IntersectionObserver(cb, options.value);
  };
  const isIntersectionDisabled = computed(() => !enabled || !(typeof window !== "undefined" && "IntersectionObserver" in window));
  watch([target, options], ([newTarget]) => {
    if (isIntersectionDisabled.value) {
      return;
    }
    disconnectObserver();
    if (!newTarget) {
      return;
    }
    initObserver();
    Array.isArray(newTarget) ? observeAll(newTarget) : observeTarget(newTarget);
  }, { immediate: true });
  onBeforeUnmount(disconnectObserver);
  return { isIntersectionDisabled };
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-image/VaImage.vue_vue_type_script_setup_true_lang.js
var _hoisted_111 = ["aria-busy"];
var _hoisted_26 = {
  key: 0,
  class: "va-image__overlay"
};
var _hoisted_33 = {
  key: 1,
  class: "va-image__error"
};
var _hoisted_43 = {
  key: 2,
  class: "va-image__loader"
};
var _hoisted_53 = {
  key: 3,
  class: "va-image__placeholder"
};
var _hoisted_63 = ["src"];
var VaFallbackProps = extractComponentProps(VaFallback);
var _sfc_main29 = defineComponent({
  ...{
    name: "VaImage"
  },
  __name: "VaImage",
  props: {
    ...useComponentPresetProp,
    ...useNativeImgAttributesProps,
    ...VaFallbackProps,
    ratio: {
      type: [Number, String],
      default: "auto",
      validator: (v) => {
        if (typeof v === "number") {
          return v > 0;
        }
        return v === "auto";
      }
    },
    fit: {
      type: String,
      default: "cover"
    },
    maxWidth: {
      type: Number,
      default: 0,
      validator: (v) => v >= 0
    },
    lazy: { type: Boolean, default: false },
    placeholderSrc: { type: String, default: "" }
  },
  emits: ["loaded", "error", "fallback"],
  setup(__props, { emit: __emit }) {
    useCssVars((_ctx) => ({
      "456b25bc": fitComputed.value
    }));
    const props = __props;
    const emit = __emit;
    const root2 = ref();
    const image = ref();
    const renderedImage = ref();
    const currentImage = computed(() => renderedImage.value || props.src);
    const imgWidth = ref(1);
    const imgHeight = ref(1);
    const isLoading = ref(false);
    const isError = ref(false);
    const handleLoad = () => {
      var _a2;
      isLoading.value = true;
      if (!isReadyForLoad.value) {
        return;
      }
      isLoading.value = false;
      renderedImage.value = (_a2 = image.value) == null ? void 0 : _a2.currentSrc;
      getImgSizes();
      emit("loaded", currentImage.value);
    };
    const handleError = (err) => {
      isError.value = true;
      isLoading.value = false;
      emit("error", err || currentImage.value);
    };
    const isIntersecting = ref(false);
    const handleIntersection = (entries, observer) => {
      entries.forEach((entry) => {
        if (!entry.isIntersecting) {
          return;
        }
        isIntersecting.value = true;
        init();
        observer.disconnect();
      });
    };
    const { isIntersectionDisabled } = useIntersectionObserver(handleIntersection, void 0, root2, props.lazy);
    const isReadyForLoad = computed(() => isIntersectionDisabled.value || isIntersecting.value);
    const isMounted = useIsMounted();
    const isReadyForRender = computed(() => !props.lazy || props.lazy && isMounted.value && isReadyForLoad.value);
    const init = () => {
      if (!props.src || isLoading.value && isIntersectionDisabled.value || !isReadyForLoad.value) {
        return;
      }
      isLoading.value = true;
      isError.value = false;
      nextTick(() => {
        var _a2;
        if (!((_a2 = image.value) == null ? void 0 : _a2.complete)) {
          return;
        }
        if (!image.value.naturalWidth) {
          handleError();
          return;
        }
        handleLoad();
      });
    };
    let timer;
    const getImgSizes = () => {
      clearTimeout(timer);
      if (isLoading.value) {
        timer = window.setTimeout(getImgSizes, 100);
      }
      const { naturalHeight, naturalWidth } = image.value || {};
      if (naturalHeight && naturalWidth) {
        imgWidth.value = naturalHeight;
        imgHeight.value = naturalWidth;
      }
    };
    onBeforeMount(init);
    onBeforeUnmount(() => clearTimeout(timer));
    watch(() => props.src, init);
    const slots = useSlots();
    const isPlaceholderPassed = computed(() => {
      var _a2;
      return ((_a2 = slots == null ? void 0 : slots.placeholder) == null ? void 0 : _a2.call(slots)) || props.placeholderSrc;
    });
    const isLoaderShown = computed(() => {
      var _a2;
      return isLoading.value && !((_a2 = slots == null ? void 0 : slots.loader) == null ? void 0 : _a2.call(slots));
    });
    const isErrorShown = computed(() => {
      var _a2;
      return isError.value && (!((_a2 = slots == null ? void 0 : slots.error) == null ? void 0 : _a2.call(slots)) && !isAnyFallbackPassed.value);
    });
    const isPlaceholderShown = computed(() => (isLoaderShown.value || isErrorShown.value) && isPlaceholderPassed.value);
    const isSuccessfullyLoaded = computed(() => !(isLoading.value || isError.value));
    const imgAttributesComputed = useNativeImgAttributes(props);
    const aspectRationAttributesComputed = computed(() => ({
      ...pick$1(props, ["ratio", "maxWidth"]),
      contentWidth: imgWidth.value,
      contentHeight: imgHeight.value
    }));
    const fallbackProps = filterComponentProps(VaFallbackProps);
    const checkObjectNonEmptyValues = (obj) => !!Object.values(obj || {}).filter((prop) => prop).length;
    const hasFallbackGlobalConfig = computed(() => {
      var _a2, _b, _c, _d;
      return checkObjectNonEmptyValues((_d = (_c = (_b = (_a2 = useGlobalConfig()) == null ? void 0 : _a2.globalConfig) == null ? void 0 : _b.value) == null ? void 0 : _c.components) == null ? void 0 : _d.VaFallback);
    });
    const isAnyFallbackPassed = computed(() => checkObjectNonEmptyValues(fallbackProps.value) || hasFallbackGlobalConfig.value);
    const fitComputed = computed(() => props.fit);
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(VaAspectRatio), mergeProps({
        ref_key: "root",
        ref: root2,
        class: "va-image"
      }, aspectRationAttributesComputed.value), {
        default: withCtx(() => [
          withDirectives(createBaseVNode("picture", {
            class: "va-image__content",
            "aria-busy": isLoading.value
          }, [
            _ctx.$slots.sources ? renderSlot(_ctx.$slots, "sources", { key: 0 }) : createCommentVNode("", true),
            isReadyForRender.value ? (openBlock(), createElementBlock("img", mergeProps({
              key: 1,
              ref_key: "image",
              ref: image
            }, unref(imgAttributesComputed), {
              onError: handleError,
              onLoad: handleLoad
            }), null, 16)) : createCommentVNode("", true)
          ], 8, _hoisted_111), [
            [vShow, isSuccessfullyLoaded.value]
          ]),
          _ctx.$slots.default && isSuccessfullyLoaded.value ? (openBlock(), createElementBlock("div", _hoisted_26, [
            renderSlot(_ctx.$slots, "default")
          ])) : createCommentVNode("", true),
          isError.value && (_ctx.$slots.error || isAnyFallbackPassed.value) ? (openBlock(), createElementBlock("div", _hoisted_33, [
            renderSlot(_ctx.$slots, "error", {}, () => [
              createVNode(unref(VaFallback), mergeProps(unref(fallbackProps), {
                onFallback: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("fallback"))
              }), null, 16)
            ])
          ])) : createCommentVNode("", true),
          isLoading.value && _ctx.$slots.loader ? (openBlock(), createElementBlock("div", _hoisted_43, [
            renderSlot(_ctx.$slots, "loader")
          ])) : createCommentVNode("", true),
          isPlaceholderShown.value ? (openBlock(), createElementBlock("div", _hoisted_53, [
            renderSlot(_ctx.$slots, "placeholder", {}, () => [
              _ctx.$props.placeholderSrc ? (openBlock(), createElementBlock("img", {
                key: 0,
                src: _ctx.$props.placeholderSrc,
                alt: ""
              }, null, 8, _hoisted_63)) : createCommentVNode("", true)
            ])
          ])) : createCommentVNode("", true)
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-image/VaImage.js
var _style_027 = ":root,\n:host {\n  --va-image-content-position: absolute;\n  --va-image-content-img-object-position: 50% 50%;\n}\n.va-image__content {\n  position: var(--va-image-content-position);\n  inset: 0;\n  width: 100%;\n}\n.va-image__content img {\n  width: 100%;\n  height: 100%;\n  object-fit: var(--456b25bc);\n  object-position: var(--va-image-content-img-object-position);\n}\n.va-image__overlay {\n  position: absolute;\n  inset: 0;\n}\n.va-image__placeholder, .va-image__loader, .va-image__error, .va-image__overlay {\n  width: 100%;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n}";
var _VaImage = _export_sfc(_sfc_main29, [["styles", [_style_027]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-image/index.js
var VaImage = withConfigTransport$1(_VaImage);

// node_modules/vuestic-ui/dist/web-components/src/components/va-hover/VaHover.vue_vue_type_script_setup_true_lang.js
var _sfc_main30 = defineComponent({
  ...{
    name: "VaHover"
  },
  __name: "VaHover",
  props: {
    ...createStatefulProps(true),
    ...useComponentPresetProp,
    disabled: { type: Boolean, default: false },
    modelValue: { type: Boolean, default: false }
  },
  emits: [...useStatefulEmits],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const { valueComputed } = useStateful(props, emit);
    const onMouseEnter = () => {
      if (!props.disabled) {
        valueComputed.value = true;
      }
    };
    const onMouseLeave = () => {
      if (!props.disabled) {
        valueComputed.value = false;
      }
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: "va-hover",
        onMouseenter: onMouseEnter,
        onMouseleave: onMouseLeave
      }, [
        renderSlot(_ctx.$slots, "default", normalizeProps(guardReactiveProps({ hover: unref(valueComputed) })))
      ], 32);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-hover/index.js
var VaHover = withConfigTransport$1(_sfc_main30);

// node_modules/vuestic-ui/dist/web-components/src/composables/useSwipe.js
var mouseEvents = ["mousedown", "mousemove"];
var touchEvents = ["touchstart", "touchmove"];
var commonAllowedDirections = {
  vertical: ["", "all", "vertical"],
  horizontal: ["", "all", "horizontal"]
};
var verticalSpecificAllowedDirections = [...commonAllowedDirections.vertical, "up", "down"];
var horizontalSpecificAllowedDirections = [...commonAllowedDirections.horizontal, "left", "right"];
var useSwipeProps = {
  swipable: { type: Boolean, default: false },
  swipeDistance: { type: Number, default: 75 },
  swipeDirection: { type: String, default: "all" }
};
var useSwipe = (props, container, cb) => {
  const swipeStarted = ref(false);
  const swipePath = reactive({
    start: { x: 0, y: 0 },
    end: { x: 0, y: 0 }
  });
  const swipeDuration = reactive({
    start: 0,
    end: 0
  });
  const setState = (e, type) => {
    let event;
    if (mouseEvents.includes(e.type)) {
      event = e;
    }
    if (touchEvents.includes(e.type)) {
      const touchEvent = e;
      event = touchEvent.changedTouches[touchEvent.changedTouches.length - 1];
    }
    if (!event) {
      return;
    }
    swipePath[type].x = event.pageX;
    swipePath[type].y = event.pageY;
    swipeDuration[type] = (/* @__PURE__ */ new Date()).getTime();
  };
  const onSwipeStart = (e) => {
    if (!props.swipable || swipeStarted.value) {
      return;
    }
    swipeStarted.value = true;
    setState(e, "start");
  };
  const onSwipeMove = (e) => {
    if (!swipeStarted.value) {
      return;
    }
    setState(e, "end");
  };
  const resetSwipe = () => {
    ["start", "end"].forEach((type) => {
      swipePath[type].x = 0;
      swipePath[type].y = 0;
      swipeDuration[type] = 0;
    });
    swipeStarted.value = false;
  };
  const isSwipeAllowed = reactive({
    vertical: false,
    horizontal: false
  });
  watchEffect(() => {
    isSwipeAllowed.horizontal = horizontalSpecificAllowedDirections.includes(props.swipeDirection);
    isSwipeAllowed.vertical = verticalSpecificAllowedDirections.includes(props.swipeDirection);
  });
  const calcDistance = (axis) => {
    return isSwipeAllowed[axis === "x" ? "horizontal" : "vertical"] && swipePath.start[axis] && swipePath.end[axis] ? Math.trunc(swipePath.start[axis] - swipePath.end[axis]) : 0;
  };
  const getAcceptableValue = (direction, result) => {
    return result === props.swipeDirection || commonAllowedDirections[direction].includes(props.swipeDirection) ? result : "";
  };
  const swipeState = reactive({ direction: "", duration: 0 });
  watch(swipePath, () => {
    const xDistance = calcDistance("x");
    const yDistance = calcDistance("y");
    if ((xDistance || yDistance) && [xDistance, yDistance].some((el) => Math.abs(el) >= props.swipeDistance)) {
      if (Math.abs(xDistance) >= Math.abs(yDistance) && isSwipeAllowed.horizontal) {
        const result = xDistance > 0 ? "left" : "right";
        swipeState.direction = getAcceptableValue("horizontal", result);
      } else if (Math.abs(xDistance) < Math.abs(yDistance) && isSwipeAllowed.vertical) {
        const result = yDistance > 0 ? "down" : "up";
        swipeState.direction = getAcceptableValue("vertical", result);
      }
      swipeState.duration = swipeDuration.end - swipeDuration.start;
      resetSwipe();
    }
  }, { deep: true });
  watch(swipeState, () => cb(swipeState), { deep: true });
  if (props.swipable) {
    useEvent(["touchstart", "mousedown"], onSwipeStart, container);
    useEvent(["touchmove", "mousemove"], onSwipeMove, container);
    useEvent(["touchcancel", "mouseup", "touchend", "mouseleave"], resetSwipe, container);
  }
  return { swipeState };
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-carousel/VaCarousel.vue_vue_type_script_setup_true_lang.js
var _hoisted_112 = ["aria-label"];
var _hoisted_27 = {
  key: 1,
  class: "va-carousel__indicators"
};
var _hoisted_34 = { class: "va-carousel__content" };
var _hoisted_44 = ["aria-hidden", "aria-current", "aria-label"];
var VaImageProps = extractComponentProps(VaImage, ["src", "alt"]);
var _sfc_main31 = defineComponent({
  ...{
    name: "VaCarousel"
  },
  __name: "VaCarousel",
  props: {
    ...useSwipeProps,
    ...useStatefulProps,
    ...useComponentPresetProp,
    ...VaImageProps,
    stateful: { type: Boolean, default: true },
    modelValue: { type: Number, default: 0 },
    items: { type: Array, required: true },
    // Animations
    autoscroll: { type: Boolean, default: false },
    autoscrollInterval: { type: Number, default: 5e3 },
    autoscrollPauseDuration: { type: Number, default: 2e3 },
    infinite: { type: Boolean, default: true },
    fadeKeyframe: { type: String, default: "va-carousel-fade-appear 1s" },
    // Visual
    arrows: { type: Boolean, default: true },
    indicators: { type: Boolean, default: true },
    indicatorTrigger: {
      type: String,
      default: "click",
      validator: (value) => ["click", "hover", "none"].includes(value)
    },
    vertical: { type: Boolean, default: false },
    height: { type: String, default: "300px" },
    effect: {
      type: String,
      default: "transition",
      validator: (value) => ["fade", "transition"].includes(value)
    },
    color: { type: String, default: "primary" },
    ratio: { type: Number },
    ariaLabel: { type: String, default: "$t:carousel" },
    ariaPreviousLabel: { type: String, default: "$t:goPreviousSlide" },
    ariaNextLabel: { type: String, default: "$t:goNextSlide" },
    ariaGoToSlideLabel: { type: String, default: "$t:goSlide" },
    ariaSlideOfLabel: { type: String, default: "$t:slideOf" }
  },
  emits: [...useStatefulEmits],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const { valueComputed: currentSlide } = useStateful(props, emit, "modelValue");
    const {
      goTo,
      next,
      prev,
      doShowNextButton,
      doShowPrevButton,
      doShowDirectionButtons
    } = useCarousel(props, currentSlide);
    const { withPause, computedSlidesStyle, slides } = useCarouselAnimation(props, currentSlide);
    const isObjectSlides = computed(() => {
      return props.items.length && props.items.every((el) => !!el && typeof el === "object" && !!(el == null ? void 0 : el.src));
    });
    const isCurrentSlide = (index) => index === currentSlide.value;
    const slideStyleComputed = computed(() => ({
      animation: props.effect === "fade" ? "fadeKeyframe" : void 0
    }));
    const slidesContainer = shallowRef();
    const onSwipe = (state) => {
      switch (state.direction) {
        case "right":
        case "up":
          doShowPrevButton.value && prev();
          break;
        case "left":
        case "down":
          doShowNextButton.value && next();
      }
    };
    useSwipe(props, slidesContainer, onSwipe);
    const getIndicatorEvents = (index) => {
      if (props.indicatorTrigger === "hover") {
        return { onmouseover: () => goTo(index) };
      }
      if (props.indicatorTrigger === "click") {
        return { onclick: () => goTo(index) };
      }
      return {};
    };
    const { tp, t } = useTranslation();
    const {
      computedActiveColor,
      computedColor,
      computedHoverColor
    } = useCarouselColor();
    const vaImageProps = filterComponentProps(VaImageProps);
    const goToWithPause = withPause(goTo);
    const prevWithPause = withPause(prev);
    const nextWithPause = withPause(next);
    __expose({
      currentSlide,
      goTo,
      next,
      prev,
      goToWithPause,
      prevWithPause,
      nextWithPause
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["va-carousel", {
          "va-carousel--vertical": _ctx.$props.vertical,
          [`va-carousel--${_ctx.$props.effect}`]: true
        }]),
        style: normalizeStyle({ height: __props.ratio ? "auto" : __props.height }),
        role: "region",
        "aria-label": unref(tp)(_ctx.$props.ariaLabel)
      }, [
        _ctx.$props.arrows && unref(doShowDirectionButtons) ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
          unref(doShowPrevButton) ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: "va-carousel__arrow va-carousel__arrow--left",
            onClick: _cache[0] || (_cache[0] = //@ts-ignore
            (...args) => unref(prevWithPause) && unref(prevWithPause)(...args)),
            onKeydown: _cache[1] || (_cache[1] = withKeys(withModifiers(
              //@ts-ignore
              (...args) => unref(prevWithPause) && unref(prevWithPause)(...args),
              ["stop"]
            ), ["enter"]))
          }, [
            renderSlot(_ctx.$slots, "prev-arrow", {}, () => [
              createVNode(unref(VaHover), { stateful: "" }, {
                default: withCtx(({ hover }) => [
                  createVNode(unref(VaButton), {
                    color: hover ? unref(computedHoverColor) : unref(computedColor),
                    icon: __props.vertical ? "va-arrow-up" : "va-arrow-left",
                    "aria-label": unref(tp)(_ctx.$props.ariaPreviousLabel)
                  }, null, 8, ["color", "icon", "aria-label"])
                ]),
                _: 1
              })
            ])
          ], 32)) : createCommentVNode("", true),
          unref(doShowNextButton) ? (openBlock(), createElementBlock("div", {
            key: 1,
            class: "va-carousel__arrow va-carousel__arrow--right",
            onClick: _cache[2] || (_cache[2] = //@ts-ignore
            (...args) => unref(nextWithPause) && unref(nextWithPause)(...args)),
            onKeydown: _cache[3] || (_cache[3] = withKeys(withModifiers(
              //@ts-ignore
              (...args) => unref(nextWithPause) && unref(nextWithPause)(...args),
              ["stop"]
            ), ["enter"]))
          }, [
            renderSlot(_ctx.$slots, "next-arrow", {}, () => [
              createVNode(unref(VaHover), { stateful: "" }, {
                default: withCtx(({ hover }) => [
                  createVNode(unref(VaButton), {
                    color: hover ? unref(computedHoverColor) : unref(computedColor),
                    icon: __props.vertical ? "va-arrow-down" : "va-arrow-right",
                    "aria-label": unref(tp)(_ctx.$props.ariaNextLabel)
                  }, null, 8, ["color", "icon", "aria-label"])
                ]),
                _: 1
              })
            ])
          ], 32)) : createCommentVNode("", true)
        ], 64)) : createCommentVNode("", true),
        _ctx.$props.indicators ? (openBlock(), createElementBlock("div", _hoisted_27, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.$props.items, (item, index) => {
            return openBlock(), createElementBlock("div", mergeProps({
              class: ["va-carousel__indicator", { "va-carousel__indicator--active": index === __props.modelValue }],
              key: index
            }, getIndicatorEvents(index)), [
              renderSlot(_ctx.$slots, "indicator", normalizeProps(guardReactiveProps({ item, index, goTo: unref(goToWithPause), isActive: isCurrentSlide(index) })), () => [
                createVNode(unref(VaHover), { stateful: "" }, {
                  default: withCtx(({ hover }) => [
                    createVNode(unref(VaButton), {
                      "aria-label": unref(tp)(_ctx.$props.ariaGoToSlideLabel, { index: index + 1 }),
                      round: "",
                      color: isCurrentSlide(index) ? unref(computedActiveColor) : hover ? unref(computedHoverColor) : unref(computedColor)
                    }, {
                      default: withCtx(() => [
                        createTextVNode(toDisplayString(index + 1), 1)
                      ]),
                      _: 2
                    }, 1032, ["aria-label", "color"])
                  ]),
                  _: 2
                }, 1024)
              ])
            ], 16);
          }), 128))
        ])) : createCommentVNode("", true),
        createBaseVNode("div", _hoisted_34, [
          createBaseVNode("div", {
            ref_key: "slidesContainer",
            ref: slidesContainer,
            class: "va-carousel__slides",
            style: normalizeStyle(unref(computedSlidesStyle)),
            role: "list"
          }, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(unref(slides), (item, index) => {
              return openBlock(), createElementBlock("div", {
                key: item,
                role: "listitem",
                class: "va-carousel__slide",
                style: normalizeStyle(slideStyleComputed.value),
                "aria-hidden": !isCurrentSlide(index),
                "aria-current": isCurrentSlide(index),
                "aria-label": unref(tp)(_ctx.$props.ariaSlideOfLabel, { index: index + 1, length: unref(slides).length })
              }, [
                renderSlot(_ctx.$slots, "default", normalizeProps(guardReactiveProps({ item, index, goTo: unref(goToWithPause), isActive: isCurrentSlide(index) })), () => [
                  createVNode(unref(VaImage), mergeProps(unref(vaImageProps), {
                    src: isObjectSlides.value ? item.src : item,
                    alt: isObjectSlides.value ? item.alt : "",
                    draggable: false
                  }), null, 16, ["src", "alt"])
                ])
              ], 12, _hoisted_44);
            }), 128))
          ], 4)
        ])
      ], 14, _hoisted_112);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-carousel/VaCarousel.js
var _style_028 = ':root,\n:host {\n  --va-carousel-background: var(--va-background-secondary);\n  --va-carousel-border-radius: var(--va-block-border-radius);\n  --va-carousel-box-shadow: var(--va-box-shadow);\n  --va-carousel-slides-transition: all 0.3s ease-in-out;\n  --va-carousel-indicators-gap: 0.25rem;\n  --va-carousel-min-height: 80px;\n  /** Fake padding for absolute position elements */\n  --va-carousel-padding: 16px;\n}\n@keyframes va-carousel-fade-appear {\n0% {\n    opacity: 0;\n}\n100% {\n    opacity: 1;\n}\n}\n.va-carousel {\n  display: flex;\n  width: 100%;\n  height: 100%;\n  max-height: 100%;\n  min-height: var(--va-carousel-min-height);\n  background: var(--va-carousel-background);\n  box-shadow: var(--va-carousel-box-shadow);\n  border-radius: var(--va-carousel-border-radius);\n  position: relative;\n  overflow: hidden;\n}\n.va-carousel__content {\n  flex: 1;\n  width: 100%;\n  white-space: nowrap;\n}\n.va-carousel__slides {\n  width: 100%;\n  height: 100%;\n  transition: var(--va-carousel-slides-transition);\n}\n.va-carousel__slide {\n  display: inline-flex;\n  justify-content: center;\n  align-items: center;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.va-carousel__indicators {\n  width: 100%;\n  position: absolute;\n  bottom: var(--va-carousel-padding);\n  display: flex;\n  justify-content: center;\n  z-index: 2;\n  overflow-x: auto;\n  left: 50%;\n  transform: translateX(-50%);\n  scrollbar-color: var(--va-background-element) transparent;\n  scrollbar-width: thin;\n  transition: scrollbar-color 0.3s ease-in-out;\n}\n.va-carousel__indicators::-webkit-scrollbar {\n  width: 4px;\n  height: 4px;\n}\n.va-carousel__indicators::-webkit-scrollbar-track {\n  box-shadow: none;\n  border-radius: 10px;\n}\n.va-carousel__indicators::-webkit-scrollbar-thumb {\n  background: var(--va-background-element);\n  opacity: 0.3;\n  border-radius: 2px;\n  -webkit-transition: background 0.3s ease-in-out;\n  transition: background 0.3s ease-in-out;\n}\n.va-carousel__indicators > * {\n  margin: 0 var(--va-carousel-indicators-gap);\n}\n.va-carousel__arrow {\n  z-index: 1;\n  width: -moz-max-content;\n  width: max-content;\n  height: -moz-max-content;\n  height: max-content;\n}\n.va-carousel__arrow--right {\n  right: var(--va-carousel-padding);\n  position: absolute;\n  top: 50%;\n  transform: translateY(-50%);\n}\n.va-carousel__arrow--left {\n  left: var(--va-carousel-padding);\n  position: absolute;\n  top: 50%;\n  transform: translateY(-50%);\n}\n.va-carousel--vertical .va-carousel__slide {\n  display: flex;\n}\n.va-carousel--vertical .va-carousel__arrow {\n  z-index: 1;\n}\n.va-carousel--vertical .va-carousel__arrow--right {\n  bottom: var(--va-carousel-padding);\n  top: auto;\n  left: 50%;\n  transform: translateX(-50%);\n}\n.va-carousel--vertical .va-carousel__arrow--left {\n  top: var(--va-carousel-padding);\n  left: 50%;\n  transform: translateX(-50%);\n}\n.va-carousel--vertical .va-carousel__indicators {\n  left: var(--va-carousel-padding);\n  flex-direction: column;\n  width: auto;\n  height: 100%;\n  top: 50%;\n  transform: translateY(-50%);\n  overflow-x: hidden;\n  overflow-y: auto;\n}\n.va-carousel--vertical .va-carousel__indicators > * {\n  margin: var(--va-carousel-indicators-gap) 0;\n}\n.va-carousel .va-image {\n  height: 100%;\n  width: 100%;\n}\n.va-carousel .va-button:focus-visible {\n  outline: 2px solid var(--va-focus) !important;\n  border-radius: "inherit";\n  outline-offset: -2px;\n}';
var _VaCarousel = _export_sfc(_sfc_main31, [["styles", [_style_028]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-carousel/index.js
var VaCarousel = withConfigTransport$1(_VaCarousel);

// node_modules/vuestic-ui/dist/web-components/src/composables/useSyncProp.js
function useSyncProp(propName, props, emit, defaultValue) {
  if (defaultValue === void 0) {
    return [
      computed({
        set(value) {
          emit(`update:${propName}`, value);
        },
        get() {
          return props[propName];
        }
      })
    ];
  }
  const currentValue = props[propName];
  const statefulValue = ref(currentValue === void 0 ? defaultValue : currentValue);
  watch(() => props[propName], (newVal) => {
    if (newVal === void 0) {
      return;
    }
    statefulValue.value = newVal;
  });
  return [
    computed({
      set(value) {
        statefulValue.value = value;
        emit(`update:${propName}`, value);
      },
      get() {
        return props[propName] === void 0 ? statefulValue.value : props[propName];
      }
    })
  ];
}

// node_modules/vuestic-ui/dist/web-components/src/utils/watch-setter.js
var isComputedRef = (value) => {
  return typeof value === "object" && "_setter" in value;
};
var watchSetter = (ref2, cb) => {
  if (!isComputedRef(ref2)) {
    return;
  }
  const originalSetter = ref2._setter;
  ref2._setter = (newValue) => {
    cb(newValue);
    originalSetter(newValue);
  };
};

// node_modules/vuestic-ui/dist/web-components/src/composables/useComponentUuid.js
var useComponentUuid = () => {
  const vm = getCurrentInstance();
  if (!vm.appContext.app) {
    return vm.uid;
  }
  return vm.uid + vm.appContext.app._uid;
};

// node_modules/vuestic-ui/dist/web-components/src/composables/useForm/consts.js
var FormServiceKey = Symbol("FormService");

// node_modules/vuestic-ui/dist/web-components/src/composables/useForm/useFormChild.js
var useFormChild = (context) => {
  const formContext = inject(FormServiceKey, null);
  if (!formContext) {
    return {
      isFormDirty: ref(false),
      isFormImmediate: ref(false),
      doShowError: ref(true),
      doShowErrorMessages: ref(true),
      doShowLoading: ref(true)
    };
  }
  const uid = useComponentUuid();
  onMounted(() => {
    formContext.registerField(uid, context);
  });
  onBeforeUnmount(() => {
    formContext.unregisterField(uid);
  });
  return {
    isFormDirty: formContext.isFormDirty,
    isFormImmediate: formContext.immediate,
    doShowError: formContext.doShowError,
    doShowErrorMessages: formContext.doShowErrorMessages,
    doShowLoading: formContext.doShowLoading
  };
};

// node_modules/vuestic-ui/dist/web-components/src/composables/useValidation.js
var normalizeValidationRules = (rules = [], callArguments = null) => {
  if (isString$1(rules)) {
    rules = [rules];
  }
  return rules.map((rule) => isFunction$4(rule) ? rule(callArguments) : rule);
};
var useValidationProps = {
  name: { type: String, default: void 0 },
  modelValue: { required: false },
  dirty: { type: Boolean, default: false },
  error: { type: Boolean, default: void 0 },
  errorMessages: { type: [Array, String], default: void 0 },
  errorCount: { type: [String, Number], default: 1 },
  rules: { type: Array, default: () => [] },
  success: { type: Boolean, default: false },
  messages: { type: [Array, String], default: () => [] },
  immediateValidation: { type: Boolean, default: false }
};
var useValidationEmits = ["update:error", "update:errorMessages", "update:dirty"];
var isPromise = (value) => {
  return typeof value === "object" && typeof value.then === "function";
};
var useDirtyValue = (value, props, emit) => {
  const isDirty = ref(false);
  watchSetter(value, () => {
    isDirty.value = true;
    emit("update:dirty", true);
  });
  watch(() => props.dirty, (newValue) => {
    if (isDirty.value === newValue) {
      return;
    }
    isDirty.value = newValue;
  });
  return { isDirty };
};
var useValidation = (props, emit, options) => {
  const { reset, focus } = options;
  const { isFocused, onFocus, onBlur } = useFocus();
  const [computedError] = useSyncProp("error", props, emit, false);
  const [computedErrorMessages] = useSyncProp("errorMessages", props, emit, []);
  const isLoading = ref(false);
  const validationAriaAttributes = computed(() => ({
    "aria-invalid": computedError.value,
    "aria-errormessage": typeof computedErrorMessages.value === "string" ? computedErrorMessages.value : computedErrorMessages.value.join(", ")
  }));
  const resetValidation = () => {
    computedError.value = false;
    computedErrorMessages.value = [];
    isDirty.value = false;
  };
  const processResults = (results) => {
    let error = false;
    let errorMessages = [];
    results.forEach((result) => {
      if (isString$1(result)) {
        errorMessages = [...errorMessages, result];
        error = true;
      } else if (result === false) {
        error = true;
      }
    });
    computedErrorMessages.value = errorMessages;
    computedError.value = error;
    return !error;
  };
  const validateAsync = async () => {
    if (!props.rules || !props.rules.length) {
      return true;
    }
    const results = normalizeValidationRules(flatten$2(props.rules), options.value.value);
    const asyncPromiseResults = results.filter((result) => isPromise(result));
    const syncRules = results.filter((result) => !isPromise(result));
    if (!asyncPromiseResults.length) {
      return processResults(syncRules);
    }
    isLoading.value = true;
    return Promise.all(asyncPromiseResults).then((asyncResults) => {
      isLoading.value = false;
      return processResults([...syncRules, ...asyncResults]);
    });
  };
  const validate = () => {
    if (!props.rules || !props.rules.length) {
      return true;
    }
    const rules = flatten$2(props.rules);
    const results = normalizeValidationRules(rules, options.value.value);
    const asyncPromiseResults = results.filter((result) => isPromise(result));
    const syncRules = results.filter((result) => !isPromise(result));
    const isSyncedError = syncRules.some((result) => isString$1(result) ? result : result === false);
    if (asyncPromiseResults.length && !isSyncedError) {
      isLoading.value = true;
      Promise.all(asyncPromiseResults).then((asyncResults) => {
        processResults([...syncRules, ...asyncResults]);
        isLoading.value = false;
      });
      return isSyncedError;
    }
    return processResults(syncRules);
  };
  watch(isFocused, (newVal) => !newVal && validate());
  const { isDirty } = useDirtyValue(options.value, props, emit);
  const {
    doShowErrorMessages,
    // Renamed to forceHideError because it's not clear what it does
    doShowError,
    doShowLoading,
    isFormImmediate,
    isFormDirty
  } = useFormChild({
    isDirty,
    isValid: computed(() => !computedError.value),
    isLoading,
    errorMessages: computedErrorMessages,
    validate,
    validateAsync,
    resetValidation,
    focus,
    reset: () => {
      reset();
      resetValidation();
      isDirty.value = false;
    },
    value: computed(() => options.value || props.modelValue),
    name: toRef(props, "name")
  });
  const immediateValidation = computed(() => props.immediateValidation || isFormImmediate.value);
  let canValidate = true;
  const withoutValidation = (cb) => {
    canValidate = false;
    cb();
    nextTick(() => {
      canValidate = true;
    });
  };
  watch(options.value, () => {
    if (!canValidate) {
      return;
    }
    return validate();
  }, { immediate: immediateValidation.value });
  return {
    isDirty,
    computedError: computed(() => {
      if (!isFormDirty.value) {
        if (!immediateValidation.value && !isDirty.value) {
          return false;
        }
      }
      return doShowError.value ? computedError.value : false;
    }),
    computedErrorMessages: computed(() => doShowErrorMessages.value ? computedErrorMessages.value : []),
    isLoading: computed(() => doShowLoading.value ? isLoading.value : false),
    listeners: { onFocus, onBlur },
    validate,
    resetValidation,
    withoutValidation,
    validationAriaAttributes
  };
};

// node_modules/vuestic-ui/dist/web-components/src/composables/useSelectable.js
var useSelectableProps = {
  ...useStatefulProps,
  ...useLoadingProps,
  ...useValidationProps,
  arrayValue: { type: [String, Boolean, Object, Number], default: null },
  label: { type: String, default: "" },
  leftLabel: { type: Boolean, default: false },
  trueValue: { type: null, default: true },
  falseValue: { type: null, default: false },
  indeterminate: { type: Boolean, default: false },
  indeterminateValue: { type: null, default: null },
  disabled: { type: Boolean, default: false },
  readonly: { type: Boolean, default: false }
};
var useSelectableEmits = [...useValidationEmits, "update:modelValue", "focus", "blur"];
var checkDuplicates = (props) => {
  const values = [props.falseValue, props.trueValue];
  if (props.indeterminate) {
    values.push(props.indeterminateValue);
  }
  const hasDuplicates = new Set(values).size !== values.length;
  if (hasDuplicates) {
    throw new Error("falseValue, trueValue, indeterminateValue props should have strictly different values, which is not the case.");
  }
};
var useSelectable = (props, emit, { input, label, container }) => {
  checkDuplicates(props);
  const reset = () => withoutValidation(() => {
    emit("update:modelValue", false);
    resetValidation();
  });
  const focus = () => {
    var _a2;
    (_a2 = unwrapEl(input.value)) == null ? void 0 : _a2.focus();
  };
  const { valueComputed } = useStateful(props, emit);
  const {
    computedError,
    computedErrorMessages,
    validate,
    validationAriaAttributes,
    withoutValidation,
    resetValidation
  } = useValidation(props, emit, { reset, focus, value: valueComputed });
  const { isFocused } = useFocus();
  const isElementRelated = (element) => {
    return !!element && [unwrapEl(label.value), unwrapEl(container.value)].includes(element);
  };
  const onBlur = (event) => {
    if (input.value === event.target && !isElementRelated(event.relatedTarget)) {
      isFocused.value = false;
      validate();
      emit("blur", event);
    }
  };
  const onFocus = (event) => {
    isFocused.value = true;
    emit("focus", event);
  };
  const isIndeterminate = computed(() => props.indeterminate && valueComputed.value === props.indeterminateValue);
  const modelIsArray = computed(() => props.arrayValue !== void 0 && props.arrayValue !== null);
  const isChecked = computed(() => {
    var _a2;
    if (modelIsArray.value) {
      return (_a2 = props.modelValue) == null ? void 0 : _a2.includes(props.arrayValue);
    }
    return valueComputed.value === props.trueValue;
  });
  const toggleSelection = () => {
    if (props.readonly || props.disabled || props.loading) {
      return;
    }
    if (modelIsArray.value) {
      if (!props.modelValue) {
        emit("update:modelValue", [props.arrayValue]);
      } else if (!Array.isArray(props.modelValue)) {
        emit("update:modelValue", props.modelValue === props.arrayValue ? [] : [props.modelValue, props.arrayValue]);
      } else if (props.modelValue.includes(props.arrayValue)) {
        emit("update:modelValue", props.modelValue.filter((option) => option !== props.arrayValue));
      } else {
        emit("update:modelValue", props.modelValue.concat(props.arrayValue));
      }
      return;
    }
    if (props.indeterminate) {
      if (isIndeterminate.value) {
        valueComputed.value = props.trueValue;
      } else if (isChecked.value) {
        valueComputed.value = props.falseValue;
      } else {
        valueComputed.value = props.indeterminateValue;
      }
      return;
    }
    if (isChecked.value) {
      valueComputed.value = props.falseValue;
    } else {
      valueComputed.value = props.trueValue;
    }
  };
  return {
    isChecked,
    isIndeterminate,
    onBlur,
    onFocus,
    toggleSelection,
    reset,
    focus,
    computedError,
    computedErrorMessages,
    validationAriaAttributes
  };
};

// node_modules/vuestic-ui/dist/web-components/src/composables/useKeyboardOnlyFocus.js
var _a;
function useKeyboardOnlyFocus() {
  const hasKeyboardFocus = ref(false);
  let previouslyClicked2 = false;
  const keyboardFocusListeners = {
    mousedown: () => {
      previouslyClicked2 = true;
    },
    focus: () => {
      if (!previouslyClicked2) {
        hasKeyboardFocus.value = true;
      }
      previouslyClicked2 = false;
    },
    blur: () => {
      hasKeyboardFocus.value = false;
      previouslyClicked2 = false;
    }
  };
  return {
    hasKeyboardFocus,
    keyboardFocusListeners
  };
}
var previouslyClicked = false;
(_a = getWindow()) == null ? void 0 : _a.addEventListener("mousedown", () => {
  previouslyClicked = true;
  setTimeout(() => {
    previouslyClicked = false;
  }, 300);
});
function useKeyboardOnlyFocusGlobal() {
  const hasKeyboardFocus = ref(false);
  const keyboardFocusListeners = {
    focus: () => {
      if (!previouslyClicked) {
        hasKeyboardFocus.value = true;
      }
    },
    blur: () => {
      hasKeyboardFocus.value = false;
    }
  };
  return {
    hasKeyboardFocus,
    keyboardFocusListeners
  };
}

// node_modules/vuestic-ui/dist/web-components/src/components/va-message-list/hooks/useMessageListAria.js
var useMessageListAria = (props) => {
  const id = useComponentUuid();
  const messageListId = `message-list-${id}`;
  const messageListAttributes = computed(() => ({
    id: messageListId,
    role: "alert"
  }));
  const doHaveMessages = computed(() => {
    if (typeof props.modelValue === "string" && props.modelValue.length > 0) {
      return true;
    }
    if (Array.isArray(props.modelValue) && props.modelValue.length > 0) {
      return true;
    }
    return false;
  });
  const childAttributes = computed(() => ({
    "aria-describedby": doHaveMessages.value ? messageListId : void 0,
    "aria-invalid": props.hasError
  }));
  return {
    messageListAttributes,
    childAttributes
  };
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-message-list/VaMessageList.vue_vue_type_script_setup_true_lang.js
var _hoisted_113 = { class: "va-message-list__list" };
var _sfc_main32 = defineComponent({
  ...{
    name: "VaMessageList",
    inheritAttrs: false
  },
  __name: "VaMessageList",
  props: {
    modelValue: {
      type: [String, Array],
      default: ""
    },
    limit: { type: Number, default: 1 },
    color: { type: String },
    hasError: { type: Boolean, default: false }
  },
  setup(__props, { expose: __expose }) {
    const props = __props;
    const { getColor } = useColors();
    const { childAttributes, messageListAttributes } = useMessageListAria(props);
    const messages = computed(() => {
      if (!props.modelValue) {
        return [];
      }
      if (!Array.isArray(props.modelValue)) {
        return [props.modelValue];
      }
      return props.modelValue.slice(0, props.limit);
    });
    const computedStyle = computed(() => props.color ? { color: getColor(props.color) } : {});
    __expose({
      messages
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock(Fragment, null, [
        renderSlot(_ctx.$slots, "default", normalizeProps(guardReactiveProps({ ariaAttributes: unref(childAttributes), messages: messages.value, attrs: _ctx.$attrs }))),
        renderSlot(_ctx.$slots, "messages", normalizeProps(guardReactiveProps({ ariaAttributes: unref(messageListAttributes), messages: messages.value })), () => [
          messages.value.length > 0 ? (openBlock(), createElementBlock("div", mergeProps({
            key: 0,
            class: "va-message-list",
            style: computedStyle.value
          }, unref(messageListAttributes)), [
            createBaseVNode("ul", _hoisted_113, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(messages.value, (message, index) => {
                return openBlock(), createElementBlock("li", {
                  key: index,
                  class: "va-message-list__message"
                }, [
                  renderSlot(_ctx.$slots, "message", normalizeProps(guardReactiveProps({ messages: messages.value, message })), () => [
                    __props.hasError ? (openBlock(), createBlock(unref(VaIcon), {
                      key: 0,
                      class: "va-message-list__icon",
                      name: "va-warning",
                      size: 16
                    })) : createCommentVNode("", true),
                    createTextVNode(toDisplayString(message), 1)
                  ])
                ]);
              }), 128))
            ])
          ], 16)) : createCommentVNode("", true)
        ])
      ], 64);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-message-list/VaMessageList.js
var _style_029 = ":root,\n:host {\n  --va-message-list-icon-margin-right: 0.25rem;\n  --va-message-list-color: var(--va-secondary);\n  --va-message-list-font-size: 13px;\n  --va-message-list-line-height: 1.2rem;\n  --va-message-wrapper-margin-top: 0.5rem;\n}\n.va-message-list {\n  color: var(--va-message-list-color);\n  list-style: none;\n}\n.va-message-list__message {\n  display: flex;\n  align-items: center;\n  font-size: var(--va-message-list-font-size);\n  line-height: var(--va-message-list-line-height);\n}\n.va-message-list__icon {\n  margin-right: var(--va-message-list-icon-margin-right);\n}";
var _VaMessageList = _export_sfc(_sfc_main32, [["styles", [_style_029]]]);
var VaMessageList = withConfigTransport$1(_VaMessageList);

// node_modules/vuestic-ui/dist/web-components/src/components/va-message-list/VaMessageListWrapper.vue_vue_type_script_setup_true_lang.js
var _hoisted_114 = { class: "va-message-list-wrapper" };
var _sfc_main33 = defineComponent({
  ...{
    name: "VaMessageListWrapper"
  },
  __name: "VaMessageListWrapper",
  props: {
    ...useValidationProps
  },
  setup(__props) {
    const props = __props;
    const messagesColor = computed(() => {
      if (props.error) {
        return "danger";
      }
      if (props.success) {
        return "success";
      }
      return "";
    });
    const hasError = toRef(props, "error");
    const messagesComputed = computed(() => props.error ? props.errorMessages : props.messages);
    const errorLimit = computed(() => props.error ? Number(props.errorCount) : 99);
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_114, [
        createVNode(unref(VaMessageList), {
          color: messagesColor.value,
          limit: errorLimit.value,
          "has-error": hasError.value,
          "model-value": messagesComputed.value,
          "inherit-slots": ["message"]
        }, {
          default: withCtx((bind) => [
            renderSlot(_ctx.$slots, "default", normalizeProps(guardReactiveProps(bind)))
          ]),
          _: 3
        }, 8, ["color", "limit", "has-error", "model-value"])
      ]);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-message-list/VaMessageListWrapper.js
var _style_030 = ":root,\n:host {\n  --va-message-list-icon-margin-right: 0.25rem;\n  --va-message-list-color: var(--va-secondary);\n  --va-message-list-font-size: 13px;\n  --va-message-list-line-height: 1.2rem;\n  --va-message-wrapper-margin-top: 0.5rem;\n}\n.va-message-list-wrapper .va-message-list {\n  margin-top: var(--va-message-wrapper-margin-top);\n}";
var VaMessageListWrapper = _export_sfc(_sfc_main33, [["styles", [_style_030]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-checkbox/VaCheckbox.vue_vue_type_script_setup_true_lang.js
var _hoisted_115 = ["id", "indeterminate", "value", "checked"];
var _hoisted_28 = ["for"];
var VaCheckboxValueType = [Boolean, Array, String, Object];
var _sfc_main34 = defineComponent({
  ...{
    name: "VaCheckbox"
  },
  __name: "VaCheckbox",
  props: {
    ...useSelectableProps,
    ...useComponentPresetProp,
    modelValue: { type: VaCheckboxValueType, default: false },
    color: { type: String, default: "primary" },
    checkedIcon: { type: String, default: "va-check" },
    indeterminate: { type: Boolean, default: false },
    indeterminateValue: { type: VaCheckboxValueType, default: null },
    indeterminateIcon: { type: String, default: "remove" },
    id: { type: String, default: "" },
    name: { type: String, default: "" },
    ariaLabel: { type: String, default: void 0 },
    vertical: { type: Boolean, default: false }
  },
  emits: useSelectableEmits,
  setup(__props, { expose: __expose, emit: __emit }) {
    useCssVars((_ctx) => ({
      "7f9078cd": displayVal.value
    }));
    const props = __props;
    const emit = __emit;
    const elements = {
      container: shallowRef(),
      input: shallowRef(),
      label: shallowRef()
    };
    const {
      isChecked,
      computedError,
      isIndeterminate,
      computedErrorMessages,
      validationAriaAttributes,
      toggleSelection,
      onBlur,
      onFocus
    } = useSelectable(props, emit, elements);
    const { getColor } = useColors();
    const { hasKeyboardFocus, keyboardFocusListeners } = useKeyboardOnlyFocus();
    const { textColorComputed } = useTextColor(computed(() => getColor(props.color)));
    const isActive = computed(() => isChecked.value || isIndeterminate.value);
    const computedClass = computed(() => ({
      "va-checkbox--selected": isChecked.value,
      "va-checkbox--readonly": props.readonly,
      "va-checkbox--disabled": props.disabled,
      "va-checkbox--indeterminate": props.indeterminate,
      "va-checkbox--error": computedError.value,
      "va-checkbox--left-label": props.leftLabel,
      "va-checkbox--on-keyboard-focus": hasKeyboardFocus.value
    }));
    const getPaddingStyle = () => {
      switch (true) {
        case !props.label:
          return "";
        case props.vertical:
          return "var(--va-checkbox-vertical-padding)";
        case Boolean(props.arrayValue):
          return "var(--va-checkbox-horizontal-padding)";
        case props.leftLabel:
          return "var(--va-checkbox-right-padding)";
        default:
          return "var(--va-checkbox-left-padding)";
      }
    };
    const labelStyle = computed(() => {
      return {
        color: computedError.value ? getColor("danger") : props.success ? getColor("success") : "",
        padding: getPaddingStyle()
      };
    });
    const inputStyle = computed(() => {
      const style = {
        background: isActive.value ? getColor(props.color) : "",
        borderColor: isActive.value ? getColor(props.color) : ""
      };
      if (computedError.value) {
        style.borderColor = getColor("danger");
      }
      if (props.success) {
        style.borderColor = getColor("success");
      }
      return style;
    });
    const computedIconName = computed(
      () => props.indeterminate && isIndeterminate.value ? props.indeterminateIcon : props.checkedIcon
    );
    const uniqueId2 = computed(generateUniqueId);
    const computedId = computed(() => props.id || uniqueId2.value);
    const computedName = computed(() => props.name || uniqueId2.value);
    const inputAttributesComputed = computed(() => ({
      name: computedName.value,
      disabled: props.disabled,
      readonly: props.readonly,
      tabindex: props.disabled ? -1 : 0,
      "aria-label": props.ariaLabel,
      "aria-disabled": props.disabled,
      "aria-readOnly": props.readonly,
      "aria-checked": isActive.value,
      ...validationAriaAttributes.value
    }));
    const displayVal = computed(() => props.vertical ? "--va-checkbox-display-flex" : "var(--va-checkbox-display)");
    __expose({
      toggleSelection
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(VaMessageListWrapper), {
        class: normalizeClass(["va-checkbox", computedClass.value]),
        disabled: _ctx.disabled,
        success: _ctx.success,
        messages: _ctx.messages,
        error: unref(computedError),
        "error-messages": unref(computedErrorMessages),
        "error-count": _ctx.errorCount
      }, {
        default: withCtx(() => [
          createBaseVNode("div", {
            ref: "container",
            class: "va-checkbox__input-container",
            onClick: _cache[6] || (_cache[6] = //@ts-ignore
            (...args) => unref(toggleSelection) && unref(toggleSelection)(...args)),
            onBlur: _cache[7] || (_cache[7] = //@ts-ignore
            (...args) => unref(onBlur) && unref(onBlur)(...args))
          }, [
            createBaseVNode("div", {
              class: "va-checkbox__square",
              style: normalizeStyle(inputStyle.value),
              onSelectstart: _cache[4] || (_cache[4] = withModifiers(() => {
              }, ["prevent"]))
            }, [
              createBaseVNode("input", mergeProps({
                ref: "input",
                type: "checkbox",
                class: "va-checkbox__input",
                id: computedId.value,
                indeterminate: __props.indeterminate,
                value: _ctx.label,
                checked: isActive.value
              }, inputAttributesComputed.value, toHandlers(unref(keyboardFocusListeners), true), {
                onFocus: _cache[0] || (_cache[0] = //@ts-ignore
                (...args) => unref(onFocus) && unref(onFocus)(...args)),
                onBlur: _cache[1] || (_cache[1] = //@ts-ignore
                (...args) => unref(onBlur) && unref(onBlur)(...args)),
                onClick: _cache[2] || (_cache[2] = withModifiers(() => {
                }, ["stop", "prevent"])),
                onKeypress: _cache[3] || (_cache[3] = withModifiers(
                  //@ts-ignore
                  (...args) => unref(toggleSelection) && unref(toggleSelection)(...args),
                  ["prevent"]
                ))
              }), null, 16, _hoisted_115),
              withDirectives(createVNode(unref(VaIcon), {
                class: "va-checkbox__icon",
                name: computedIconName.value,
                color: unref(textColorComputed)
              }, null, 8, ["name", "color"]), [
                [vShow, isActive.value]
              ])
            ], 36),
            _ctx.label || _ctx.$slots.label ? (openBlock(), createElementBlock("label", {
              key: 0,
              ref: "label",
              class: "va-checkbox__label",
              for: computedId.value,
              style: normalizeStyle(labelStyle.value),
              onBlur: _cache[5] || (_cache[5] = //@ts-ignore
              (...args) => unref(onBlur) && unref(onBlur)(...args))
            }, [
              renderSlot(_ctx.$slots, "label", {}, () => [
                createTextVNode(toDisplayString(_ctx.label), 1)
              ])
            ], 44, _hoisted_28)) : createCommentVNode("", true)
          ], 544)
        ]),
        _: 3
      }, 8, ["class", "disabled", "success", "messages", "error", "error-messages", "error-count"]);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-checkbox/VaCheckbox.js
var _style_031 = ":root,\n:host {\n  --va-checkbox-display: inline-block;\n  --va-checkbox-input-padding: 0;\n  --va-checkbox-input-cursor: pointer;\n  --va-checkbox-disabled-cursor: default;\n  --va-checkbox-readonly-cursor: initial;\n  --va-checkbox-label-display: inline-block;\n  --va-checkbox-label-cursor: pointer;\n  --va-checkbox-font-size: 15px;\n  --va-checkbox-line-height: 20px;\n  --va-checkbox-background: transparent;\n  /* Square */\n  --va-checkbox-square-width: 1.25rem;\n  --va-checkbox-square-min-width: 1.25rem;\n  --va-checkbox-square-height: 1.25rem;\n  --va-checkbox-square-border: solid var(--va-form-element-border-width) var(--va-background-border);\n  --va-checkbox-square-border-radius: calc(var(--va-form-element-border-radius) / 2);\n  /* Padding */\n  --va-checkbox-horizontal-gap: 0.5em;\n  --va-checkbox-vertical-gap: 0.3em;\n  --va-checkbox-vertical-padding: var(--va-checkbox-vertical-gap) 0 var(--va-checkbox-vertical-gap) var(--va-checkbox-horizontal-gap);\n  --va-checkbox-horizontal-padding: 0 var(--va-checkbox-horizontal-gap);\n  --va-checkbox-right-padding: 0 var(--va-checkbox-horizontal-gap) 0 0;\n  --va-checkbox-left-padding: 0 0 0 var(--va-checkbox-horizontal-gap);\n}\n.va-checkbox {\n  display: var(--7f9078cd);\n  max-width: -moz-fit-content;\n  max-width: fit-content;\n  font-family: var(--va-font-family);\n}\n.va-checkbox__input-container {\n  align-items: center;\n  display: flex;\n  padding: var(--va-checkbox-input-padding);\n  cursor: var(--va-checkbox-input-cursor);\n  font-size: var(--va-checkbox-font-size);\n  line-height: var(--va-checkbox-line-height);\n}\n.va-checkbox--disabled .va-checkbox__input-container {\n  cursor: default;\n  opacity: 0.4;\n  pointer-events: none;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n          user-select: none;\n  cursor: var(--va-checkbox-disabled-cursor);\n}\n.va-checkbox--readonly .va-checkbox__input-container {\n  cursor: var(--va-checkbox-readonly-cursor);\n}\n.va-checkbox--left-label .va-checkbox__input-container {\n  flex-direction: row-reverse;\n}\n.va-checkbox .va-checkbox__square {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  width: var(--va-checkbox-square-width);\n  min-width: var(--va-checkbox-square-min-width);\n  height: var(--va-checkbox-square-height);\n  position: relative;\n  background: var(--va-checkbox-background, --va-checkbox-square-background-color);\n  border: var(--va-checkbox-square-border, var(--va-control-border));\n  border-radius: var(--va-checkbox-square-border-radius);\n}\n.va-checkbox--on-keyboard-focus.va-checkbox .va-checkbox__square {\n  transition: all, 0.6s, ease-in;\n  outline: 2px solid var(--va-focus);\n}\n.va-checkbox__input {\n  position: absolute;\n  width: 1px;\n  height: 1px;\n  margin: -1px;\n  border: 0;\n  padding: 0;\n  white-space: nowrap;\n  -webkit-clip-path: inset(100%);\n          clip-path: inset(100%);\n  clip: rect(0 0 0 0);\n  overflow: hidden;\n}\n.va-checkbox__label {\n  display: var(--va-checkbox-label-display);\n  position: relative;\n  cursor: var(--va-checkbox-label-cursor);\n}\n.va-checkbox__icon {\n  pointer-events: none;\n  position: absolute;\n}\n.va-checkbox--selected .va-checkbox__icon {\n  color: var(--va-checkbox-selected-icon-color);\n}\n.va-checkbox--indeterminate .va-checkbox__icon {\n  color: var(--va-checkbox-indeterminate-icon-color);\n}";
var _VaCheckbox = _export_sfc(_sfc_main34, [["styles", [_style_031]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-checkbox/index.js
var VaCheckbox = withConfigTransport$1(_VaCheckbox);

// node_modules/vuestic-ui/dist/web-components/src/components/va-chip/VaChip.vue_vue_type_script_setup_true_lang.js
var _hoisted_116 = { class: "va-chip__content" };
var _sfc_main35 = defineComponent({
  ...{
    name: "VaChip"
  },
  __name: "VaChip",
  props: {
    ...useRouterLinkProps,
    ...useColorProps,
    ...useStatefulProps,
    ...useComponentPresetProp,
    modelValue: { type: Boolean, default: true },
    closeable: { type: Boolean, default: false },
    outline: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false },
    readonly: { type: Boolean, default: false },
    square: { type: Boolean, default: false },
    shadow: { type: Boolean, default: false },
    flat: { type: Boolean, default: false },
    icon: { type: String, default: "" },
    tag: { type: String, default: "span" },
    size: {
      type: String,
      default: "medium",
      validator: (value) => ["small", "medium", "large"].includes(value)
    },
    ariaCloseLabel: { type: String, default: "$t:close" }
  },
  emits: [...useStatefulEmits, "focus"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const { getColor } = useColors();
    const colorComputed = computed(() => getColor(props.color));
    const borderColor = computed(() => props.outline ? colorComputed.value : "");
    const isTransparentBackground = computed(() => Boolean(props.outline || props.flat));
    const { textColorComputed } = useTextColor(colorComputed, isTransparentBackground);
    const { hasKeyboardFocus, keyboardFocusListeners } = useKeyboardOnlyFocus();
    const shadowStyle = computed(() => {
      if (!props.shadow || props.flat || props.outline || props.disabled || hasKeyboardFocus.value) {
        return;
      }
      return `0 0.125rem 0.19rem 0 ${getBoxShadowColor(colorComputed.value)}`;
    });
    const { valueComputed } = useStateful(props, emit);
    const { tagComputed, hrefComputed } = useRouterLink(props);
    const { isHovered, onMouseEnter, onMouseLeave } = useHover();
    const close = () => {
      if (!props.disabled) {
        valueComputed.value = false;
      }
    };
    const iconSize = computed(() => props.size);
    const tabIndexComputed = computed(() => props.disabled ? -1 : 0);
    const computedClass = useBem("va-chip", () => ({
      ...pick$1(props, ["disabled", "readonly", "square"]),
      small: props.size === "small",
      large: props.size === "large"
    }));
    const computedStyle = computed(() => {
      const result = {
        color: textColorComputed.value,
        borderColor: borderColor.value,
        background: "",
        boxShadow: shadowStyle.value
      };
      if (props.outline || props.flat) {
        if (hasKeyboardFocus.value) {
          result.background = getFocusColor(colorComputed.value);
        } else if (!props.readonly && isHovered.value) {
          result.background = getHoverColor(colorComputed.value);
        }
      } else {
        result.background = colorComputed.value;
      }
      return result;
    });
    const { tp } = useTranslation();
    __expose({
      close
    });
    return (_ctx, _cache) => {
      return unref(valueComputed) ? (openBlock(), createBlock(resolveDynamicComponent(unref(tagComputed)), {
        key: 0,
        class: normalizeClass(["va-chip", unref(computedClass)]),
        href: unref(hrefComputed),
        target: _ctx.target,
        to: _ctx.to,
        replace: _ctx.replace,
        exact: _ctx.exact,
        "active-class": _ctx.activeClass,
        "exact-active-class": _ctx.exactActiveClass,
        style: normalizeStyle(computedStyle.value)
      }, {
        default: withCtx(() => [
          createBaseVNode("span", mergeProps({
            class: "va-chip__inner",
            onFocus: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("focus")),
            onMouseenter: _cache[1] || (_cache[1] = //@ts-ignore
            (...args) => unref(onMouseEnter) && unref(onMouseEnter)(...args)),
            onMouseleave: _cache[2] || (_cache[2] = //@ts-ignore
            (...args) => unref(onMouseLeave) && unref(onMouseLeave)(...args))
          }, toHandlers(unref(keyboardFocusListeners), true)), [
            __props.icon ? (openBlock(), createBlock(unref(VaIcon), {
              key: 0,
              class: "va-chip__icon",
              name: __props.icon,
              size: iconSize.value
            }, null, 8, ["name", "size"])) : createCommentVNode("", true),
            createBaseVNode("span", _hoisted_116, [
              renderSlot(_ctx.$slots, "default")
            ]),
            __props.closeable ? (openBlock(), createBlock(unref(VaIcon), {
              key: 1,
              role: "button",
              name: "va-close",
              class: "va-chip__close-icon",
              "aria-label": unref(tp)(_ctx.$props.ariaCloseLabel),
              tabindex: tabIndexComputed.value,
              size: iconSize.value,
              onClick: withModifiers(close, ["stop"]),
              onKeydown: [
                withKeys(withModifiers(close, ["stop"]), ["enter"]),
                withKeys(withModifiers(close, ["stop"]), ["space"])
              ]
            }, null, 8, ["aria-label", "tabindex", "size", "onKeydown"])) : createCommentVNode("", true)
          ], 16)
        ]),
        _: 3
      }, 8, ["href", "target", "to", "replace", "exact", "active-class", "exact-active-class", "class", "style"])) : createCommentVNode("", true);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-chip/VaChip.js
var _style_032 = ":root,\n:host {\n  --va-chip-display: inline-flex;\n  --va-chip-border: 0.125rem solid transparent;\n  --va-chip-position: relative;\n  --va-chip-border-radius: 2rem;\n  --va-chip-width: auto;\n  --va-chip-height: auto;\n  --va-chip-min-width: initial;\n  --va-chip-min-height: initial;\n  --va-chip-padding: 0 0.375rem;\n  --va-chip-color: #ffffff;\n  --va-chip-cursor: default;\n  --va-chip-font-size: 1rem;\n  --va-chip-vertical-align: middle;\n  --va-chip-inner-display: inline-flex;\n  --va-chip-inner-align-items: center;\n  --va-chip-inner-width: 100%;\n  --va-chip-hover-opacity: 0.85;\n  --va-chip-content-display: flex;\n  --va-chip-content-width: var(--va-chip-inner-width, 100%);\n  --va-chip-content-align-items: center;\n  --va-chip-content-justify-content: center;\n  --va-chip-content-padding: 0 var(--va-gap-medium, 0.5rem);\n  --va-chip-content-line-height: 1.6;\n  /* Square */\n  --va-chip-square-border-radius: 0.2rem;\n  /* Small */\n  --va-chip-sm-height: 1.5rem;\n  --va-chip-sm-font-size: 0.875rem;\n  --va-chip-sm-content-padding: 0 var(--va-gap-small, 0.5rem);\n  /* Large */\n  --va-chip-lg-height: 2.5rem;\n  --va-chip-lg-font-size: 1.25rem;\n  --va-chip-lg-content-padding: 0 var(--va-gap-large, 0.5rem);\n}\n.va-chip {\n  display: var(--va-chip-display);\n  border: var(--va-chip-border, var(--va-control-border));\n  position: var(--va-chip-position);\n  border-radius: var(--va-chip-border-radius);\n  width: var(--va-chip-width);\n  height: var(--va-chip-height);\n  min-width: var(--va-chip-min-width);\n  min-height: var(--va-chip-min-height);\n  padding: var(--va-chip-padding);\n  color: var(--va-chip-color);\n  cursor: var(--va-chip-cursor);\n  font-size: var(--va-chip-font-size);\n  font-family: var(--va-font-family);\n  vertical-align: var(--va-chip-vertical-align);\n}\n.va-chip__inner {\n  display: var(--va-chip-inner-display);\n  align-items: var(--va-chip-inner-align-items);\n  width: var(--va-chip-inner-width);\n  vertical-align: inherit;\n}\n.va-chip:hover:not(.va-chip--readonly) {\n  opacity: var(--va-chip-hover-opacity);\n}\n.va-chip__content {\n  display: var(--va-chip-content-display);\n  justify-content: var(--va-chip-content-justify-content);\n  align-items: var(--va-chip-content-align-items);\n  padding: var(--va-chip-content-padding);\n  line-height: var(--va-chip-content-line-height);\n  width: var(--va-chip-content-width);\n}\n.va-chip__close-icon {\n  cursor: pointer;\n}\n.va-chip--disabled .va-chip__close-icon {\n  cursor: default !important;\n}\n.va-chip--square {\n  border-radius: var(--va-chip-square-border-radius, var(--va-square-border-radius));\n}\n.va-chip--small {\n  height: var(--va-chip-sm-height);\n  font-size: var(--va-chip-sm-font-size);\n}\n.va-chip--small .va-chip__content {\n  padding: var(--va-chip-sm-content-padding);\n}\n.va-chip--large {\n  height: var(--va-chip-lg-height);\n  font-size: var(--va-chip-lg-font-size);\n}\n.va-chip--large .va-chip__content {\n  padding: var(--va-chip-lg-content-padding);\n}\n.va-chip.va-chip--disabled {\n  cursor: default;\n  opacity: 0.4;\n  pointer-events: none;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n          user-select: none;\n}";
var _VaChip = _export_sfc(_sfc_main35, [["styles", [_style_032]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-chip/index.js
var VaChip = withConfigTransport$1(_VaChip);

// node_modules/vuestic-ui/dist/web-components/src/composables/useResizeObserver.js
var useResizeObserver = (elementsList, cb) => {
  let resizeObserver;
  const observeAll = (elementsList2) => {
    elementsList2.forEach((element) => {
      const unrefedElement = unref(element);
      unrefedElement && (resizeObserver == null ? void 0 : resizeObserver.observe(unrefedElement));
    });
  };
  watch(elementsList, (newValue) => {
    resizeObserver == null ? void 0 : resizeObserver.disconnect();
    observeAll(newValue);
  });
  onMounted(() => {
    resizeObserver = new ResizeObserver(cb);
    observeAll(elementsList);
  });
  onBeforeUnmount(() => resizeObserver == null ? void 0 : resizeObserver.disconnect());
  return resizeObserver;
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-collapse/VaCollapse.vue_vue_type_script_setup_true_lang.js
var _hoisted_117 = { class: "va-collapse__header__text" };
var _hoisted_29 = ["id", "aria-labelledby"];
var _hoisted_35 = { class: "va-collapse__content" };
var _sfc_main36 = defineComponent({
  ...{
    name: "VaCollapse"
  },
  __name: "VaCollapse",
  props: {
    ...useComponentPresetProp,
    ...useStatefulProps,
    modelValue: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false },
    header: { type: String, default: "" },
    icon: { type: String, default: "" },
    color: { type: String, default: void 0 },
    bodyColor: { type: String, default: void 0 },
    textColor: { type: String, default: "" },
    bodyTextColor: { type: String, default: "" },
    iconColor: { type: String, default: "secondary" },
    colorAll: { type: Boolean, default: false },
    stateful: { type: Boolean, default: true }
  },
  emits: ["update:modelValue", ...useSelectableEmits],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const body = shallowRef();
    const { valueComputed } = useStateful(props, emit, "modelValue");
    const { getColor, getTextColor, setHSLAColor: setHSLAColor2 } = useColors();
    const { accordionProps, accordionItemValue } = useAccordionItem();
    const computedModelValue = computed({
      get() {
        if (valueComputed.userProvided) {
          return valueComputed.value;
        }
        if (!isNil$1(accordionItemValue)) {
          return accordionItemValue.value;
        }
        return valueComputed.value;
      },
      set(v) {
        if (!isNil$1(accordionItemValue)) {
          accordionItemValue.value = v;
        }
        valueComputed.value = v;
      }
    });
    if (valueComputed.userProvided && !isNil$1(accordionItemValue)) {
      accordionItemValue.value = valueComputed.value;
    }
    const bodyHeight = ref();
    useResizeObserver([body], ([body2]) => {
      bodyHeight.value = body2.contentRect.height ?? 0;
    });
    const height = computed(() => computedModelValue.value ? bodyHeight.value : 0);
    const getTransition = () => {
      const duration = height.value / 1e3 * 0.2;
      return `${duration > 0.2 ? duration : 0.2}s`;
    };
    const contentBackground = computed(() => {
      if (props.bodyColor) {
        return getColor(props.bodyColor);
      }
      return props.color && props.colorAll ? setHSLAColor2(getColor(props.color), { a: 0.07 }) : void 0;
    });
    const headerBackground = computed(() => {
      return props.color ? getColor(props.color) : void 0;
    });
    const uniqueId2 = computed(generateUniqueId);
    const headerIdComputed = computed(() => `header-${uniqueId2.value}`);
    const panelIdComputed = computed(() => `panel-${uniqueId2.value}`);
    const tabIndexComputed = computed(() => props.disabled ? -1 : 0);
    const headerAttributes = computed(() => ({
      id: headerIdComputed.value,
      tabindex: tabIndexComputed.value,
      "aria-controls": panelIdComputed.value,
      "aria-expanded": computedModelValue.value,
      "aria-disabled": props.disabled,
      role: "button"
    }));
    const isHeightChanging = ref(false);
    watch(height, (newValue, oldValue) => {
      if (oldValue === void 0) {
        return;
      }
      if (isHeightChanging.value === true) {
        return;
      }
      isHeightChanging.value = true;
    });
    const onTransitionEnd = (e) => {
      if (e.propertyName === "height" && e.target === e.currentTarget) {
        isHeightChanging.value = false;
      }
    };
    const computedClasses = useBem("va-collapse", () => ({
      ...pick$1(props, ["disabled"]),
      expanded: computedModelValue.value,
      active: computedModelValue.value,
      popout: !!(accordionProps.value.popout && computedModelValue.value),
      inset: !!(accordionProps.value.inset && computedModelValue.value),
      "height-changing": isHeightChanging.value,
      "colored-body": Boolean(contentBackground.value),
      "colored-header": Boolean(headerBackground.value)
    }));
    const toggle = () => {
      if (props.disabled) {
        return;
      }
      computedModelValue.value = !computedModelValue.value;
    };
    const { textColorComputed } = useTextColor(headerBackground);
    const headerStyle = computed(() => ({
      color: textColorComputed.value,
      backgroundColor: headerBackground.value
    }));
    const doRenderBody = computed(() => {
      if (computedModelValue.value) {
        return true;
      }
      if (isHeightChanging.value) {
        return true;
      }
      return false;
    });
    const contentStyle = computed(() => {
      return {
        height: `${height.value}px`,
        transitionDuration: getTransition(),
        background: computedModelValue.value ? contentBackground.value : "",
        color: props.bodyTextColor ? getColor(props.bodyTextColor) : contentBackground.value ? getColor(getTextColor(contentBackground.value)) : "currentColor"
      };
    });
    __expose({
      toggle
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["va-collapse", unref(computedClasses)])
      }, [
        createBaseVNode("div", {
          class: "va-collapse__header-wrapper",
          onClick: toggle,
          onKeydown: [
            withKeys(toggle, ["enter"]),
            withKeys(toggle, ["space"])
          ]
        }, [
          renderSlot(_ctx.$slots, "header", normalizeProps(guardReactiveProps({
            value: computedModelValue.value,
            bind: headerAttributes.value,
            attributes: headerAttributes.value,
            attrs: headerAttributes.value,
            iconAttrs: {
              class: [
                "va-collapse__expand-icon",
                computedModelValue.value ? "a-collapse__expand-icon--expanded" : "a-collapse__expand-icon--collapsed"
              ]
            },
            text: __props.header
          })), () => [
            createBaseVNode("div", mergeProps(headerAttributes.value, {
              class: "va-collapse__header",
              style: headerStyle.value
            }), [
              __props.icon ? (openBlock(), createBlock(unref(VaIcon), {
                key: 0,
                class: "va-collapse__header__icon",
                name: __props.icon
              }, null, 8, ["name"])) : createCommentVNode("", true),
              renderSlot(_ctx.$slots, "header-content", normalizeProps(guardReactiveProps({ header: __props.header })), () => [
                createBaseVNode("div", _hoisted_117, toDisplayString(__props.header), 1)
              ]),
              renderSlot(_ctx.$slots, "expand-icon", {}, () => [
                createVNode(unref(VaIcon), {
                  class: normalizeClass(["va-collapse__expand-icon", computedModelValue.value ? "va-collapse__expand-icon--expanded" : "va-collapse__expand-icon--collapsed"]),
                  name: "va-arrow-down"
                }, null, 8, ["class"])
              ])
            ], 16)
          ])
        ], 32),
        createBaseVNode("div", {
          class: normalizeClass(["va-collapse__body-wrapper", {
            "va-collapse__body-wrapper--bordered": !_ctx.$slots.body && !_ctx.$slots.header
          }]),
          style: normalizeStyle(contentStyle.value),
          onTransitionend: onTransitionEnd
        }, [
          doRenderBody.value ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: "va-collapse__body",
            ref_key: "body",
            ref: body,
            role: "region",
            id: panelIdComputed.value,
            "aria-labelledby": headerIdComputed.value
          }, [
            renderSlot(_ctx.$slots, "body", {}, () => [
              createBaseVNode("div", _hoisted_35, [
                renderSlot(_ctx.$slots, "default", {}, () => [
                  renderSlot(_ctx.$slots, "content")
                ])
              ])
            ])
          ], 8, _hoisted_29)) : createCommentVNode("", true)
        ], 38)
      ], 2);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-collapse/VaCollapse.js
var _style_033 = ":root,\n:host {\n  --va-collapse-padding: 0.75rem;\n  --va-collapse-gap: 0.5rem;\n  --va-collapse-transition: all 0.3s linear;\n  --va-collapse-popout-margin: 0.5rem -0.5rem;\n  --va-collapse-inset-margin: 0.5rem 0.5rem;\n  --va-collapse-body-transition: opacity 0.1s linear;\n  --va-collapse-body-wrapper-transition: height 0.3s linear, background 0.3s linear;\n  --va-collapse-body-width: 100%;\n  --va-collapse-header-content-cursor: pointer;\n  --va-collapse-header-content-background-color: #f5f8f9;\n  --va-collapse-header-content-box-shadow: var(--va-box-shadow);\n  --va-collapse-header-content-border-radius: 0.375rem;\n  --va-collapse-header-content-padding-top: 0.75rem;\n  --va-collapse-header-content-padding-bottom: 0.75rem;\n  --va-collapse-header-content-padding-left: 1rem;\n  --va-collapse-header-content-text-font-weight: 600;\n  --va-collapse-header-content-icon-min-width: 1.5rem;\n  --va-collapse-header-content-icon-margin-left: 0.5rem;\n  --va-collapse-header-content-icon-margin-right: 0.5rem;\n  --va-collapse-header-content-icon-color: var(--va-background-element);\n  --va-collapse-expand-icon-transition: transform 0.3s linear;\n  /* Solid */\n  --va-collapse-solid-box-shadow: var(--va-box-shadow);\n  --va-collapse-solid-border-radius: 0.375rem;\n  --va-collapse-solid-header-content-background-color: #f5f8f9;\n  --va-collapse-solid-header-content-box-shadow: none;\n  --va-collapse-solid-header-content-border-radius: 0.375rem;\n  --va-collapse-solid-header-content-transition: background-color ease-in 0.3s;\n  --va-collapse-solid-body-border-radius: 0 0 0.375rem 0.375rem;\n  --va-collapse-solid-body-margin-top: 0;\n}\n.va-collapse {\n  transition: var(--va-collapse-transition, var(--va-swing-transition));\n  font-family: var(--va-font-family);\n  display: flex;\n  flex-direction: column;\n}\n.va-collapse__body-wrapper {\n  transition: var(--va-collapse-body-wrapper-transition);\n  overflow: auto;\n}\n.va-collapse__body-wrapper--bordered {\n  border-bottom: 1px solid var(--va-background-border);\n  box-sizing: content-box;\n}\n.va-collapse--colored-header:not(.va-collapse--expanded) .va-collapse__body-wrapper--bordered {\n  border-bottom: none;\n}\n.va-collapse--colored-body.va-collapse--expanded .va-collapse__body-wrapper--bordered {\n  border-bottom: none;\n}\n.va-collapse__body {\n  top: 0;\n  left: 0;\n  width: var(--va-collapse-body-width);\n  transition: var(--va-collapse-body-transition);\n  opacity: 0;\n}\n.va-collapse__content {\n  padding: var(--va-collapse-padding);\n  padding-top: calc(var(--va-collapse-padding) / 1.5);\n  box-sizing: border-box;\n}\n.va-collapse__content:empty {\n  padding: 0;\n}\n.va-collapse__header {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  gap: var(--va-collapse-gap);\n  cursor: var(--va-collapse-header-content-cursor);\n  padding: var(--va-collapse-padding);\n  transition: all 0.2s ease-in-out;\n}\n.va-collapse__header__text {\n  width: 100%;\n  font-weight: var(--va-collapse-header-content-text-font-weight);\n}\n.va-collapse__header:focus-visible {\n  outline: 2px solid var(--va-focus) !important;\n  border-radius: var(--va-collapse-header-content-border-radius);\n}\n.va-collapse--expanded .va-collapse__body {\n  opacity: 1;\n}\n.va-collapse__expand-icon {\n  transition: var(--va-collapse-expand-icon-transition);\n}\n.va-collapse__expand-icon--expanded {\n  transform: rotate(180deg);\n}\n.va-collapse--popout {\n  margin: var(--va-collapse-popout-margin);\n}\n.va-collapse--inset {\n  margin: var(--va-collapse-inset-margin);\n}\n.va-collapse--disabled {\n  cursor: default;\n  opacity: 0.4;\n  pointer-events: none;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n          user-select: none;\n}\n.va-collapse--height-changing .va-collapse__body-wrapper {\n  overflow: hidden;\n}";
var _VaCollapse = _export_sfc(_sfc_main36, [["styles", [_style_033]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-collapse/index.js
var VaCollapse = withConfigTransport$1(_VaCollapse);

// node_modules/vuestic-ui/dist/web-components/src/components/va-color-indicator/VaColorIndicator.vue_vue_type_script_setup_true_lang.js
var _sfc_main37 = defineComponent({
  ...{
    name: "VaColorIndicator"
  },
  __name: "VaColorIndicator",
  props: {
    ...useStatefulProps,
    ...useComponentPresetProp,
    modelValue: { type: Boolean, default: null },
    color: { type: String, default: "" },
    square: { type: Boolean, default: false },
    size: { type: String, default: "1rem" }
  },
  emits: [...useStatefulEmits],
  setup(__props, { emit: __emit }) {
    useCssVars((_ctx) => ({
      "1fba77fa": borderRadiusComputed.value
    }));
    const props = __props;
    const emit = __emit;
    const { valueComputed } = useStateful(props, emit);
    const { getColor } = useColors();
    const { hasKeyboardFocus, keyboardFocusListeners } = useKeyboardOnlyFocus();
    const colorComputed = computed(() => getColor(props.color));
    const borderRadiusComputed = computed(() => props.square ? "0px" : "50%");
    const computedStyle = computed(() => ({
      backgroundColor: colorComputed.value,
      height: props.size,
      width: props.size
    }));
    const computedClass = computed(() => ({
      "va-color-indicator--selected": valueComputed.value,
      "va-color-indicator--on-keyboard-focus": hasKeyboardFocus.value
    }));
    const toggleModelValue = () => {
      valueComputed.value = !valueComputed.value;
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", mergeProps({
        class: ["va-color-indicator", computedClass.value],
        style: computedStyle.value,
        onClick: toggleModelValue,
        onKeydown: [
          withKeys(toggleModelValue, ["enter"]),
          withKeys(toggleModelValue, ["space"])
        ]
      }, toHandlers(unref(keyboardFocusListeners), true)), [
        createBaseVNode("div", {
          class: "va-color-indicator__core",
          style: normalizeStyle(computedStyle.value)
        }, null, 4)
      ], 16);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-color-indicator/VaColorIndicator.js
var _style_034 = ".va-color-indicator {\n  display: inline-flex;\n  justify-content: center;\n  align-items: center;\n  cursor: pointer;\n  border-radius: var(--1fba77fa);\n  text-align: center;\n  background-color: var(--va-background-element);\n  border: 0.125rem solid var(--va-background-border);\n  box-sizing: border-box;\n  overflow: hidden;\n}\n.va-color-indicator__core {\n  border-radius: var(--1fba77fa);\n}\n.va-color-indicator--selected {\n  background-color: var(--va-primary);\n  border-color: var(--va-primary);\n}\n.va-color-indicator--on-keyboard-focus {\n  outline: 2px solid var(--va-focus) !important;\n  border-radius: var(--1fba77fa);\n}";
var _VaColorIndicatort = _export_sfc(_sfc_main37, [["styles", [_style_034]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-color-indicator/index.js
var VaColorIndicator = withConfigTransport$1(_VaColorIndicatort);

// node_modules/vuestic-ui/dist/web-components/src/components/va-input/hooks/useCleave.js
var DEFAULT_MASK_TOKENS = {
  creditCard: {
    creditCard: true
  },
  date: {
    date: true,
    datePattern: ["d", "m", "Y"]
  },
  time: {
    time: true,
    timePattern: ["h", "m"],
    timeFormat: "24"
  },
  numeral: {
    numeral: true,
    numeralThousandsGroupStyle: "thousand"
  }
};
var useCleaveProps = {
  mask: { type: [String, Object], default: "" },
  returnRaw: { type: Boolean, default: true }
};
var useCleave = (element, props, syncValue) => {
  const cleave = ref();
  const getMask = (mask2) => {
    if (typeof mask2 === "string") {
      return DEFAULT_MASK_TOKENS[mask2] ? { ...DEFAULT_MASK_TOKENS[mask2] } : null;
    }
    return { ...mask2 };
  };
  const destroyCleave = () => {
    if (cleave.value) {
      cleave.value.destroy();
    }
  };
  const mask = computed(() => getMask(props.mask));
  const cleaveEnabled = computed(() => {
    return mask.value && Object.keys(mask.value).length;
  });
  watchEffect(() => {
    destroyCleave();
    if (!element.value) {
      return;
    }
    if (!cleaveEnabled.value || !mask.value) {
      return;
    }
    cleave.value = new cleave_esm_default(element.value, mask.value);
    cleave.value.properties.onValueChanged = ({ target: { rawValue, value } }) => {
      if (props.returnRaw) {
        syncValue.value = rawValue;
      } else {
        syncValue.value = value;
      }
    };
  });
  onBeforeUnmount(() => {
    destroyCleave();
  });
  const computedValue = computed(() => {
    if (cleave.value) {
      if (props.returnRaw && syncValue.value === cleave.value.getRawValue()) {
        return cleave.value.getFormattedValue();
      }
    }
    return syncValue.value;
  });
  const onInput = (event) => {
    const value = event.target.value;
    if (!cleaveEnabled.value) {
      syncValue.value = value;
    }
  };
  return {
    cleave,
    cleaveEnabled,
    computedValue,
    onInput
  };
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-input-wrapper/components/VaInputLabel.vue_vue_type_script_setup_true_lang.js
var _hoisted_118 = {
  key: 0,
  class: "va-input-label__required-mark"
};
var _sfc_main38 = defineComponent({
  ...{
    name: "VaInputLabel"
  },
  __name: "VaInputLabel",
  props: {
    label: {
      type: String,
      default: ""
    },
    requiredMark: {
      type: Boolean,
      default: false
    },
    color: {
      type: String,
      default: "primary"
    }
  },
  setup(__props) {
    const { getColor } = useColors();
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("label", {
        "aria-hidden": "true",
        class: "va-input-label",
        style: normalizeStyle({ color: unref(getColor)(_ctx.$props.color, void 0, true) })
      }, [
        renderSlot(_ctx.$slots, "default", normalizeProps(guardReactiveProps({ label: __props.label, requiredMark: __props.requiredMark, color: unref(getColor)(_ctx.$props.color) })), () => [
          createTextVNode(toDisplayString(__props.label) + " ", 1),
          __props.requiredMark ? (openBlock(), createElementBlock("span", _hoisted_118, " * ")) : createCommentVNode("", true)
        ])
      ], 4);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-input-wrapper/components/VaInputLabel.js
var _style_035 = ".va-input-label {\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n  font-size: 0.625rem;\n  letter-spacing: 0.6px;\n  line-height: 1.2;\n  font-weight: 700;\n  text-transform: uppercase;\n  min-height: 1rem;\n  display: inline-block;\n}\n.va-input-label__required-mark {\n  transform: translate(0, -2px);\n  color: var(--va-danger);\n  font-size: 18px;\n  font-weight: var(--va-input-container-label-font-weight);\n  vertical-align: middle;\n}";
var VaInputLabel = _export_sfc(_sfc_main38, [["styles", [_style_035]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-input-wrapper/hooks/useInputFieldAria.js
var useInputFieldAriaProps = {
  label: { type: String, default: "" },
  inputAriaLabel: { type: String, default: "$t:inputField" },
  inputAriaLabelledby: { type: String },
  inputAriaDescribedby: { type: String }
};
var useInputFieldAria = (props) => {
  const id = useComponentUuid();
  const labelId = `input-label-${id}`;
  const characterCountId = `input-character-count-${id}`;
  const ariaAttributes = computed(() => ({
    "aria-label": props.label !== "" ? props.label : props.inputAriaLabel,
    "aria-labelledby": props.inputAriaLabelledby ? props.inputAriaLabelledby : labelId,
    "aria-describedby": props.inputAriaDescribedby ? props.inputAriaDescribedby : characterCountId
  }));
  return {
    labelId,
    characterCountId,
    ariaAttributes
  };
};

// node_modules/vuestic-ui/dist/web-components/src/utils/with-slot-inheritance/with-slot-inheritance.js
var WithSlotInheritance = (component) => {
  return defineComponent({
    name: "ProxySlots",
    props: {
      inheritSlots: { type: Array, required: true }
    },
    render() {
      var _a2;
      const parentSlots = ((_a2 = this.$parent) == null ? void 0 : _a2.$slots) || {};
      const slotsToProxy = this.$props.inheritSlots || Object.keys(parentSlots);
      const slots = slotsToProxy.reduce(
        (slots2, name) => {
          if (parentSlots[name]) {
            slots2[name] = parentSlots[name];
          }
          return slots2;
        },
        {}
      );
      return h(component, this.$attrs, {
        ...slots,
        ...this.$slots
      });
    }
  });
};

// node_modules/vuestic-ui/dist/web-components/src/composables/useFormField.js
var useFormFieldProps = {
  disabled: { type: Boolean, default: false },
  readonly: { type: Boolean, default: false }
};
var useFormField = (prefix2, props) => {
  const computedClasses = useBem(prefix2, computed(() => pick$1(props, ["disabled", "readonly"])));
  return { computedClasses };
};

// node_modules/vuestic-ui/dist/web-components/src/composables/useFocusDeep.js
var useFocusDeep = (el) => {
  const focused = useActiveElement();
  const current = useCurrentElement(el ? useHTMLElement(el) : void 0);
  let previouslyFocusedElement = null;
  const isFocused = computed({
    get() {
      var _a2;
      if (!focused.value) {
        return false;
      }
      if (focused.value === current.value) {
        return true;
      }
      const isFocused2 = (_a2 = current.value) == null ? void 0 : _a2.contains(focused.value);
      if (isFocused2) {
        previouslyFocusedElement = focused.value;
      }
      return isFocused2;
    },
    set(value) {
      var _a2;
      let target = previouslyFocusedElement ?? current.value;
      if (!((_a2 = current.value) == null ? void 0 : _a2.contains(target))) {
        target = current.value;
      }
      if (value) {
        target == null ? void 0 : target.focus();
      } else {
        target == null ? void 0 : target.blur();
      }
    }
  });
  return Object.assign(isFocused, {
    /** Focus `el` if focus is not set to any other element */
    focusIfNothingIfFocused: () => {
      if (focused.value === document.body) {
        isFocused.value = true;
      }
    },
    focusPreviousElement: () => {
      if (previouslyFocusedElement) {
        previouslyFocusedElement.focus();
      } else {
        document.body.focus();
      }
    }
  });
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-input-wrapper/VaInputWrapper.vue_vue_type_script_lang.js
var VaInputLabelProps = extractComponentProps(VaInputLabel);
var __default__ = defineComponent({
  name: "VaInputWrapper",
  components: { VaMessageList: WithSlotInheritance(VaMessageList), VaIcon, VaInputLabel },
  props: {
    ...useComponentPresetProp,
    ...useInputFieldAriaProps,
    ...useFormFieldProps,
    ...useValidationProps,
    ...VaInputLabelProps,
    modelValue: { type: null, default: "" },
    counter: { type: Boolean },
    maxLength: { type: Number, default: void 0 },
    label: { type: String, default: "" },
    placeholder: { type: String, default: "" },
    color: { type: String, default: "primary" },
    background: { type: String },
    success: { type: Boolean, default: false },
    loading: { type: Boolean, default: false },
    requiredMark: { type: Boolean, default: false },
    innerLabel: { type: Boolean, default: false }
  },
  emits: [
    "click",
    "click-prepend",
    "click-append",
    "click-prepend-inner",
    "click-append-inner",
    "click-field",
    "update:modelValue"
  ],
  setup(props, { emit, slots }) {
    const { getColor } = useColors();
    const [vModel] = useSyncProp("modelValue", props, emit, "");
    const inputRef = ref();
    const isFocused = useFocusDeep();
    const counterValue = computed(
      () => props.counter && typeof vModel.value === "string" ? vModel.value.length : void 0
    );
    const wrapperClass = useBem("va-input-wrapper", () => ({
      ...pick$1(props, ["success", "error", "disabled", "readonly"]),
      focused: Boolean(isFocused.value),
      labeled: Boolean(props.label || slots.label),
      labeledInner: Boolean(props.label || slots.label) && props.innerLabel
    }));
    const colorComputed = computed(() => getColor(props.color));
    const backgroundComputed = computed(() => props.background ? getColor(props.background) : "#ffffff00");
    const messagesComputed = computed(() => props.error ? props.errorMessages : props.messages);
    const { textColorComputed } = useTextColor(backgroundComputed);
    const messagesColor = computed(() => {
      if (props.error) {
        return "danger";
      }
      if (props.success) {
        return "success";
      }
      return "";
    });
    const errorLimit = computed(() => props.error ? Number(props.errorCount) : 99);
    const isCounterVisible = computed(() => counterValue.value !== void 0);
    const counterComputed = computed(
      () => props.maxLength !== void 0 ? `${counterValue.value}/${props.maxLength}` : counterValue.value
    );
    const {
      labelId,
      characterCountId,
      ariaAttributes
    } = useInputFieldAria(props);
    const vaInputLabelProps = filterComponentProps(VaInputLabelProps);
    const focus = () => {
      isFocused.value = true;
    };
    const blur = () => {
      isFocused.value = false;
    };
    return {
      inputRef,
      focus,
      blur,
      labelId,
      characterCountId,
      ariaAttributes,
      vModel,
      counterValue,
      vaInputLabelProps,
      wrapperClass,
      textColorComputed,
      isCounterVisible,
      counterComputed,
      colorComputed,
      backgroundComputed,
      messagesColor,
      messagesComputed,
      errorLimit
    };
  }
});
var __injectCSSVars__ = () => {
  useCssVars((_ctx) => ({
    "05a29c09": _ctx.backgroundComputed,
    "68f2b922": _ctx.colorComputed,
    "da15c816": _ctx.textColorComputed
  }));
};
var __setup__ = __default__.setup;
__default__.setup = __setup__ ? (props, ctx) => {
  __injectCSSVars__();
  return __setup__(props, ctx);
} : __injectCSSVars__;

// node_modules/vuestic-ui/dist/web-components/src/components/va-input-wrapper/VaInputWrapper.js
var _style_036 = ':root,\n:host {\n  --va-input-wrapper-width: var(--va-form-element-default-width);\n  --va-input-wrapper-color: var(--va-primary);\n  --va-input-wrapper-background: var(--va-background-element, #f5f9fb);\n  --va-input-wrapper-background-opacity: 1;\n  --va-input-wrapper-border-width: var(--va-form-element-border-width);\n  --va-input-wrapper-border-color: var(--va-background-border);\n  --va-input-wrapper-border-radius: var(--va-form-element-border-radius);\n  --va-input-wrapper-min-width: var(--va-form-element-min-width);\n  --va-input-wrapper-display: inline-block;\n  --va-input-wrapper-cursor: text;\n  --va-input-wrapper-min-height: 36px;\n  --va-input-wrapper-validation-background-opacity: 0.1;\n  /* Counter container */\n  --va-input-wrapper-counter-line-height: 1.5;\n  --va-input-wrapper-counter-font-size: 0.8rem;\n  --va-input-wrapper-counter-color: var(--va-secondary);\n  /* Content Wrapper */\n  --va-input-wrapper-horizontal-padding: 0.5rem;\n  --va-input-wrapper-items-gap: 0.5rem;\n  /* Validation */\n  --va-input-wrapper-success-background: var(--va-input-success-color);\n  --va-input-wrapper-error-background: var(--va-input-error-color);\n}\n.va-input-wrapper {\n  --va-input-wrapper-background: var(--05a29c09);\n  --va-input-wrapper-color: var(--68f2b922);\n  --va-input-wrapper-text-color: var(--da15c816);\n  cursor: var(--va-input-wrapper-cursor);\n  font-family: var(--va-font-family);\n  display: inline-block;\n  flex-direction: column;\n  vertical-align: middle;\n  min-width: auto;\n  max-width: 100%;\n  flex-grow: 0;\n  flex-shrink: 1;\n}\n.va-input-wrapper__fieldset {\n  border: none;\n}\n.va-input-wrapper__size-keeper {\n  width: var(--va-input-wrapper-width);\n  min-width: 100%;\n  max-width: 100%;\n  display: flex;\n  flex-direction: column;\n  height: 100%;\n}\n.va-input-wrapper__container {\n  display: flex;\n  align-items: center;\n  gap: var(--va-input-content-items-gap);\n  flex: 1;\n}\n.va-input-wrapper__field {\n  position: relative;\n  display: flex;\n  align-items: center;\n  flex: 1;\n  min-height: var(--va-input-wrapper-min-height);\n  border-color: var(--va-input-wrapper-border-color);\n  border-style: solid;\n  border-width: var(--va-input-wrapper-border-width);\n  border-radius: var(--va-input-wrapper-border-radius);\n  padding: 0 var(--va-input-wrapper-horizontal-padding);\n  gap: var(--va-input-wrapper-items-gap);\n  z-index: 0;\n  overflow: hidden;\n  color: var(--da15c816);\n  align-self: stretch;\n  z-index: 0;\n}\n.va-input-wrapper__field::after {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  content: "";\n  background: var(--va-input-wrapper-background);\n  opacity: var(--va-input-wrapper-background-opacity);\n  z-index: -1;\n  transition: all 0.3s ease-in-out;\n}\n.va-input-wrapper__field input,\n.va-input-wrapper__field textarea {\n  color: inherit;\n}\n.va-input-wrapper > .va-message-list {\n  margin-top: 2px;\n}\n.va-input-wrapper__prepend-inner, .va-input-wrapper__append-inner {\n  display: flex;\n  justify-content: center;\n  align-content: center;\n  align-items: center;\n}\n.va-input-wrapper__text {\n  width: 100%;\n  position: relative;\n  min-height: var(--va-input-line-height);\n  display: flex;\n  align-items: center;\n  align-self: stretch;\n  overflow: hidden;\n  caret-color: var(--va-input-wrapper-text-color);\n  color: var(--va-input-wrapper-text-color);\n}\n.va-input-wrapper__text input {\n  scrollbar-color: var(--va-input-scroll-color) transparent;\n  scrollbar-width: thin;\n  transition: scrollbar-color 0.3s ease-in-out;\n  width: 100%;\n  min-height: var(--va-input-line-height);\n  background-color: transparent;\n  border-style: none;\n  outline: none;\n  line-height: var(--va-input-line-height);\n  font-size: var(--va-input-font-size);\n  font-family: inherit;\n  font-weight: var(--va-input-font-weight);\n  font-style: var(--va-input-font-style);\n  font-stretch: var(--va-input-font-stretch);\n  letter-spacing: var(--va-input-letter-spacing);\n  cursor: inherit;\n  align-self: stretch;\n}\n.va-input-wrapper__text input::-webkit-scrollbar {\n  width: 4px;\n  height: 4px;\n}\n.va-input-wrapper__text input::-webkit-scrollbar-track {\n  box-shadow: none;\n  border-radius: 10px;\n}\n.va-input-wrapper__text input::-webkit-scrollbar-thumb {\n  background: var(--va-input-scroll-color);\n  opacity: 0.3;\n  border-radius: 2px;\n  -webkit-transition: background 0.3s ease-in-out;\n  transition: background 0.3s ease-in-out;\n}\n.va-input-wrapper__text input::-moz-placeholder {\n  color: inherit;\n  opacity: 0.5;\n}\n.va-input-wrapper__text input::placeholder {\n  color: inherit;\n  opacity: 0.5;\n}\n.va-input-wrapper__icons {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n}\n.va-input-wrapper__icons__reset:focus {\n  outline: 2px solid var(--va-focus) !important;\n  border-radius: 2px;\n}\n.va-input-wrapper__counter-wrapper {\n  display: flex;\n  align-items: center;\n  justify-content: flex-end;\n  color: var(--va-input-wrapper-counter-color);\n  font-size: var(--va-input-wrapper-counter-font-size);\n  line-height: var(--va-input-wrapper-counter-line-height);\n}\n.va-input-wrapper__label {\n  max-width: 100%;\n  width: 100%;\n  display: block;\n}\n.va-input-wrapper__label--inner {\n  position: absolute;\n  left: 0;\n  top: 0;\n  padding-top: 1px;\n}\n.va-input-wrapper__label--outer {\n  margin-bottom: 2px;\n}\n.va-input-wrapper--labeled-inner .va-input-wrapper__text {\n  padding-top: 12px;\n  box-sizing: content-box;\n}\n.va-input-wrapper--labeled-inner textarea {\n  margin-top: 0;\n}\n.va-input-wrapper--solid {\n  --va-input-wrapper-border-color: var(--va-input-color);\n}\n.va-input-wrapper--bordered .va-input-wrapper__field {\n  border-top-left-radius: var(--va-input-wrapper-border-radius);\n  border-top-right-radius: var(--va-input-wrapper-border-radius);\n  border-bottom-left-radius: 0;\n  border-bottom-right-radius: 0;\n  border-left-width: 0;\n  border-right-width: 0;\n  border-top-width: 0;\n}\n.va-input-wrapper--bordered .va-input-wrapper__field::after {\n  bottom: 0;\n  border-color: var(--va-input-wrapper-border-color);\n  border-bottom-style: solid;\n}\n.va-input-wrapper--error {\n  --va-input-wrapper-border-color: var(--va-input-wrapper-error-background, var(--va-danger));\n  --va-input-wrapper-background: var(--va-input-wrapper-error-background, var(--va-danger));\n  --va-input-wrapper-background-opacity: var(--va-input-wrapper-validation-background-opacity);\n}\n.va-input-wrapper--success {\n  --va-input-wrapper-border-color: var(--va-input-wrapper-success-background, var(--va-success));\n  --va-input-wrapper-background: var(--va-input-wrapper-success-background, var(--va-success));\n  --va-input-wrapper-background-opacity: var(--va-input-wrapper-validation-background-opacity);\n}\n.va-input-wrapper--focused {\n  --va-input-wrapper-border-color: var(--va-input-wrapper-color);\n}\n.va-input-wrapper--readonly {\n  cursor: default;\n}\n.va-input-wrapper--disabled {\n  cursor: default;\n  opacity: 0.4;\n  pointer-events: none;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n          user-select: none;\n}';
var _hoisted_119 = { class: "va-input-wrapper__fieldset va-input-wrapper__size-keeper" };
var _hoisted_210 = { class: "va-input-wrapper__container" };
var _hoisted_36 = { class: "va-input-wrapper__text" };
var _hoisted_45 = ["placeholder", "readonly", "disabled"];
var _hoisted_54 = ["id"];
var _hoisted_64 = { class: "va-input-wrapper__counter" };
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_VaInputLabel = resolveComponent("VaInputLabel");
  const _component_va_icon = resolveComponent("va-icon");
  const _component_va_message_list = resolveComponent("va-message-list");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["va-input-wrapper", _ctx.wrapperClass]),
    onClick: _cache[6] || (_cache[6] = ($event) => _ctx.$emit("click", $event))
  }, [
    createBaseVNode("fieldset", _hoisted_119, [
      createVNode(_component_va_message_list, {
        color: _ctx.messagesColor,
        "model-value": _ctx.messagesComputed,
        limit: _ctx.errorLimit,
        "inherit-slots": ["message", "messages"]
      }, {
        default: withCtx(({ ariaAttributes: messagesChildAriaAttributes }) => [
          (_ctx.$props.label || _ctx.$slots.label) && !_ctx.$props.innerLabel ? (openBlock(), createBlock(_component_VaInputLabel, mergeProps({
            key: 0,
            class: "va-input-wrapper__label va-input-wrapper__label--outer"
          }, _ctx.vaInputLabelProps, { id: _ctx.labelId }), {
            default: withCtx((bind) => [
              renderSlot(_ctx.$slots, "label", normalizeProps(guardReactiveProps(bind)))
            ]),
            _: 3
          }, 16, ["id"])) : createCommentVNode("", true),
          createBaseVNode("div", _hoisted_210, [
            _ctx.$slots.prepend ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: "va-input-wrapper__prepend-inner",
              onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click-prepend"))
            }, [
              renderSlot(_ctx.$slots, "prepend")
            ])) : createCommentVNode("", true),
            createBaseVNode("div", {
              onClick: _cache[4] || (_cache[4] = ($event) => _ctx.$emit("click-field", $event)),
              class: "va-input-wrapper__field"
            }, [
              _ctx.$slots.prependInner ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: "va-input-wrapper__prepend-inner",
                ref: "container",
                onClick: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("click-prepend-inner", $event))
              }, [
                renderSlot(_ctx.$slots, "prependInner")
              ], 512)) : createCommentVNode("", true),
              createBaseVNode("div", _hoisted_36, [
                (_ctx.$props.label || _ctx.$slots.label) && _ctx.$props.innerLabel ? (openBlock(), createBlock(_component_VaInputLabel, mergeProps({
                  key: 0,
                  class: "va-input-wrapper__label va-input-wrapper__label--inner"
                }, _ctx.vaInputLabelProps, { id: _ctx.labelId }), {
                  default: withCtx((bind) => [
                    renderSlot(_ctx.$slots, "label", normalizeProps(guardReactiveProps(bind)))
                  ]),
                  _: 3
                }, 16, ["id"])) : createCommentVNode("", true),
                renderSlot(_ctx.$slots, "default", normalizeProps(guardReactiveProps({ ariaAttributes: { ...messagesChildAriaAttributes, ..._ctx.ariaAttributes }, value: _ctx.vModel })), () => [
                  withDirectives(createBaseVNode("input", mergeProps({ ...messagesChildAriaAttributes, ..._ctx.ariaAttributes }, {
                    "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => _ctx.vModel = $event),
                    ref: "inputRef",
                    placeholder: _ctx.$props.placeholder,
                    readonly: _ctx.$props.readonly,
                    disabled: _ctx.$props.disabled
                  }), null, 16, _hoisted_45), [
                    [vModelDynamic, _ctx.vModel]
                  ])
                ])
              ]),
              _ctx.success ? (openBlock(), createBlock(_component_va_icon, {
                key: 1,
                color: "success",
                name: "va-check-circle",
                class: "va-input-wrapper__icon va-input-wrapper__icon--success"
              })) : createCommentVNode("", true),
              _ctx.error ? (openBlock(), createBlock(_component_va_icon, {
                key: 2,
                color: "danger",
                name: "va-warning",
                class: "va-input-wrapper__icon va-input-wrapper__icon--error"
              })) : createCommentVNode("", true),
              _ctx.$props.loading ? (openBlock(), createBlock(_component_va_icon, {
                key: 3,
                color: _ctx.$props.color,
                name: "va-loading",
                spin: "counter-clockwise",
                class: "va-input-wrapper__icon va-input-wrapper__icon--loading"
              }, null, 8, ["color"])) : createCommentVNode("", true),
              renderSlot(_ctx.$slots, "icon"),
              _ctx.$slots.appendInner ? (openBlock(), createElementBlock("div", {
                key: 4,
                class: "va-input-wrapper__append-inner",
                onClick: _cache[3] || (_cache[3] = ($event) => _ctx.$emit("click-append-inner", $event))
              }, [
                renderSlot(_ctx.$slots, "appendInner")
              ])) : createCommentVNode("", true)
            ]),
            _ctx.$slots.append ? (openBlock(), createElementBlock("div", {
              key: 1,
              class: "va-input-wrapper__append-inner",
              onClick: _cache[5] || (_cache[5] = ($event) => _ctx.$emit("click-append"))
            }, [
              renderSlot(_ctx.$slots, "append")
            ])) : createCommentVNode("", true)
          ]),
          _ctx.isCounterVisible ? (openBlock(), createElementBlock("div", {
            key: 1,
            class: "va-input-wrapper__counter-wrapper",
            id: _ctx.characterCountId
          }, [
            renderSlot(_ctx.$slots, "counter", normalizeProps(guardReactiveProps({ valueLength: _ctx.counterValue, maxLength: _ctx.$props.maxLength })), () => [
              createBaseVNode("div", _hoisted_64, toDisplayString(_ctx.counterComputed), 1)
            ])
          ], 8, _hoisted_54)) : createCommentVNode("", true)
        ]),
        _: 3
      }, 8, ["color", "model-value", "limit"])
    ])
  ], 2);
}
var _VaInputWrapper = _export_sfc(__default__, [["render", _sfc_render], ["styles", [...(__default__.components ? Object.values(__default__.components) : []).map((c) => c.styles || []).flat(), _style_036]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-input-wrapper/index.js
var VaInputWrapper = withConfigTransport$1(_VaInputWrapper);

// node_modules/vuestic-ui/dist/web-components/src/utils/combine-functions.js
var combineFunctions = (...list) => {
  return (...args) => list.forEach((fn) => fn(...args));
};

// node_modules/vuestic-ui/dist/web-components/src/composables/useFocusable.js
var useFocusableProps = {
  /** Focus element when mounted */
  autofocus: { type: Boolean, default: false }
};
var useFocusable = (el, props) => {
  const focus = () => {
    focusElement(unwrapEl(el.value));
  };
  const blur = () => {
    blurElement(unwrapEl(el.value));
  };
  onMounted(() => {
    if (props.autofocus) {
      focus();
    }
  });
  return {
    focus,
    blur
  };
};

// node_modules/vuestic-ui/dist/web-components/src/composables/useClearable.js
var useClearableProps = {
  clearable: { type: Boolean, default: false },
  clearableIcon: { type: String, default: "va-clear" },
  clearValue: { type: String, default: "" }
};
var useClearableEmits = ["clear"];
var useClearable = (props, inputValue, el, hasError) => {
  const { isFocused, onFocus, onBlur } = useFocus(el);
  const clearedValues = [null, void 0, props.clearValue];
  const canBeCleared = computed(() => props.clearable && !props.disabled && !props.readonly && !clearedValues.includes(inputValue.value));
  const clearIconColor = computed(() => {
    if (isFocused == null ? void 0 : isFocused.value) {
      return props.color || "primary";
    }
    if (hasError == null ? void 0 : hasError.value) {
      return "danger";
    }
    if (props.success) {
      return "success";
    }
    return "secondary";
  });
  const clearIconProps = computed(() => ({
    name: props.clearableIcon,
    color: clearIconColor.value,
    size: "medium",
    tabindex: canBeCleared.value ? 0 : -1
  }));
  return {
    canBeCleared,
    clearIconColor,
    clearIconProps,
    onFocus,
    onBlur
  };
};

// node_modules/vuestic-ui/dist/web-components/src/composables/useDeprecatedCondition.js
var useDeprecatedCondition = (validators) => {
  if (!isDev) {
    return void 0;
  }
  const instance = getCurrentInstance();
  if (!instance) {
    throw new Error("`useDeprecated` hook must be used only inside of setup function!");
  }
  validators.forEach((validator) => {
    const message = validator();
    if (typeof message === "string") {
      warn(`(${instance.type.name} component) ${message}`);
    }
  });
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-input/VaInput.vue_vue_type_script_setup_true_lang.js
var _hoisted_120 = ["value"];
var VaInputWrapperProps = extractComponentProps(VaInputWrapper);
var { createEmits: createInputEmits, createListeners: createInputListeners } = useEmitProxy(
  ["change", "keyup", "keypress", "keydown", "focus", "blur", "input"]
);
var { createEmits: createFieldEmits, createListeners: createFieldListeners } = useEmitProxy([
  "click",
  "click-prepend",
  "click-append",
  "click-prepend-inner",
  "click-append-inner"
]);
var _sfc_main39 = defineComponent({
  ...{
    name: "VaInput",
    inheritAttrs: false
  },
  __name: "VaInput",
  props: {
    ...VaInputWrapperProps,
    ...useFormFieldProps,
    ...useFocusableProps,
    ...useValidationProps,
    ...useClearableProps,
    ...useCleaveProps,
    ...useComponentPresetProp,
    ...useStatefulProps,
    // input
    placeholder: { type: String, default: "" },
    tabindex: { type: [String, Number], default: 0 },
    modelValue: { type: [Number, String], default: "" },
    type: { type: String, default: "text" },
    inputClass: { type: String, default: "" },
    pattern: { type: String },
    inputmode: { type: String, default: "text" },
    counter: { type: Boolean, default: false },
    // style
    ariaResetLabel: { type: String, default: "$t:reset" },
    /** Set value to input when model value is updated */
    strictBindInputValue: { type: Boolean, default: false }
  },
  emits: [
    "update:modelValue",
    ...useValidationEmits,
    ...useClearableEmits,
    ...createInputEmits(),
    ...createFieldEmits(),
    ...useStatefulEmits
  ],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit = __emit;
    useDeprecatedCondition([
      () => props.type !== "textarea" || 'Use VaTextarea component instead of VaInput with type="textarea"'
    ]);
    const input = shallowRef();
    const { valueComputed } = useStateful(props, emit, "modelValue");
    const reset = () => withoutValidation(() => {
      emit("update:modelValue", props.clearValue);
      emit("clear");
      resetValidation();
    });
    const { focus, blur } = useFocusable(input, props);
    const slots = useSlots();
    const filterSlots = computed(() => {
      const iconSlot = ["icon"];
      return Object.keys(slots).filter((slot) => !iconSlot.includes(slot));
    });
    const { tp } = useTranslation();
    const {
      isDirty,
      computedError,
      computedErrorMessages,
      listeners: { onBlur, onFocus },
      validationAriaAttributes,
      isLoading,
      withoutValidation,
      resetValidation
    } = useValidation(props, emit, { reset, focus, value: valueComputed });
    const { modelValue } = toRefs(props);
    const {
      canBeCleared,
      clearIconProps
    } = useClearable(props, modelValue, input, computedError);
    const { computedValue, onInput } = useCleave(input, props, valueComputed);
    const inputListeners = createInputListeners(emit);
    const inputEvents = {
      ...inputListeners,
      onFocus: combineFunctions(onFocus, inputListeners.onFocus),
      onBlur: combineFunctions(onBlur, inputListeners.onBlur),
      onInput: combineFunctions(onInput, inputListeners.onInput)
    };
    const setInputValue = (newValue) => {
      if (!props.strictBindInputValue) {
        return;
      }
      const target = input.value;
      if (!target) {
        return;
      }
      const selectionStart = target.selectionStart || 0;
      const selectionEnd = target.selectionEnd || 0;
      if (target.value !== newValue) {
        target.value = String(newValue);
      }
      target.setSelectionRange(selectionStart, selectionEnd);
    };
    watch(computedValue, (newValue) => {
      setInputValue(String(newValue));
    }, { immediate: true });
    useEvent("input", () => {
      setInputValue(String(valueComputed.value));
    }, input);
    const tabIndexComputed = computed(() => props.disabled ? -1 : props.tabindex);
    const attrs = useAttrs();
    const computedChildAttributes = computed(() => ({
      "aria-label": props.inputAriaLabel || props.label,
      "aria-labelledby": props.inputAriaLabelledby,
      "aria-required": props.requiredMark,
      tabindex: tabIndexComputed.value,
      class: props.inputClass,
      "aria-disabled": props.disabled,
      "aria-readonly": props.readonly,
      ...validationAriaAttributes.value,
      ...omit$1(attrs, ["class", "style"])
    }));
    const computedInputAttributes = computed(() => ({
      ...computedChildAttributes.value,
      ...pick$1(props, ["type", "disabled", "readonly", "placeholder", "pattern", "inputmode", "minlength", "maxlength"])
    }));
    const valueLengthComputed = computed(
      () => props.counter && typeof computedValue.value === "string" ? computedValue.value.length : void 0
    );
    const onFieldClick = (e) => {
      if (!e.target || !("tagName" in e.target)) {
        return;
      }
      if (e.target.tagName === "INPUT" || e.target.tagName === "TEXTAREA") {
        return;
      }
      focus();
    };
    const wrapperProps = filterComponentProps(VaInputWrapperProps);
    const fieldListeners = createFieldListeners(emit);
    __expose({
      isDirty,
      isLoading,
      computedError,
      computedErrorMessages,
      reset,
      focus,
      blur,
      value: valueComputed,
      withoutValidation,
      resetValidation
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(VaInputWrapper), mergeProps({
        ...unref(fieldListeners),
        ...unref(wrapperProps)
      }, {
        class: ["va-input", _ctx.$attrs.class],
        style: _ctx.$attrs.style,
        loading: _ctx.$props.loading || unref(isLoading),
        error: unref(computedError),
        "error-messages": unref(computedErrorMessages),
        "error-count": _ctx.errorCount,
        "counter-value": valueLengthComputed.value,
        onClick: onFieldClick
      }), createSlots({
        icon: withCtx((slotScope) => [
          unref(canBeCleared) ? (openBlock(), createBlock(unref(VaIcon), mergeProps({
            key: 0,
            role: "button",
            "aria-label": unref(tp)(_ctx.$props.ariaResetLabel)
          }, unref(clearIconProps), {
            onClick: withModifiers(reset, ["stop"]),
            onKeydown: [
              withKeys(withModifiers(reset, ["stop"]), ["enter"]),
              withKeys(withModifiers(reset, ["stop"]), ["space"])
            ]
          }), null, 16, ["aria-label", "onKeydown"])) : createCommentVNode("", true),
          renderSlot(_ctx.$slots, "icon", normalizeProps(guardReactiveProps(slotScope)))
        ]),
        default: withCtx(() => [
          !_ctx.$slots.content ? (openBlock(), createElementBlock("input", mergeProps({
            key: 0,
            ref_key: "input",
            ref: input,
            class: "va-input__content__input"
          }, { ...computedInputAttributes.value, ...inputEvents }, { value: unref(computedValue) }), null, 16, _hoisted_120)) : createCommentVNode("", true)
        ]),
        _: 2
      }, [
        renderList(filterSlots.value, (name) => {
          return {
            name,
            fn: withCtx((slotScope) => [
              renderSlot(_ctx.$slots, name, normalizeProps(guardReactiveProps(slotScope)))
            ])
          };
        })
      ]), 1040, ["class", "style", "loading", "error", "error-messages", "error-count", "counter-value"]);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-input/index.js
var VaInput = withConfigTransport$1(_sfc_main39);

// node_modules/vuestic-ui/dist/web-components/src/components/va-color-input/VaColorInput.vue_vue_type_script_setup_true_lang.js
var _hoisted_121 = { class: "va-color-input" };
var VaInputProps = extractComponentProps(VaInput);
var _sfc_main40 = defineComponent({
  ...{
    name: "VaColorInput"
  },
  __name: "VaColorInput",
  props: {
    ...VaInputProps,
    ...useStatefulProps,
    ...useComponentPresetProp,
    modelValue: { type: String, default: null },
    disabled: { type: Boolean, default: false },
    indicator: {
      type: String,
      default: "dot",
      validator: (value) => ["dot", "square"].includes(value)
    },
    ariaOpenColorPickerLabel: { type: String, default: "$t:openColorPicker" }
  },
  emits: [...useStatefulEmits],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const colorPicker = shallowRef();
    const { valueComputed } = useStateful(props, emit);
    const callPickerDialog = () => {
      var _a2;
      return !props.disabled && ((_a2 = colorPicker.value) == null ? void 0 : _a2.click());
    };
    const tabIndexComputed = computed(() => props.disabled ? -1 : 0);
    const inputValue = computed({
      get: () => props.modelValue,
      set: throttle$1((value) => emit("update:modelValue", value), 500)
    });
    const vaInputProps = filterComponentProps(VaInputProps);
    const { tp } = useTranslation();
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_121, [
        createVNode(unref(VaInput), mergeProps(unref(vaInputProps), {
          modelValue: unref(valueComputed),
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => isRef(valueComputed) ? valueComputed.value = $event : null),
          class: "va-color-input__input",
          tabindex: tabIndexComputed.value
        }), {
          appendInner: withCtx(() => [
            createVNode(unref(VaColorIndicator), {
              class: "va-color-input__dot",
              role: "button",
              "aria-label": unref(tp)(_ctx.$props.ariaOpenColorPickerLabel),
              "aria-disabled": _ctx.$props.disabled,
              tabindex: tabIndexComputed.value,
              color: unref(valueComputed),
              indicator: _ctx.$props.indicator,
              size: "16px",
              onClick: callPickerDialog,
              onKeydown: [
                withKeys(callPickerDialog, ["space"]),
                withKeys(callPickerDialog, ["enter"])
              ]
            }, null, 8, ["aria-label", "aria-disabled", "tabindex", "color", "indicator"])
          ]),
          _: 1
        }, 16, ["modelValue", "tabindex"]),
        withDirectives(createBaseVNode("input", {
          ref_key: "colorPicker",
          ref: colorPicker,
          type: "color",
          class: "va-color-input__hidden-input",
          "aria-hidden": "true",
          tabindex: "-1",
          "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => inputValue.value = $event)
        }, null, 512), [
          [vModelText, inputValue.value]
        ])
      ]);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-color-input/VaColorInput.js
var _style_037 = ".va-color-input {\n  display: flex;\n  align-items: center !important;\n}\n.va-color-input .form-group {\n  margin-bottom: 0;\n}\n.va-color-input__input {\n  margin-bottom: 0;\n  min-width: 5.6rem;\n}\n.va-color-input__input__pointer {\n  cursor: pointer;\n}\n.va-color-input__hidden-input {\n  visibility: hidden;\n  width: 0;\n  height: 0;\n  overflow: hidden;\n  position: absolute;\n  pointer-events: none;\n}";
var _VaColorInput = _export_sfc(_sfc_main40, [["styles", [_style_037]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-color-input/index.js
var VaColorInput = withConfigTransport$1(_VaColorInput);

// node_modules/vuestic-ui/dist/web-components/src/components/va-color-palette/VaColorPalette.vue_vue_type_script_setup_true_lang.js
var _hoisted_122 = ["aria-label"];
var _sfc_main41 = defineComponent({
  ...{
    name: "VaColorPalette"
  },
  __name: "VaColorPalette",
  props: {
    ...useStatefulProps,
    ...useComponentPresetProp,
    modelValue: { type: String, default: null },
    palette: { type: Array, default: () => [] },
    indicator: {
      type: String,
      default: "dot",
      validator: (value) => ["dot", "square"].includes(value)
    },
    ariaLabel: { type: String, default: "$t:colorSelection" },
    ariaIndicatorLabel: { type: String, default: "$t:color" }
  },
  emits: [...useStatefulEmits],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const { valueComputed } = useStateful(props, emit);
    const isSelected = (color) => valueComputed.value === color;
    const { tp } = useTranslation();
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("ul", {
        class: "va-color-palette",
        role: "listbox",
        "aria-label": unref(tp)(_ctx.$props.ariaLabel)
      }, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(__props.palette, (color, index) => {
          return openBlock(), createBlock(unref(VaColorIndicator), {
            key: index,
            role: "option",
            "aria-label": unref(tp)(_ctx.$props.ariaIndicatorLabel, { color }),
            "aria-selected": isSelected(color),
            tabindex: "0",
            modelValue: isSelected(color),
            color,
            square: __props.indicator === "square",
            "onUpdate:modelValue": ($event) => valueComputed.value = color
          }, null, 8, ["aria-label", "aria-selected", "modelValue", "color", "square", "onUpdate:modelValue"]);
        }), 128))
      ], 8, _hoisted_122);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-color-palette/VaColorPalette.js
var _style_038 = ".va-color-palette {\n  display: flex;\n  padding-left: 0;\n  margin: 0;\n}\n.va-color-palette > * {\n  margin-right: 0.25rem;\n}\n.va-color-palette > *:last-child {\n  margin-right: 0;\n}";
var _VaColorPalette = _export_sfc(_sfc_main41, [["styles", [_style_038]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-color-palette/index.js
var VaColorPalette = withConfigTransport$1(_VaColorPalette);

// node_modules/vuestic-ui/dist/web-components/src/components/va-content/VaContent.js
var _sfc_main42 = {
  name: "VaContent"
};
var _hoisted_123 = { class: "va-typography-block" };
function _sfc_render2(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_123, [
    renderSlot(_ctx.$slots, "default")
  ]);
}
var _VaContent = _export_sfc(_sfc_main42, [["render", _sfc_render2], ["styles", [...(_sfc_main42.components ? Object.values(_sfc_main42.components) : []).map((c) => c.styles || []).flat()]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-content/index.js
var VaContent = withConfigTransport$1(_VaContent);

// node_modules/vuestic-ui/dist/web-components/src/utils/css.js
var safeCSSLength = (length) => typeof length === "number" ? `${length}px` : length;

// node_modules/vuestic-ui/dist/web-components/src/components/va-counter/hooks/useCounterPropsValidation.js
function useCounterPropsValidation(props) {
  const validateCounterProps = () => {
    const val = Number(props.modelValue);
    if (Number.isNaN(val)) {
      warn("The value is not a number or cannot be reduced to a number.");
      return;
    }
    if (props.min && props.max && props.min > props.max) {
      warn(`The maximum value (${props.max}) can not be less than the minimum value (${props.min}).`);
    }
    if (props.min && val < props.min) {
      warn(`The value of the counter (${val}) can not be less than the minimum value (${props.min}).`);
    }
    if (props.max && val > props.max) {
      warn(`The value of the counter (${val}) can not be greater than the maximum value (${props.max}).`);
    }
    if (props.min && props.max && props.step > props.max - props.min) {
      warn(`The value of the step (${props.step}) can not be greater than the difference (${props.max - props.min}) between maximum value (${props.max}) and minimum value (${props.min}).`);
    }
  };
  watch(
    [
      () => props.step,
      () => props.min,
      () => props.max
    ],
    validateCounterProps,
    { immediate: true }
  );
}

// node_modules/vuestic-ui/dist/web-components/src/composables/useLongPress.js
function useLongPress(el, options) {
  let timeoutId = -1;
  let intervalId = -1;
  const handleMouseDown = () => {
    var _a2;
    (_a2 = options.onStart) == null ? void 0 : _a2.call(options);
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => {
      intervalId = setInterval(() => {
        var _a22;
        return (_a22 = options.onUpdate) == null ? void 0 : _a22.call(options);
      }, options.interval || 100);
    }, unref(options.delay) || 500);
  };
  const handleMouseUp = () => {
    var _a2;
    clearTimeout(timeoutId);
    clearInterval(intervalId);
    (_a2 = options.onEnd) == null ? void 0 : _a2.call(options);
  };
  const htmlElement = useHTMLElement(el);
  useEvent(["mousedown", "touchstart", "dragstart"], handleMouseDown, htmlElement);
  useEvent([
    "mouseup",
    "mouseleave",
    "touchend",
    "touchcancel",
    "drop",
    "dragend",
    "blur"
  ], handleMouseUp, true);
}

// node_modules/vuestic-ui/dist/web-components/src/components/va-counter/VaCounter.vue_vue_type_script_setup_true_lang.js
var _hoisted_124 = ["value", "aria-live"];
var { createEmits: createInputEmits2, createListeners: createInputListeners2 } = useEmitProxy(
  ["change"]
);
var { createEmits: createFieldEmits2, createListeners: createFieldListeners2 } = useEmitProxy([
  { listen: "click-prepend", emit: "click:decrease-button" },
  { listen: "click-append", emit: "click:increase-button" },
  { listen: "click-prepend-inner", emit: "click:decrease-icon" },
  { listen: "click-append-inner", emit: "click:increase-icon" }
]);
var VaInputWrapperProps2 = extractComponentProps(VaInputWrapper);
var _sfc_main43 = defineComponent({
  ...{
    name: "VaCounter",
    inheritAttrs: false
  },
  __name: "VaCounter",
  props: {
    ...useFormFieldProps,
    ...useStatefulProps,
    ...useComponentPresetProp,
    ...useClearableProps,
    ...VaInputWrapperProps2,
    // input
    modelValue: { type: [String, Number], default: 0 },
    manualInput: { type: Boolean, default: false },
    min: { type: Number },
    max: { type: Number },
    step: { type: Number, default: 1 },
    color: { type: String, default: "primary" },
    // icons & buttons
    increaseIcon: { type: String, default: "va-plus" },
    decreaseIcon: { type: String, default: "va-minus" },
    buttons: { type: Boolean, default: false },
    flat: { type: Boolean, default: true },
    rounded: { type: Boolean, default: false },
    margins: { type: [String, Number], default: "4px" },
    longPressDelay: { type: Number, default: 500 },
    ariaLabel: { type: String, default: "$t:counterValue" },
    ariaDecreaseLabel: { type: String, default: "$t:decreaseCounter" },
    ariaIncreaseLabel: { type: String, default: "$t:increaseCounter" }
  },
  emits: [
    "update:modelValue",
    ...useValidationEmits,
    ...createInputEmits2(),
    ...createFieldEmits2(),
    ...useFocusEmits
  ],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const input = shallowRef();
    const { min = ref(void 0), max = ref(void 0), step } = toRefs(props);
    const {
      isFocused,
      focus,
      blur
    } = useFocus(input, emit);
    const { valueComputed } = useStateful(props, emit);
    const reset = () => withoutValidation(() => {
      emit("update:modelValue", props.clearValue);
      emit("clear");
      resetValidation();
    });
    const {
      computedError,
      computedErrorMessages,
      withoutValidation,
      resetValidation
    } = useValidation(props, emit, { reset, focus, value: valueComputed });
    const setCountInput = ({ target }) => {
      valueComputed.value = Number(target == null ? void 0 : target.value);
    };
    const setCountChange = ({ target }) => {
      calculateCounterValue(Number(target == null ? void 0 : target.value));
    };
    const getRoundDownWithStep = (value) => {
      if (typeof min.value === "undefined" || !step.value) {
        return value;
      }
      return min.value + step.value * Math.floor((value - min.value) / step.value);
    };
    const calculateCounterValue = (counterValue) => {
      if (typeof min.value !== "undefined" && counterValue < min.value) {
        valueComputed.value = min.value;
        return;
      }
      if (max.value && counterValue > max.value) {
        valueComputed.value = getRoundDownWithStep(max.value);
        return;
      }
      valueComputed.value = getRoundDownWithStep(counterValue);
    };
    const isMinReached = computed(() => {
      if (isNil$1(min.value)) {
        return false;
      }
      return Number(valueComputed.value) <= min.value;
    });
    const isMaxReached = computed(() => {
      if (isNil$1(max.value)) {
        return false;
      }
      return step.value ? Number(valueComputed.value) > max.value - step.value : Number(valueComputed.value) >= max.value;
    });
    const tabIndexComputed = computed(() => props.disabled ? -1 : 0);
    const isDecreaseActionDisabled = computed(() => isMinReached.value || props.disabled);
    const isIncreaseActionDisabled = computed(() => isMaxReached.value || props.disabled);
    const decreaseCount = () => {
      if (isDecreaseActionDisabled.value) {
        return;
      }
      calculateCounterValue(Number(valueComputed.value) - step.value);
    };
    const increaseCount = () => {
      if (isIncreaseActionDisabled.value) {
        return;
      }
      calculateCounterValue(Number(valueComputed.value) + step.value);
    };
    useLongPress(useTemplateRef("decreaseButtonRef"), {
      onUpdate: decreaseCount,
      delay: toRef(props, "longPressDelay")
    });
    useLongPress(useTemplateRef("increaseButtonRef"), {
      onUpdate: increaseCount,
      delay: toRef(props, "longPressDelay")
    });
    const { getColor } = useColors();
    const colorComputed = computed(() => getColor(props.color));
    const decreaseIconProps = computed(() => ({
      class: { "va-counter__icon--inactive": isDecreaseActionDisabled.value },
      color: colorComputed.value,
      icon: props.decreaseIcon,
      plain: true,
      disabled: isDecreaseActionDisabled.value,
      readonly: props.readonly,
      tabindex: -1,
      "aria-label": tp(props.ariaDecreaseLabel),
      ...!isDecreaseActionDisabled.value && { onClick: decreaseCount }
    }));
    const increaseIconProps = computed(() => ({
      class: { "va-counter__icon--inactive": isIncreaseActionDisabled.value },
      color: colorComputed.value,
      icon: props.increaseIcon,
      plain: true,
      disabled: isIncreaseActionDisabled.value,
      readonly: props.readonly,
      tabindex: -1,
      "aria-label": tp(props.ariaIncreaseLabel),
      ...!isIncreaseActionDisabled.value && { onClick: increaseCount }
    }));
    const isSquareCorners = computed(() => (typeof props.margins === "string" ? parseFloat(props.margins) : props.margins) === 0);
    const buttonsColor = () => {
      if (isFocused.value) {
        return props.color;
      }
      return "background-border";
    };
    const buttonProps = computed(() => ({
      ...pick$1(props, ["color", "textColor"]),
      round: props.rounded,
      preset: props.flat ? "secondary" : "",
      borderColor: props.flat ? buttonsColor() : ""
    }));
    const decreaseButtonProps = computed(() => ({
      ...buttonProps.value,
      icon: props.decreaseIcon,
      disabled: isDecreaseActionDisabled.value,
      "aria-label": tp(props.ariaDecreaseLabel),
      ...!isDecreaseActionDisabled.value && { onClick: decreaseCount }
    }));
    const increaseButtonProps = computed(() => ({
      ...buttonProps.value,
      icon: props.increaseIcon,
      disabled: isIncreaseActionDisabled.value,
      "aria-label": tp(props.ariaIncreaseLabel),
      ...!isIncreaseActionDisabled.value && { onClick: increaseCount }
    }));
    const { tp } = useTranslation();
    const attrs = useAttrs();
    const slots = useSlots();
    const inputAttributesComputed = computed(() => ({
      tabindex: tabIndexComputed.value,
      "aria-label": tp(props.ariaLabel),
      "aria-valuemin": min.value,
      "aria-valuemax": max.value,
      ...omit$1(attrs, ["class", "style"]),
      ...pick$1(props, ["disabled", "min", "max", "step"]),
      readonly: props.readonly || !props.manualInput
    }));
    const classComputed = computed(() => [
      attrs.class,
      { "va-counter--input-square": isSquareCorners.value },
      { "va-counter--content-slot": slots.content && props.buttons }
    ].filter(Boolean));
    const styleComputed = computed(() => ({
      ...attrs.style || {}
    }));
    const marginComputed = computed(() => safeCSSLength(props.margins));
    useCounterPropsValidation(props);
    const fieldListeners = createFieldListeners2(emit);
    const inputListeners = createInputListeners2(emit);
    const inputWrapperPropsComputed = filterComponentProps(VaInputWrapperProps2);
    __expose({
      focus,
      blur,
      decreaseCount,
      increaseCount,
      reset
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(VaInputWrapper), mergeProps({ class: "va-counter" }, { ...unref(fieldListeners), ...unref(inputWrapperPropsComputed) }, {
        class: classComputed.value,
        style: styleComputed.value,
        focused: unref(isFocused),
        error: unref(computedError),
        "error-messages": unref(computedErrorMessages),
        onKeydown: [
          withKeys(withModifiers(increaseCount, ["prevent"]), ["up"]),
          withKeys(withModifiers(increaseCount, ["prevent"]), ["right"]),
          withKeys(withModifiers(decreaseCount, ["prevent"]), ["down"]),
          withKeys(withModifiers(decreaseCount, ["prevent"]), ["left"])
        ]
      }), createSlots({
        default: withCtx(() => [
          !_ctx.$slots.content ? (openBlock(), createElementBlock("input", mergeProps({
            key: 0,
            ref_key: "input",
            ref: input,
            class: "va-input__content__input",
            type: "number",
            inputmode: "decimal"
          }, { ...inputAttributesComputed.value, ...unref(inputListeners) }, {
            value: unref(valueComputed),
            "aria-live": _ctx.$props.disabled ? "off" : "polite",
            onInput: setCountInput,
            onChange: setCountChange
          }), null, 16, _hoisted_124)) : createCommentVNode("", true)
        ]),
        _: 2
      }, [
        _ctx.$props.buttons ? {
          name: "prepend",
          fn: withCtx((slotScope) => [
            createBaseVNode("div", {
              class: "va-counter__prepend-wrapper",
              style: normalizeStyle({ marginRight: marginComputed.value }),
              onMousedown: _cache[0] || (_cache[0] = withModifiers(
                //@ts-ignore
                (...args) => unref(focus) && unref(focus)(...args),
                ["prevent"]
              ))
            }, [
              renderSlot(_ctx.$slots, "decreaseAction", normalizeProps(guardReactiveProps({ ...slotScope, decreaseCount })), () => [
                createVNode(unref(VaButton), mergeProps({ class: "va-counter__button-decrease" }, decreaseButtonProps.value, { ref: "decreaseButtonRef" }), null, 16)
              ])
            ], 36)
          ]),
          key: "0"
        } : {
          name: "prependInner",
          fn: withCtx((slotScope) => [
            createBaseVNode("div", {
              class: "va-counter__prepend-inner",
              onMousedown: _cache[1] || (_cache[1] = withModifiers(
                //@ts-ignore
                (...args) => unref(focus) && unref(focus)(...args),
                ["prevent"]
              ))
            }, [
              renderSlot(_ctx.$slots, "decreaseAction", normalizeProps(guardReactiveProps({ ...slotScope, decreaseCount })), () => [
                createVNode(unref(VaButton), mergeProps(decreaseIconProps.value, { ref: "decreaseButtonRef" }), null, 16)
              ])
            ], 32)
          ]),
          key: "1"
        },
        _ctx.$props.buttons ? {
          name: "append",
          fn: withCtx((slotScope) => [
            createBaseVNode("div", {
              class: "va-counter__append-wrapper",
              style: normalizeStyle({ marginLeft: marginComputed.value }),
              onMousedown: _cache[2] || (_cache[2] = withModifiers(
                //@ts-ignore
                (...args) => unref(focus) && unref(focus)(...args),
                ["prevent"]
              ))
            }, [
              renderSlot(_ctx.$slots, "increaseAction", normalizeProps(guardReactiveProps({ ...slotScope, increaseCount })), () => [
                createVNode(unref(VaButton), mergeProps({ class: "va-counter__button-increase" }, increaseButtonProps.value, { ref: "increaseButtonRef" }), null, 16)
              ])
            ], 36)
          ]),
          key: "2"
        } : {
          name: "appendInner",
          fn: withCtx((slotScope) => [
            createBaseVNode("div", {
              class: "va-counter__append-inner",
              onMousedown: _cache[3] || (_cache[3] = withModifiers(
                //@ts-ignore
                (...args) => unref(focus) && unref(focus)(...args),
                ["prevent"]
              ))
            }, [
              renderSlot(_ctx.$slots, "increaseAction", normalizeProps(guardReactiveProps({ ...slotScope, increaseCount })), () => [
                createVNode(unref(VaButton), mergeProps(increaseIconProps.value, { ref: "increaseButtonRef" }), null, 16)
              ])
            ], 32)
          ]),
          key: "3"
        },
        _ctx.$slots.content ? {
          name: "default",
          fn: withCtx((slotScope) => [
            createBaseVNode("div", {
              ref_key: "input",
              ref: input,
              tabindex: "0",
              class: "va-counter__content-wrapper"
            }, [
              renderSlot(_ctx.$slots, "content", normalizeProps(guardReactiveProps({ ...slotScope, value: Number(unref(valueComputed)) })))
            ], 512)
          ]),
          key: "4"
        } : void 0
      ]), 1040, ["class", "style", "focused", "error", "error-messages", "onKeydown"]);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-counter/VaCounter.js
var _style_039 = ":root,\n:host {\n  --va-counter-button-inner-padding: 6px;\n  --va-counter-button-outer-padding: 8px;\n}\n.va-counter {\n  --va-input-wrapper-width: var(--va-form-element-default-width-small);\n}\n.va-counter.va-input-wrapper {\n  min-width: unset;\n  flex: none;\n}\n.va-counter.va-input-wrapper .va-input-wrapper__field {\n  width: unset;\n}\n.va-counter .va-input-wrapper__field > *,\n.va-counter .va-input-wrapper__container > * {\n  margin-right: 0;\n}\n.va-counter.va-counter--input-square .va-input-wrapper__field {\n  border-radius: 0;\n  border-left: none;\n  border-right: none;\n}\n.va-counter.va-counter--input-square .va-counter__prepend-wrapper {\n  z-index: 1;\n}\n.va-counter.va-counter--input-square .va-counter__prepend-wrapper .va-counter__button-decrease {\n  border-top-right-radius: 0;\n  border-bottom-right-radius: 0;\n}\n.va-counter.va-counter--input-square .va-counter__prepend-wrapper .va-counter__button-decrease:not(.va-button--square) {\n  width: unset;\n}\n.va-counter.va-counter--input-square .va-counter__append-wrapper {\n  z-index: 1;\n}\n.va-counter.va-counter--input-square .va-counter__append-wrapper .va-counter__button-increase {\n  border-top-left-radius: 0;\n  border-bottom-left-radius: 0;\n}\n.va-counter.va-counter--input-square .va-counter__append-wrapper .va-counter__button-increase:not(.va-button--square) {\n  width: unset;\n}\n.va-counter .va-counter__prepend-wrapper .va-counter__button-decrease .va-button__content,\n.va-counter .va-counter__prepend-wrapper .va-counter__button-increase .va-button__content,\n.va-counter .va-counter__append-wrapper .va-counter__button-decrease .va-button__content,\n.va-counter .va-counter__append-wrapper .va-counter__button-increase .va-button__content {\n  padding: unset;\n}\n.va-counter .va-counter__content-wrapper {\n  width: 100%;\n  display: flex;\n  justify-content: center;\n}\n.va-counter .va-counter__content-wrapper:focus-visible {\n  outline: none;\n}\n.va-counter .va-input__content__input {\n  text-align: center;\n}\n.va-counter .va-input__content__input::-webkit-outer-spin-button, .va-counter .va-input__content__input::-webkit-inner-spin-button {\n  -webkit-appearance: none;\n  margin: 0;\n}\n.va-counter .va-input__content__input[type=number] {\n  -moz-appearance: textfield;\n}\n.va-counter .va-input-wrapper__field {\n  padding: 0;\n}\n.va-counter__prepend-inner, .va-counter__append-inner {\n  display: flex;\n  align-items: stretch;\n  height: 100%;\n  margin: 0 0.5rem;\n}";
var _VaCounter = _export_sfc(_sfc_main43, [["styles", [_style_039]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-counter/index.js
var VaCounter = withConfigTransport$1(_VaCounter);

// node_modules/vuestic-ui/dist/web-components/src/components/va-data-table/hooks/useCommonProps.js
var useCurrentPageProp = { currentPage: { type: Number } };
var useItemsProp = { items: { type: Array, default: () => [] } };
var useSelectableProp = { selectable: { type: Boolean, default: false } };
var useItemsTrackByProp = { itemsTrackBy: { type: [String, Function], default: "" } };

// node_modules/vuestic-ui/dist/web-components/src/components/va-data-table/hooks/useColumns.js
var sortingOptionsValidator = (options) => {
  const isAllowedOptionsLength = options.length === 2 || options.length === 3;
  const isAvailableOptions = options.every((option) => ["asc", "desc", null].includes(option));
  const isUniqueOptions = options.length === new Set(options).size;
  return isAllowedOptionsLength && isAvailableOptions && isUniqueOptions;
};
var useColumnsProps = {
  ...useItemsProp,
  columns: { type: Array, default: () => [] },
  sortingOptions: {
    type: Array,
    default: () => ["asc", "desc", null],
    validator: sortingOptionsValidator
  }
};
var buildTableColumn = (source, initialIndex, props) => {
  const input = typeof source === "string" ? { key: source } : source;
  const isValidOptions = input.sortingOptions ? sortingOptionsValidator(input.sortingOptions) : true;
  if (!isValidOptions) {
    warn(`The "sortingOptions" array in the column with "${input.key}" key is invalid. For this column, the "sortingOptions" value is taken as for the table: ${JSON.stringify(props.sortingOptions)}.`);
  }
  return {
    source,
    initialIndex,
    key: input.key,
    name: input.name || input.key,
    label: input.label || startCase$1(input.key),
    thTitle: input.thTitle || input.headerTitle || input.label || startCase$1(input.key),
    sortable: input.sortable || false,
    sortingFn: input.sortingFn,
    sortingOptions: isValidOptions && input.sortingOptions || props.sortingOptions,
    thAlign: input.thAlign || input.alignHead || "left",
    thVerticalAlign: input.thVerticalAlign || input.verticalAlignHead || "middle",
    tdAlign: input.tdAlign || input.align || "left",
    tdVerticalAlign: input.tdVerticalAlign || input.verticalAlign || "middle",
    width: input.width,
    tdClass: input.tdClass || input.classes,
    thClass: input.thClass || input.headerClasses,
    tdStyle: input.tdStyle || input.style,
    thStyle: input.thStyle || input.headerStyle
  };
};
var buildColumnsFromItems = (props) => {
  return Object.keys(merge$1({}, ...props.items)).map((item, index) => buildTableColumn(item, index, props));
};
var buildNormalizedColumns = (props) => {
  return props.columns.map((item, index) => buildTableColumn(item, index, props));
};
var useColumns = (props) => {
  const columnsComputed = computed(() => {
    if (props.columns.length === 0) {
      return buildColumnsFromItems(props);
    } else {
      return buildNormalizedColumns(props);
    }
  });
  return {
    columnsComputed
  };
};

// node_modules/vuestic-ui/dist/web-components/src/composables/useThrottle.js
var useThrottleProps = {
  delay: {
    type: Number,
    default: 0,
    validator: (value) => value >= 0
  }
};
function useThrottleFunction(fn, props) {
  const delay = toRef(props, "delay") ?? 0;
  const isThrottled = ref(true);
  let lastCallResult = void 0;
  return function(...args) {
    const invoke = () => fn.apply(this, args);
    if (!unref(delay)) {
      return invoke();
    }
    if (isThrottled.value) {
      isThrottled.value = false;
      setTimeout(() => isThrottled.value = true, unref(delay));
      lastCallResult = invoke();
    }
    return lastCallResult;
  };
}
function useThrottleValue(value, props) {
  const delay = toRef(props, "delay") ?? 0;
  if (!unref(delay)) {
    return value;
  }
  const isThrottled = ref(true);
  const previousCallValue = ref();
  const previousReturnedValue = ref();
  const currentCallValue = ref();
  watch(value, () => {
    previousCallValue.value = value.value;
    const lastCallValue = setTimeout(() => {
      currentCallValue.value = previousCallValue.value;
    }, unref(delay));
    if (isThrottled.value) {
      isThrottled.value = false;
      currentCallValue.value = value.value;
      previousReturnedValue.value = value.value;
      clearTimeout(lastCallValue);
      setTimeout(() => isThrottled.value = true, unref(delay));
    } else {
      currentCallValue.value = previousReturnedValue.value;
    }
  }, { immediate: true });
  return currentCallValue;
}

// node_modules/vuestic-ui/dist/web-components/src/components/va-data-table/hooks/usePaginatedRows.js
var usePaginatedRowsProps = {
  ...useThrottleProps,
  ...useCurrentPageProp,
  perPage: { type: Number }
};
var usePaginatedRows = (sortedRows, props) => {
  const paginatedRows = computed(() => {
    if (!props.perPage || props.perPage < 0) {
      return sortedRows.value;
    }
    if (!props.currentPage || props.currentPage < 0) {
      return sortedRows.value.slice(0, props.perPage);
    }
    const pageStartIndex = props.perPage * (props.currentPage - 1);
    return sortedRows.value.slice(pageStartIndex, pageStartIndex + props.perPage);
  });
  const paginatedRowsThrottled = useThrottleValue(paginatedRows, props);
  return {
    paginatedRows: paginatedRowsThrottled
  };
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-data-table/hooks/useRows.js
var getItemKey = (source, itemsTrackBy) => typeof itemsTrackBy === "function" ? itemsTrackBy(source) : getValueByPath(source, itemsTrackBy) || source;
var useRowsProps = {
  ...useItemsProp,
  ...useItemsTrackByProp
};
var buildTableCell = (rowIndex, rowKey, rowData, column) => {
  var _a2;
  const source = getValueByPath(rowData, column.key);
  return {
    rowIndex,
    rowKey,
    rowData,
    column,
    source,
    value: ((_a2 = source == null ? void 0 : source.toString) == null ? void 0 : _a2.call(source)) || ""
  };
};
var buildTableRow = (source, initialIndex, itemsTrackBy, columns) => {
  const itemKey = getItemKey(source, itemsTrackBy);
  return {
    initialIndex,
    itemKey,
    source,
    cells: columns.map((column) => buildTableCell(initialIndex, itemKey, source, column)),
    rowData: source
  };
};
var useRows = (columns, props) => {
  const expandableRows = ref({});
  const rowsComputed = computed(() => props.items.map((rawItem, index) => ({
    ...buildTableRow(rawItem, index, props.itemsTrackBy, columns.value),
    toggleRowDetails: (show) => {
      if (typeof show === "boolean") {
        expandableRows.value[index] = show;
      } else {
        expandableRows.value[index] = !expandableRows.value[index];
      }
    },
    isExpandableRowVisible: !!expandableRows.value[index]
  })));
  return {
    rowsComputed
  };
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-data-table/hooks/useSelectableRow.js
var useSelectableProps2 = {
  ...useSelectableProp,
  ...useItemsTrackByProp,
  modelValue: { type: Array },
  selectMode: { type: String, default: "multiple" }
};
var useSelectableRow = (paginatedRows, props, emit) => {
  const selectedItemsFallback = ref([]);
  const selectedItemsSync = computed({
    get() {
      if (props.modelValue === void 0) {
        return selectedItemsFallback.value;
      } else {
        return props.modelValue;
      }
    },
    set(modelValue) {
      if (props.modelValue === void 0) {
        selectedItemsFallback.value = modelValue;
      }
      emit("update:modelValue", modelValue);
    }
  });
  const prevSelectedRowIndex = ref(-1);
  watch(() => props.selectMode, (newSelectMode, oldSelectMode) => {
    if (newSelectMode === "single" && oldSelectMode === "multiple") {
      selectedItemsSync.value = [];
      setPrevSelectedRowIndex(-1);
    }
  });
  watch(paginatedRows, () => {
    setPrevSelectedRowIndex(-1);
  });
  watch(selectedItemsSync, (currentSelectedItems, previousSelectedItems = []) => {
    emit("selectionChange", {
      currentSelectedItems,
      previousSelectedItems
    });
  }, { immediate: true });
  const getKey = (source) => getItemKey(source, props.itemsTrackBy);
  const noRowsSelected = computed(() => !paginatedRows.value.some(({ source }) => selectedItemsSync.value.includes(getKey(source))));
  const allRowsSelected = computed(() => {
    if (paginatedRows.value.length === 0) {
      return false;
    }
    return paginatedRows.value.every(({ source }) => selectedItemsSync.value.includes(getKey(source)));
  });
  const severalRowsSelected = computed(() => !noRowsSelected.value && !allRowsSelected.value);
  function isRowSelected(row) {
    return selectedItemsSync.value.includes(getKey(row.source));
  }
  function selectAllRows() {
    selectedItemsSync.value = [.../* @__PURE__ */ new Set([
      ...selectedItemsSync.value,
      ...paginatedRows.value.map((row) => getKey(row.source))
    ])];
  }
  function unselectAllRows() {
    const paginatedRowsKeys = paginatedRows.value.map((row) => getKey(row.source));
    selectedItemsSync.value = selectedItemsSync.value.filter((item) => !paginatedRowsKeys.includes(item));
  }
  function selectRow(row) {
    selectedItemsSync.value = [...selectedItemsSync.value, getKey(row.source)];
  }
  function selectOnlyRow(row) {
    selectedItemsSync.value = [getKey(row.source)];
  }
  function unselectRow(row) {
    const index = selectedItemsSync.value.findIndex((item) => item === getKey(row.source));
    selectedItemsSync.value = [
      ...selectedItemsSync.value.slice(0, index),
      ...selectedItemsSync.value.slice(index + 1)
    ];
  }
  function setPrevSelectedRowIndex(rowInitialIndex) {
    if (rowInitialIndex === -1) {
      prevSelectedRowIndex.value = -1;
    } else {
      const prevSelectedRow = paginatedRows.value.find((row) => row.initialIndex === rowInitialIndex);
      prevSelectedRow ? prevSelectedRowIndex.value = paginatedRows.value.indexOf(prevSelectedRow) : prevSelectedRowIndex.value = -1;
    }
  }
  function getRowsToSelect(targetIndex) {
    let start;
    let end;
    if (isRowSelected(paginatedRows.value[prevSelectedRowIndex.value])) {
      start = Math.min(prevSelectedRowIndex.value, targetIndex);
      end = Math.max(prevSelectedRowIndex.value, targetIndex);
    } else {
      start = Math.min(prevSelectedRowIndex.value + 1, targetIndex);
      end = Math.max(prevSelectedRowIndex.value - 1, targetIndex);
    }
    return paginatedRows.value.slice(start, end + 1);
  }
  function mergeSelection(rowsToSelect) {
    const rowsToSelectedItems = rowsToSelect.map((row) => getKey(row.source));
    if (noRowsSelected.value) {
      selectedItemsSync.value = rowsToSelectedItems;
      return;
    }
    const isInternalSelection = rowsToSelectedItems.every((item) => selectedItemsSync.value.includes(item));
    if (isInternalSelection) {
      selectedItemsSync.value = selectedItemsSync.value.filter((item) => !rowsToSelectedItems.includes(item));
      return;
    }
    selectedItemsSync.value = [.../* @__PURE__ */ new Set([
      ...selectedItemsSync.value,
      ...rowsToSelectedItems
    ])];
  }
  function toggleRowSelection(row) {
    if (!props.selectable) {
      return;
    }
    if (isRowSelected(row)) {
      unselectRow(row);
      props.selectMode === "single" ? setPrevSelectedRowIndex(-1) : setPrevSelectedRowIndex(row.initialIndex);
    } else {
      props.selectMode === "single" ? selectOnlyRow(row) : selectRow(row);
      setPrevSelectedRowIndex(row.initialIndex);
    }
  }
  function ctrlSelectRow(row) {
    if (!props.selectable) {
      return;
    }
    toggleRowSelection(row);
  }
  function shiftSelectRows(row) {
    if (!props.selectable) {
      return;
    }
    if (props.selectMode === "single" || prevSelectedRowIndex.value === -1) {
      return toggleRowSelection(row);
    }
    const targetIndex = paginatedRows.value.indexOf(row);
    mergeSelection(getRowsToSelect(targetIndex));
    setPrevSelectedRowIndex(-1);
  }
  function toggleBulkSelection() {
    if (allRowsSelected.value) {
      unselectAllRows();
    } else {
      selectAllRows();
    }
    setPrevSelectedRowIndex(-1);
  }
  return {
    ctrlSelectRow,
    shiftSelectRows,
    toggleRowSelection,
    toggleBulkSelection,
    isRowSelected,
    noRowsSelected,
    severalRowsSelected,
    allRowsSelected
  };
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-data-table/hooks/useStylable.js
var prefix = "--va-data-table";
var isFunction2 = (val) => typeof val === "function";
var useStylableProps = {
  ...useSelectableProp,
  selectedColor: { type: String, default: "primary" },
  allowFooterSorting: { type: Boolean, default: false },
  stickyHeader: { type: Boolean, default: false },
  stickyFooter: { type: Boolean, default: false },
  height: { type: [String, Number] }
};
var getClass = (classes) => isFunction2(classes) ? classes() : classes;
var getStyle = (styles) => isFunction2(styles) ? styles() : styles;
var useStylable = (props) => {
  const { getColor, getFocusColor: getFocusColor2, getHoverColor: getHoverColor2 } = useColors();
  const color = computed(() => getColor(props.selectedColor));
  const CSSVariables = computed(() => ({
    hoverColor: getHoverColor2(color.value),
    selectedColor: props.selectable ? getFocusColor2(color.value) : void 0,
    tableHeight: props.height ? safeCSSLength(props.height) : "var(--va-data-table-height)",
    theadBg: props.stickyHeader ? "var(--va-data-table-thead-background, var(--va-data-table-header-background))" : "var(--va-data-table-thead-background)",
    tfootBg: props.stickyFooter ? "var(--va-data-table-tfoot-background, var(--va-data-table-header-background))" : "var(--va-data-table-tfoot-background)"
  }));
  const getHeaderCSSVariables = (column) => ({
    [`${prefix}-width`]: column.width && safeCSSLength(column.width),
    [`${prefix}-align`]: column.thAlign,
    [`${prefix}-vertical-align`]: column.thVerticalAlign,
    [`${prefix}-cursor`]: column.sortable ? "pointer" : "default"
  });
  const getCellCSSVariables = (cell) => ({
    [`${prefix}-align`]: cell.column.tdAlign,
    [`${prefix}-vertical-align`]: cell.column.tdVerticalAlign
  });
  const getFooterCSSVariables = (column) => ({
    [`${prefix}-align`]: column.thAlign,
    [`${prefix}-vertical-align`]: column.thVerticalAlign,
    [`${prefix}-cursor`]: props.allowFooterSorting && column.sortable ? "pointer" : "default"
  });
  return {
    CSSVariables,
    getHeaderCSSVariables,
    getCellCSSVariables,
    getFooterCSSVariables,
    getClass,
    getStyle
  };
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-data-table/hooks/useBinding.js
var isFunction3 = (val) => typeof val === "function";
var isObject4 = (val) => val !== null && typeof val === "object";
var useBindingProps = {
  rowBind: { type: null },
  cellBind: { type: null }
};
var useBinding = (props) => {
  const getRowBind = (row) => isFunction3(props.rowBind) ? props.rowBind(row.source, row.initialIndex) : isObject4(props.rowBind) ? props.rowBind : {};
  const getCellBind = (cell, row) => isFunction3(props.cellBind) ? props.cellBind(cell.source, row.source, cell.column, row.initialIndex) : isObject4(props.cellBind) ? props.cellBind : {};
  return {
    getRowBind,
    getCellBind
  };
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-data-table/hooks/useAnimationName.js
var useAnimationNameProps = {
  ...useCurrentPageProp,
  animated: { type: Boolean, default: true }
};
var useAnimationName = (props, rows) => {
  const animationType = ref("shuffle");
  const animationName = computed(() => props.animated ? `table-transition-${animationType.value}` : "");
  const oldRowsLength = ref(rows.value.length);
  const isDifferentRowLength = computed(() => rows.value.length !== oldRowsLength.value);
  watch(rows, (newRows, oldRows) => {
    const hasRows = !!(newRows.length && oldRows.length);
    animationType.value = newRows.length > 50 || isDifferentRowLength.value && hasRows ? "fade" : "shuffle";
    oldRowsLength.value = newRows.length;
  });
  watch(() => props.currentPage, () => {
    if (!isDifferentRowLength.value) {
      animationType.value = "shuffle";
    }
  });
  return animationName;
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-data-table/hooks/useFilterable.js
var useFilterableProps = {
  ...useThrottleProps,
  filter: { type: String, default: "" },
  filterMethod: { type: Function }
};
var useFilterable = (rawRows, props, emit) => {
  const filteredRows = computed(() => {
    if (!rawRows.value.length) {
      return rawRows.value;
    }
    if (props.filter === "" && !props.filterMethod) {
      return rawRows.value;
    }
    return rawRows.value.filter(
      (row) => row.cells.some((cell) => {
        if (typeof props.filterMethod === "function") {
          return props.filterMethod(cell.source, cell);
        }
        const cellRegex = new RegExp(props.filter, "i");
        return cellRegex.test(cell.value);
      })
    );
  });
  const filteredRowsThrottled = useThrottleValue(filteredRows, props);
  watch(filteredRowsThrottled, () => {
    emit("filtered", {
      items: filteredRowsThrottled.value.map((row) => row.source),
      itemsIndexes: filteredRowsThrottled.value.map((row) => row.initialIndex)
    });
  });
  if (filteredRows.value.length !== rawRows.value.length) {
    emit("filtered", {
      items: filteredRows.value.map((row) => row.source),
      itemsIndexes: filteredRows.value.map((row) => row.initialIndex)
    });
  }
  return {
    filteredRows: filteredRowsThrottled
  };
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-data-table/hooks/useSortable.js
var useSortableProps = {
  ...useThrottleProps,
  sortBy: { type: String },
  columnSorted: { type: Object },
  sortingOrder: { type: [String, null] },
  disableClientSideSorting: { type: Boolean, default: false }
};
var useSortable = (columns, filteredRows, props, emit) => {
  const sortByFallback = ref("");
  const sortBySync = computed({
    get() {
      if (props.sortBy === void 0) {
        return sortByFallback.value;
      } else {
        return props.sortBy;
      }
    },
    set(value) {
      if (props.sortBy === void 0) {
        sortByFallback.value = value;
      }
      emit("update:sortBy", value);
    }
  });
  const sortingOrderFallback = ref(null);
  const sortingOrderSync = computed({
    get() {
      if (props.sortingOrder === void 0) {
        return sortingOrderFallback.value;
      } else {
        return props.sortingOrder;
      }
    },
    set(value) {
      if (props.sortingOrder === void 0) {
        sortingOrderFallback.value = value;
      }
      emit("update:sortingOrder", value);
    }
  });
  const sortedRows = computed(() => {
    if (props.disableClientSideSorting) {
      return filteredRows.value;
    }
    if (filteredRows.value.length <= 1) {
      return filteredRows.value;
    }
    const columnIndex = columns.value.findIndex(
      ({ name, sortable }) => sortBySync.value === name && sortable
    );
    const column = columns.value[columnIndex];
    if (!column) {
      return filteredRows.value;
    }
    const sortingOrderRatio = sortingOrderSync.value === "desc" ? -1 : 1;
    return [...filteredRows.value].sort((a, b) => {
      if (sortingOrderSync.value === null) {
        return a.initialIndex - b.initialIndex;
      } else {
        const firstValue = a.cells[columnIndex].value;
        const secondValue = b.cells[columnIndex].value;
        const firstSource = a.cells[columnIndex].source;
        const secondSource = b.cells[columnIndex].source;
        return sortingOrderRatio * (typeof column.sortingFn === "function" ? column.sortingFn(firstSource, secondSource) : firstValue.localeCompare(secondValue));
      }
    });
  });
  watch(sortedRows, () => {
    emit("sorted", {
      sortBy: sortBySync.value,
      sortingOrder: sortingOrderSync.value,
      items: sortedRows.value.map((row) => row.source),
      itemsIndexes: sortedRows.value.map((row) => row.initialIndex)
    });
  });
  const getNextSortingOptionsValue = (value, options) => {
    const index = options.findIndex((sortingValue) => sortingValue === value);
    return index !== -1 ? options[(index + 1) % options.length] : options[0];
  };
  function toggleSorting(column) {
    let value;
    if (column.name === sortBySync.value) {
      value = getNextSortingOptionsValue(sortingOrderSync.value, column.sortingOptions);
    } else {
      sortBySync.value = column.name;
      value = column.sortingOptions[0];
    }
    sortingOrderSync.value = value;
    emit("columnSorted", { columnName: column.name, value, column });
  }
  const toggleSortingThrottled = useThrottleFunction(toggleSorting, props);
  const sortingOrderIconName = computed(() => {
    return sortingOrderSync.value === "asc" ? "va-arrow-up" : sortingOrderSync.value === "desc" ? "va-arrow-down" : "unfold_more";
  });
  return {
    sortBySync,
    sortingOrderSync,
    toggleSorting: toggleSortingThrottled,
    sortedRows,
    sortingOrderIconName
  };
};

// node_modules/vuestic-ui/dist/web-components/src/composables/useElementRef.js
var unrefElement = (el) => {
  const e = unref(el);
  return unwrapEl(e);
};
var useElementRef = () => {
  const el = shallowRef();
  return computed({
    get() {
      return unrefElement(el);
    },
    set(node) {
      el.value = node;
    }
  });
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-data-table/hooks/useTableScroll.js
var useTableScrollProps = {
  scrollTopMargin: { type: Number, default: 0 },
  scrollBottomMargin: { type: Number, default: 0 }
};
var useTableScrollEmits = ["scroll:top", "scroll:bottom"];
var useTableScroll = (props, emit) => {
  var _a2;
  const vNodeProps = (_a2 = getCurrentInstance()) == null ? void 0 : _a2.vnode.props;
  const doRenderTopTrigger = (vNodeProps == null ? void 0 : vNodeProps["onScroll:top"]) !== void 0;
  const doRenderBottomTrigger = (vNodeProps == null ? void 0 : vNodeProps["onScroll:bottom"]) !== void 0;
  const scrollContainer = useElementRef();
  const topTrigger = useElementRef();
  const bottomTrigger = useElementRef();
  const isObservable = computed(() => !!scrollContainer.value);
  const intersectionHandler = (entries) => {
    entries.forEach((entry) => {
      if (entry.isIntersecting) {
        entry.target === topTrigger.value ? emit("scroll:top") : emit("scroll:bottom");
      }
    });
  };
  const targets = computed(() => {
    const list = [];
    if (isObservable.value) {
      topTrigger.value && list.push(topTrigger.value);
      bottomTrigger.value && list.push(bottomTrigger.value);
    }
    return list;
  });
  const options = computed(() => ({
    root: scrollContainer.value,
    rootMargin: `${props.scrollTopMargin ?? 0}px 0px ${props.scrollBottomMargin ?? 0}px 0px`
  }));
  useIntersectionObserver(intersectionHandler, options, targets);
  return {
    scrollContainer,
    topTrigger,
    bottomTrigger,
    doRenderTopTrigger,
    doRenderBottomTrigger
  };
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-data-table/components/VaDataTableThRow.vue_vue_type_script_setup_true_lang.js
var _hoisted_125 = { class: "va-data-table__table-tr" };
var _hoisted_211 = {
  key: 0,
  scope: "col",
  class: "va-data-table__table-th va-data-table__table-cell-select"
};
var _hoisted_37 = ["title", "onClick", "onKeydown"];
var _hoisted_46 = { class: "va-data-table__table-th-wrapper" };
var _hoisted_55 = { key: 0 };
var _sfc_main44 = defineComponent({
  ...{
    name: "VaDataTableThRow"
  },
  __name: "VaDataTableThRow",
  props: {
    ...useStylableProps,
    selectMode: { type: String, default: "multiple" },
    allRowsSelected: { type: Boolean, default: false },
    severalRowsSelected: { type: Boolean, default: false },
    columns: { type: Array, required: true },
    isFooter: { type: Boolean, default: false },
    sortBySync: { type: String, required: true },
    sortingOrderIconName: { type: String, required: true },
    sortingOrderSync: { type: String, default: null },
    ariaSelectAllRowsLabel: { type: String, default: "$t:selectAllRows" },
    ariaSortColumnByLabel: { type: String, default: "$t:sortColumnBy" }
  },
  emits: [
    "toggleBulkSelection",
    "toggleSorting"
  ],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const { t, tp } = useTranslation();
    const {
      getFooterCSSVariables,
      getHeaderCSSVariables,
      getClass: getClass2,
      getStyle: getStyle2
    } = useStylable(props);
    const getAriaAttributes = (column) => {
      const ariaSort = props.sortingOrderSync && props.sortBySync === column.name ? props.sortingOrderSync === "asc" ? "ascending" : "descending" : "none";
      const ariaLabel = column.sortable ? tp(props.ariaSortColumnByLabel, { name: column.label }) : void 0;
      return {
        "aria-sort": ariaSort,
        "aria-label": ariaLabel
      };
    };
    const sortByColumn = (column) => {
      if (props.isFooter && !props.allowFooterSorting || !column.sortable) {
        return;
      }
      emit("toggleSorting", column);
    };
    const toggleBulkSelection = () => emit("toggleBulkSelection");
    const getColumnStyles = (column) => {
      return [
        column.width ? { minWidth: column.width, maxWidth: column.width } : {},
        props.isFooter ? getFooterCSSVariables(column) : getHeaderCSSVariables(column),
        getStyle2(column.thStyle)
      ];
    };
    const slotNameComputed = computed(() => props.isFooter ? "footer" : "header");
    const multiplySelectAvailable = computed(() => props.selectMode === "multiple");
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("tr", _hoisted_125, [
        _ctx.$props.selectable ? (openBlock(), createElementBlock("th", _hoisted_211, [
          multiplySelectAvailable.value ? (openBlock(), createBlock(unref(VaCheckbox), {
            key: 0,
            class: "va-data-table__table-cell-checkbox",
            "model-value": _ctx.$props.severalRowsSelected ? "idl" : _ctx.$props.allRowsSelected,
            "aria-label": unref(tp)(_ctx.$props.ariaSelectAllRowsLabel),
            "true-value": true,
            "false-value": false,
            color: _ctx.$props.selectedColor,
            "indeterminate-value": "idl",
            indeterminate: "",
            "onUpdate:modelValue": toggleBulkSelection
          }, null, 8, ["model-value", "aria-label", "color"])) : createCommentVNode("", true)
        ])) : createCommentVNode("", true),
        (openBlock(true), createElementBlock(Fragment, null, renderList(__props.columns, (column) => {
          return openBlock(), createElementBlock("th", mergeProps({
            key: column.name,
            scope: "col",
            class: ["va-data-table__table-th", unref(getClass2)(column.thClass)],
            title: column.thTitle,
            style: getColumnStyles(column)
          }, getAriaAttributes(column), {
            onClick: withModifiers(($event) => sortByColumn(column), ["exact"]),
            onKeydown: withKeys(withModifiers(($event) => sortByColumn(column), ["stop"]), ["enter"])
          }), [
            createBaseVNode("div", _hoisted_46, [
              `${slotNameComputed.value}(${column.name})` in _ctx.$slots ? (openBlock(), createElementBlock("span", _hoisted_55, [
                renderSlot(_ctx.$slots, `${slotNameComputed.value}(${column.name})`, normalizeProps(guardReactiveProps({ label: column.label, key: column.key })))
              ])) : renderSlot(_ctx.$slots, slotNameComputed.value, normalizeProps(mergeProps({ key: 1 }, { label: column.label, key: column.key })), () => [
                createBaseVNode("span", null, toDisplayString(column.label), 1)
              ]),
              column.sortable ? (openBlock(), createBlock(unref(VaIcon), {
                key: 2,
                class: normalizeClass(["va-data-table__table-th-sorting-icon", { active: __props.sortBySync === column.name && __props.sortingOrderSync !== null }]),
                size: "small",
                role: column.sortable ? "button" : void 0,
                tabindex: column.sortable ? 0 : -1,
                name: __props.sortingOrderIconName,
                onSelectstart: withModifiers(() => {
                }, ["prevent"])
              }, null, 8, ["class", "role", "tabindex", "name"])) : createCommentVNode("", true)
            ])
          ], 16, _hoisted_37);
        }), 128))
      ]);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-data-table/components/VaDataTableThRow.js
var _style_040 = '.va-data-table {\n  --va-data-table-cell-padding: 0.625rem;\n  --va-data-table-thead-line-height: 1.6;\n  --va-data-table-thead-font-size: 0.625rem;\n  --va-data-table-thead-font-weight: 700;\n  --va-data-table-thead-text-transform: uppercase;\n  --va-data-table-thead-letter-spacing: 0.6px;\n  --va-data-table-thead-border: 1px solid var(--va-background-border);\n  --va-data-table-thead-border-top-shadow: inset 0 1px 0 0 var(--va-background-border);\n  --va-data-table-thead-border-bottom-shadow: inset 0 -1px 0 0 var(--va-background-border);\n  --va-data-table-height: unset;\n  --va-data-table-max-height: unset;\n  --va-data-table-thead-color: currentColor;\n  --va-data-table-tfoot-color: currentColor;\n  --va-data-table-header-background: var(--va-background-primary);\n  /* Hover */\n  --va-data-table-hover-th-opacity: 0.3;\n  /* Striped */\n  --va-data-table-striped-tr-background-color: var(--va-background-element);\n  --va-data-table-striped-tr-opacity: 1;\n  /* Selectable */\n  --va-data-table-selectable-tr-cursor: pointer;\n  --va-data-table-selectable-cell-width: 55px;\n  --va-data-table-selectable-cell-vertical-align: middle;\n  --va-data-table-selectable-cell-text-align: center;\n  /* No-data */\n  --va-data-table-no-data-text-align: center;\n  --va-data-table-no-data-vertical-align: middle;\n  /* Animated */\n  --va-data-table-transition: var(--va-transition);\n  /* Grid */\n  --va-data-table-grid-tbody-gap: 0.5rem;\n  --va-data-table-grid-tbody-margin-top: 1rem;\n  --va-data-table-grid-tr-padding: 1rem;\n  --va-data-table-grid-tr-border-radius: 0.5rem;\n  --va-data-table-grid-tr-border: 1px solid var(--va-background-border);\n  --va-data-table-grid-tr-header-font-weight: 600;\n  --va-data-table-grid-tr-header-color: var(--va-text-primary);\n}\n.va-data-table .va-data-table__table .va-data-table__table-th {\n  padding: var(--va-data-table-cell-padding);\n  width: var(--va-data-table-width);\n  min-width: var(--va-data-table-width);\n  text-align: var(--va-data-table-align);\n  vertical-align: var(--va-data-table-vertical-align);\n  font-size: var(--va-data-table-thead-font-size);\n  line-height: var(--va-data-table-thead-line-height);\n  font-weight: var(--va-data-table-thead-font-weight);\n  text-transform: var(--va-data-table-thead-text-transform);\n  letter-spacing: var(--va-data-table-thead-letter-spacing);\n  cursor: var(--va-data-table-cursor);\n}\n.va-data-table .va-data-table__table .va-data-table__table-th .va-data-table__table-th-wrapper {\n  display: flex;\n  align-items: center;\n}\n.va-data-table .va-data-table__table .va-data-table__table-th .va-data-table__table-th-wrapper:focus-visible {\n  outline: 2px solid var(--va-focus) !important;\n  border-radius: "inherit";\n  outline-offset: 2px;\n}\n.va-data-table .va-data-table__table .va-data-table__table-th .va-data-table__table-th-sorting-icon {\n  opacity: 0;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n          user-select: none;\n  pointer-events: none;\n}\n.va-data-table .va-data-table__table .va-data-table__table-th .va-data-table__table-th-sorting-icon.active {\n  opacity: 1;\n  pointer-events: initial;\n}\n.va-data-table .va-data-table__table .va-data-table__table-th .va-data-table__table-th-sorting-icon:focus-visible {\n  opacity: 1;\n}\n.va-data-table .va-data-table__table .va-data-table__table-th span {\n  flex-grow: 1;\n}\n.va-data-table .va-data-table__table .va-data-table__table-th:hover .va-data-table__table-th-sorting-icon:not(.active, :focus-visible) {\n  opacity: var(--va-data-table-hover-th-opacity);\n}';
var _VaDataTableThRow = _export_sfc(_sfc_main44, [["styles", [_style_040]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-data-table/components/index.js
var VaDataTableThRow = withConfigTransport$1(_VaDataTableThRow);

// node_modules/vuestic-ui/dist/web-components/src/components/va-virtual-scroller/useVirtualScrollerSizes.js
var { isParsablePositiveMeasure, parseSizeValue: parseSizeValue2 } = useParsableMeasure();
var validateSizeProp = (v, propName) => {
  const isProperValue = isParsablePositiveMeasure(v);
  !isProperValue && warn(`[va-virtual-scroller] ${propName} should be number or parsable int greater or equal to 0. Provided: ${v}.`);
  return isProperValue;
};
var useVirtualScrollerSizesProps = {
  horizontal: { type: Boolean, default: false },
  itemSize: {
    type: [Number, String],
    default: 0,
    validator: (v) => {
      return validateSizeProp(v, "itemSize");
    }
  },
  wrapperSize: {
    type: [Number, String],
    default: 100,
    validator: (v) => {
      return v === "auto" || validateSizeProp(v, "wrapperSize");
    }
  }
};
var useVirtualScrollerSizes = (props, scrollPosition) => {
  const list = shallowRef();
  const wrapper = shallowRef();
  const clientSizeMeasure = computed(() => props.horizontal ? "clientWidth" : "clientHeight");
  const wrapperSize = computed(() => {
    var _a2;
    if (props.wrapperSize === "auto") {
      return ((_a2 = wrapper.value) == null ? void 0 : _a2[clientSizeMeasure.value]) || 0;
    }
    return parseSizeValue2(props.wrapperSize, pageFontSize);
  });
  const pageFontSize = ref(16);
  const handleWindowResize = () => {
    pageFontSize.value = parseFloat(getComputedStyle(document.documentElement).fontSize);
    calcAverageItemsSize();
  };
  useEvent("resize", handleWindowResize, true);
  const itemSizeCalculated = ref(0);
  const calcAverageItemsSize = () => {
    if (!list.value) {
      return;
    }
    const sizes = [];
    const itemsList = list.value.children;
    const itemsAmount = itemsList.length;
    for (let i = 0; i < itemsAmount; i++) {
      const currentChild = list.value.children.item(i);
      currentChild && sizes.push(currentChild[clientSizeMeasure.value]);
    }
    itemSizeCalculated.value = itemsAmount ? Math.trunc(sizes.reduce((acc, el) => acc + el, 0) / (itemsAmount - 1)) : 0;
  };
  const instance = getCurrentInstance();
  onMounted(() => {
    var _a2, _b;
    if (!list.value) {
      list.value = (_b = (_a2 = instance == null ? void 0 : instance.parent) == null ? void 0 : _a2.refs) == null ? void 0 : _b.list;
    }
    calcAverageItemsSize();
  });
  watch(scrollPosition, calcAverageItemsSize);
  watch(wrapperSize, calcAverageItemsSize);
  let oldItemSize = 0;
  const itemSize = computed(() => {
    const sizeParsed = parseSizeValue2(props.itemSize, pageFontSize);
    const result = Math.max(sizeParsed, itemSizeCalculated.value, 1);
    const diff = Math.abs(oldItemSize / result * 100 - 100);
    if (diff > 5 || oldItemSize === 0) {
      oldItemSize = result;
      return result;
    }
    return oldItemSize;
  });
  return { list, wrapper, itemSize, wrapperSize };
};

// node_modules/vuestic-ui/dist/web-components/src/composables/useTrackBy.js
var useTrackByProps = {
  trackBy: {
    type: [String, Number, Function],
    default: ""
  }
};
var useTrackBy = (props) => {
  const getKey = (item, index, defaultValue) => {
    if (props.trackBy && item && typeof item === "object" && !isFunction$4(props.trackBy)) {
      const isArrayItem = Array.isArray(item);
      let key;
      if (isArrayItem && !isNaN(+props.trackBy)) {
        key = item[+props.trackBy];
      }
      if (!isArrayItem) {
        key = item[props.trackBy];
      }
      if (key || key === 0) {
        return key;
      }
      warn(`${isArrayItem ? "Index" : "Key"} '${props.trackBy}' wasn't found in provided ${isArrayItem ? "array" : "object"}: `, item);
    }
    if (isFunction$4(props.trackBy)) {
      return props.trackBy(item);
    }
    return defaultValue;
  };
  return { getKey };
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-virtual-scroller/VaVirtualScroller.vue_vue_type_script_setup_true_generic_Item%20%3D%20unknown_lang.js
var _sfc_main45 = defineComponent({
  ...{
    name: "VaVirtualScroller"
  },
  __name: "VaVirtualScroller",
  props: {
    ...useTrackByProps,
    ...useVirtualScrollerSizesProps,
    items: { type: Array, default: () => [] },
    bench: { type: Number, default: 10, validator: (v) => v >= 0 },
    disabled: { type: Boolean, default: false },
    table: { type: Boolean, default: false }
  },
  emits: ["scroll:bottom"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const listScrollPosition = ref(0);
    const scrollDirection = computed(() => props.horizontal ? "scrollLeft" : "scrollTop");
    const handleScroll = () => {
      if (!wrapper.value) {
        return;
      }
      listScrollPosition.value = wrapper.value[scrollDirection.value];
    };
    if (!props.disabled) {
      useEvent("scroll", handleScroll, true);
    }
    const { list, wrapper, itemSize, wrapperSize } = useVirtualScrollerSizes(props, listScrollPosition);
    const { getKey } = useTrackBy(props);
    const uniqueKey = (item, index, defaultValue) => getKey(item, index, defaultValue);
    watch(listScrollPosition, (newValue) => {
      if (newValue + wrapperSize.value === containerSize.value) {
        emit("scroll:bottom");
      }
    });
    const renderStartIndex = computed(() => {
      return Math.max(0, Math.floor(listScrollPosition.value / itemSize.value) - props.bench);
    });
    const renderItemsAmount = computed(() => {
      var _a2;
      if (!((_a2 = props.items) == null ? void 0 : _a2.length)) {
        return 0;
      }
      return props.disabled ? props.items.length : Math.min(props.items.length - renderStartIndex.value, Math.ceil(wrapperSize.value / itemSize.value) + props.bench * 2);
    });
    const renderEndIndex = computed(() => renderStartIndex.value + renderItemsAmount.value);
    const renderBuffer = computed(() => {
      var _a2;
      if (!((_a2 = props.items) == null ? void 0 : _a2.length)) {
        return [];
      }
      return props.items.slice(renderStartIndex.value, renderEndIndex.value);
    });
    const sizeAttribute = computed(() => props.horizontal ? "width" : "height");
    const isDisabledVirtualTable = computed(() => props.table && props.disabled);
    const wrapperStyleComputed = computed(() => ({
      [sizeAttribute.value]: isDisabledVirtualTable.value || !wrapperSize.value ? void 0 : `${wrapperSize.value}px`
    }));
    const wrapperClassComputed = useBem("va-virtual-scroller", () => ({
      ...pick$1(props, ["horizontal"])
    }));
    const containerSize = computed(() => {
      var _a2;
      return (((_a2 = props.items) == null ? void 0 : _a2.length) ?? 0) * itemSize.value;
    });
    const containerStyleComputed = computed(() => ({
      [sizeAttribute.value]: isDisabledVirtualTable.value ? void 0 : `${containerSize.value}px`
    }));
    const currentListOffset = computed(() => renderStartIndex.value * itemSize.value);
    const listStyleComputed = computed(() => ({
      transform: `translate${props.horizontal ? "X" : "Y"}(${currentListOffset.value}px)`
    }));
    const scrollToAttribute = computed(() => props.horizontal ? "left" : "top");
    const virtualScrollTo = (index) => {
      var _a2;
      if (!index && index !== 0) {
        return;
      }
      (_a2 = wrapper.value) == null ? void 0 : _a2.scrollTo({ [scrollToAttribute.value]: index * itemSize.value });
    };
    __expose({
      scrollToAttribute,
      virtualScrollTo
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        ref_key: "wrapper",
        ref: wrapper,
        class: normalizeClass(["va-virtual-scroller", unref(wrapperClassComputed)]),
        style: normalizeStyle(wrapperStyleComputed.value)
      }, [
        renderSlot(_ctx.$slots, "content", normalizeProps(guardReactiveProps({ containerStyleComputed: containerStyleComputed.value, listStyleComputed: listStyleComputed.value, renderBuffer: renderBuffer.value, uniqueKey, currentListOffset: currentListOffset.value })), () => [
          createBaseVNode("div", {
            class: "va-virtual-scroller__container",
            style: normalizeStyle(containerStyleComputed.value)
          }, [
            createBaseVNode("div", {
              ref_key: "list",
              ref: list,
              role: "list",
              class: "va-virtual-scroller__list",
              style: normalizeStyle(listStyleComputed.value)
            }, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(renderBuffer.value, (item, index) => {
                return renderSlot(_ctx.$slots, "default", normalizeProps(mergeProps({
                  key: uniqueKey(item, index)
                }, { item, index: renderStartIndex.value + index })));
              }), 128))
            ], 4)
          ], 4)
        ])
      ], 6);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-virtual-scroller/VaVirtualScroller.js
var _style_041 = ".va-virtual-scroller {\n  overflow: auto;\n  width: 100%;\n  height: 100%;\n}\n.va-virtual-scroller__container {\n  position: relative;\n  overflow: hidden;\n  min-width: 100%;\n  min-height: 100%;\n}\n.va-virtual-scroller__list {\n  display: flex;\n  flex-direction: column;\n}\n.va-virtual-scroller--horizontal .va-virtual-scroller__list {\n  flex-direction: row;\n}";
var _VaVirtualScroller = _export_sfc(_sfc_main45, [["styles", [_style_041]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-virtual-scroller/index.js
var VaVirtualScroller = withConfigTransport$1(_VaVirtualScroller);

// node_modules/vuestic-ui/dist/web-components/src/components/va-inner-loading/VaInnerLoading.vue_vue_type_script_setup_true_lang.js
var _hoisted_126 = {
  key: 0,
  class: "va-inner-loading__overlay",
  "aria-hidden": "true"
};
var _sfc_main46 = defineComponent({
  ...{
    name: "VaInnerLoading"
  },
  __name: "VaInnerLoading",
  props: {
    ...useLoadingProps,
    ...useComponentPresetProp,
    color: { type: String },
    icon: { type: String, default: "va-loading" },
    size: { type: Number, default: 30 }
  },
  setup(__props) {
    const props = __props;
    const { getColor } = useColors();
    const colorComputed = computed(() => getColor(props.color));
    const computedClass = computed(() => ({
      "va-inner-loading--active": props.loading
    }));
    const ariaAttributesComputed = computed(() => ({
      "aria-busy": props.loading
    }));
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", mergeProps({
        class: ["va-inner-loading", computedClass.value],
        "aria-live": "polite"
      }, ariaAttributesComputed.value), [
        renderSlot(_ctx.$slots, "default"),
        _ctx.$props.loading ? (openBlock(), createElementBlock("div", _hoisted_126, [
          renderSlot(_ctx.$slots, "loading", {}, () => [
            createVNode(unref(VaIcon), {
              class: "va-inner-loading__spinner",
              spin: "counter-clockwise",
              color: colorComputed.value,
              size: _ctx.$props.size,
              name: _ctx.$props.icon
            }, null, 8, ["color", "size", "name"])
          ])
        ])) : createCommentVNode("", true)
      ], 16);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-inner-loading/VaInnerLoading.js
var _style_042 = ':root,\n:host {\n  --va-inner-loading-position: relative;\n  --va-inner-loading-min-width: fit-content;\n  --va-inner-loading-width: 100%;\n  --va-inner-loading-overlay-display: flex;\n  --va-inner-loading-overlay-align-items: center;\n  --va-inner-loading-overlay-justify-content: center;\n  --va-inner-loading-overlay-position: absolute;\n  --va-inner-loading-overlay-top: 0;\n  --va-inner-loading-overlay-bottom: 0;\n  --va-inner-loading-overlay-width: 100%;\n  --va-inner-loading-overlay-background: var(--va-background-primary);\n}\n.va-inner-loading {\n  position: var(--va-inner-loading-position);\n  min-width: var(--va-inner-loading-min-width);\n  width: var(--va-inner-loading-width);\n  font-family: var(--va-font-family);\n}\n.va-inner-loading--active {\n  pointer-events: none;\n}\n.va-inner-loading__overlay {\n  display: var(--va-inner-loading-overlay-display);\n  align-items: var(--va-inner-loading-overlay-align-items);\n  justify-content: var(--va-inner-loading-overlay-justify-content);\n  position: var(--va-inner-loading-overlay-position);\n  top: var(--va-inner-loading-overlay-top);\n  bottom: var(--va-inner-loading-overlay-bottom);\n  width: var(--va-inner-loading-overlay-width);\n  z-index: 0;\n}\n.va-inner-loading__overlay::after {\n  content: "";\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  top: 0;\n  left: 0;\n  background: var(--va-inner-loading-overlay-background);\n  opacity: 0.3;\n  z-index: -1;\n}';
var _VaInnerLoading = _export_sfc(_sfc_main46, [["styles", [_style_042]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-inner-loading/index.js
var VaInnerLoading = withConfigTransport$1(_VaInnerLoading);

// node_modules/vuestic-ui/dist/web-components/src/components/va-data-table/VaDataTable.vue_vue_type_script_setup_true_lang.js
var _hoisted_127 = { key: 0 };
var _hoisted_212 = {
  ref: "list",
  class: "va-data-table__table-tbody"
};
var _hoisted_38 = {
  key: "showNoDataHtml",
  class: "va-data-table__table-tr"
};
var _hoisted_47 = ["colspan", "innerHTML"];
var _hoisted_56 = {
  key: "showNoDataFilteredHtml",
  class: "va-data-table__table-tr"
};
var _hoisted_65 = ["colspan", "innerHTML"];
var _hoisted_73 = ["onClick", "onDblclick", "onContextmenu"];
var _hoisted_8 = {
  key: 0,
  class: "va-data-table__grid-column-header"
};
var _hoisted_9 = {
  key: 0,
  class: "va-data-table__table-expanded-content",
  colspan: "99999"
};
var VaVirtualScrollerProps = extractComponentProps(VaVirtualScroller, ["items", "trackBy", "horizontal", "disabled", "table"]);
var VaDataTableThRowProps = extractComponentProps(VaDataTableThRow);
var _sfc_main47 = defineComponent({
  ...{
    name: "VaDataTable",
    inheritAttrs: false
  },
  __name: "VaDataTable",
  props: {
    ...useComponentPresetProp,
    ...VaVirtualScrollerProps,
    ...useAnimationNameProps,
    ...useBindingProps,
    ...useTableScrollProps,
    ...useSortableProps,
    ...useStylableProps,
    ...useColumnsProps,
    ...useFilterableProps,
    ...usePaginatedRowsProps,
    ...useRowsProps,
    ...useSelectableProps2,
    ...useThrottleProps,
    ...pick$1(VaDataTableThRowProps, ["ariaSelectAllRowsLabel", "ariaSortColumnByLabel"]),
    hoverable: { type: Boolean, default: false },
    clickable: { type: Boolean, default: false },
    loading: { type: Boolean, default: false },
    loadingColor: { type: String, default: "primary" },
    noDataHtml: { type: String, default: "No items" },
    noDataFilteredHtml: { type: String, default: "No items match the provided filtering condition" },
    hideDefaultHeader: { type: Boolean, default: false },
    footerClone: { type: Boolean, default: false },
    striped: { type: Boolean, default: false },
    virtualScroller: { type: Boolean, default: false },
    virtualTrackBy: { type: [String, Number], default: "initialIndex" },
    grid: { type: Boolean, default: false },
    gridColumns: { type: Number, default: 0 },
    wrapperSize: { type: [Number, String], default: "auto" },
    ariaSelectRowLabel: { type: String, default: "$t:selectRowByIndex" }
  },
  emits: [
    "update:modelValue",
    // `modelValue` is selectedItems
    "update:sortBy",
    "update:sortingOrder",
    "filtered",
    "sorted",
    "selectionChange",
    "row:click",
    "row:dblclick",
    "row:contextmenu",
    "columnSorted",
    ...useTableScrollEmits
  ],
  setup(__props, { emit: __emit }) {
    useCssVars((_ctx) => ({
      "06771dc5": unref(CSSVariables).selectedColor,
      "6c4ea46a": unref(CSSVariables).hoverColor,
      "56527a12": unref(CSSVariables).tableHeight,
      "a06f5c94": unref(CSSVariables).theadBg,
      "a61bb678": unref(CSSVariables).tfootBg,
      "d268e7a2": gridColumnsCount.value
    }));
    const { tp } = useTranslation();
    const props = __props;
    const emit = __emit;
    const { columnsComputed } = useColumns(props);
    const { rowsComputed } = useRows(columnsComputed, props);
    const { filteredRows } = useFilterable(rowsComputed, props, emit);
    const {
      sortBySync,
      sortingOrderSync,
      toggleSorting,
      sortedRows,
      sortingOrderIconName
    } = useSortable(columnsComputed, filteredRows, props, emit);
    const { paginatedRows } = usePaginatedRows(sortedRows, props);
    const {
      ctrlSelectRow,
      shiftSelectRows,
      toggleBulkSelection,
      isRowSelected,
      severalRowsSelected,
      allRowsSelected,
      toggleRowSelection
    } = useSelectableRow(paginatedRows, props, emit);
    const {
      CSSVariables,
      getCellCSSVariables,
      getClass: getClass2,
      getStyle: getStyle2
    } = useStylable(props);
    const { getRowBind, getCellBind } = useBinding(props);
    const animationName = useAnimationName(props, paginatedRows);
    const showNoDataHtml = computed(() => props.items.length === 0);
    const showNoDataFilteredHtml = computed(() => paginatedRows.value.length === 0);
    const onRowClickHandler = (name, event, row) => {
      emit(name, {
        event,
        item: row.source,
        itemIndex: row.initialIndex,
        row
      });
      if (props.selectable && props.grid) {
        toggleRowSelection(row);
      }
    };
    const computedTableAttributes = computed(() => ({
      ...omit$1(attrs, ["class", "style"]),
      class: pick$1(props, ["striped", "selectable", "hoverable", "clickable"])
    }));
    const filteredVirtualScrollerProps = filterComponentProps(VaVirtualScrollerProps);
    const virtualScrollerPropsComputed = computed(() => ({
      ...filteredVirtualScrollerProps.value,
      items: paginatedRows.value,
      trackBy: props.virtualTrackBy,
      disabled: !props.virtualScroller,
      table: true
    }));
    const attrs = useAttrs();
    const computedAttributes = computed(() => ({
      class: [
        { "va-data-table--sticky": props.stickyHeader || props.stickyFooter },
        { "va-data-table--scroll": !!props.height },
        { "va-data-table--virtual-scroller": isVirtualScroll.value },
        { "va-data-table--grid": props.grid },
        attrs.class
      ],
      style: [attrs.style],
      ...virtualScrollerPropsComputed.value
    }));
    const filteredThProps = filterComponentProps(VaDataTableThRowProps);
    const thAttributesComputed = computed(() => ({
      ...filteredThProps.value,
      columns: columnsComputed.value,
      sortingOrderIconName: sortingOrderIconName.value,
      severalRowsSelected: severalRowsSelected.value,
      sortingOrderSync: sortingOrderSync.value,
      allRowsSelected: allRowsSelected.value,
      sortBySync: sortBySync.value
    }));
    const {
      scrollContainer,
      topTrigger,
      bottomTrigger,
      doRenderTopTrigger,
      doRenderBottomTrigger
    } = useTableScroll(props, emit);
    const isVirtualScroll = computed(() => props.virtualScroller && !props.grid);
    const gridColumnsCount = computed(() => props.gridColumns || "var(--va-data-table-grid-tbody-columns)");
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(VaVirtualScroller), mergeProps({ class: "va-data-table" }, computedAttributes.value, {
        ref_key: "scrollContainer",
        ref: scrollContainer
      }), {
        content: withCtx(({
          uniqueKey,
          renderBuffer,
          currentListOffset,
          listStyleComputed,
          containerStyleComputed
        }) => [
          createVNode(unref(VaInnerLoading), {
            "aria-live": "polite",
            style: normalizeStyle(containerStyleComputed),
            loading: __props.loading,
            color: __props.loadingColor
          }, {
            default: withCtx(() => [
              unref(doRenderTopTrigger) ? (openBlock(), createElementBlock("div", {
                key: 0,
                ref_key: "topTrigger",
                ref: topTrigger,
                class: "va-data-table__scroll-trigger"
              }, null, 512)) : createCommentVNode("", true),
              createBaseVNode("table", mergeProps({
                class: "va-data-table__table",
                style: listStyleComputed
              }, computedTableAttributes.value), [
                "colgroup" in _ctx.$slots ? (openBlock(), createElementBlock("colgroup", _hoisted_127, [
                  renderSlot(_ctx.$slots, "colgroup", normalizeProps(guardReactiveProps(unref(columnsComputed))))
                ])) : createCommentVNode("", true),
                createBaseVNode("thead", {
                  class: normalizeClass(["va-data-table__table-thead", { "va-data-table__table-thead--sticky": _ctx.$props.stickyHeader }]),
                  style: normalizeStyle({ top: isVirtualScroll.value && _ctx.$props.stickyHeader ? `-${currentListOffset}px` : void 0 })
                }, [
                  renderSlot(_ctx.$slots, "headerPrepend"),
                  renderSlot(_ctx.$slots, "header", {}, () => [
                    !__props.hideDefaultHeader ? (openBlock(), createBlock(unref(VaDataTableThRow), mergeProps({ key: 0 }, thAttributesComputed.value, {
                      onToggleBulkSelection: unref(toggleBulkSelection),
                      onToggleSorting: unref(toggleSorting)
                    }), createSlots({ _: 2 }, [
                      renderList(_ctx.$slots, (_, slot) => {
                        return {
                          name: slot,
                          fn: withCtx((scope) => [
                            renderSlot(_ctx.$slots, slot, normalizeProps(guardReactiveProps(scope)))
                          ])
                        };
                      })
                    ]), 1040, ["onToggleBulkSelection", "onToggleSorting"])) : createCommentVNode("", true)
                  ]),
                  renderSlot(_ctx.$slots, "headerAppend")
                ], 6),
                createBaseVNode("tbody", _hoisted_212, [
                  renderSlot(_ctx.$slots, "bodyPrepend"),
                  createVNode(TransitionGroup, {
                    name: isVirtualScroll.value ? "" : unref(animationName),
                    css: !_ctx.$props.virtualScroller,
                    appear: !_ctx.$props.virtualScroller
                  }, {
                    default: withCtx(() => [
                      showNoDataHtml.value ? (openBlock(), createElementBlock("tr", _hoisted_38, [
                        createBaseVNode("td", {
                          class: "va-data-table__table-td no-data",
                          colspan: unref(columnsComputed).length + (_ctx.selectable ? 1 : 0),
                          innerHTML: __props.noDataHtml
                        }, null, 8, _hoisted_47)
                      ])) : showNoDataFilteredHtml.value ? (openBlock(), createElementBlock("tr", _hoisted_56, [
                        createBaseVNode("td", {
                          class: "va-data-table__table-td no-data",
                          colspan: unref(columnsComputed).length + (_ctx.selectable ? 1 : 0),
                          innerHTML: __props.noDataFilteredHtml
                        }, null, 8, _hoisted_65)
                      ])) : createCommentVNode("", true),
                      (openBlock(true), createElementBlock(Fragment, null, renderList(renderBuffer, (row, index) => {
                        return openBlock(), createElementBlock(Fragment, {
                          key: `table-row_${uniqueKey(row, index)}`
                        }, [
                          createBaseVNode("tr", mergeProps({
                            class: ["va-data-table__table-tr", [{ selected: unref(isRowSelected)(row), "va-data-table__table-tr--expanded": row.isExpandableRowVisible }]]
                          }, unref(getRowBind)(row), {
                            onClick: ($event) => onRowClickHandler("row:click", $event, row),
                            onDblclick: ($event) => onRowClickHandler("row:dblclick", $event, row),
                            onContextmenu: ($event) => onRowClickHandler("row:contextmenu", $event, row)
                          }), [
                            _ctx.selectable && !_ctx.$props.grid ? (openBlock(), createElementBlock("td", {
                              class: "va-data-table__table-td va-data-table__table-cell-select",
                              key: `selectable_${uniqueKey(row, index)}`,
                              onSelectstart: _cache[0] || (_cache[0] = withModifiers(() => {
                              }, ["prevent"]))
                            }, [
                              createVNode(unref(VaCheckbox), {
                                class: "va-data-table__table-cell-checkbox",
                                "model-value": unref(isRowSelected)(row),
                                color: _ctx.selectedColor,
                                "aria-label": unref(tp)(_ctx.$props.ariaSelectRowLabel, { index: row.initialIndex }),
                                onClick: [
                                  withModifiers(($event) => unref(shiftSelectRows)(row), ["shift", "exact", "stop"]),
                                  withModifiers(($event) => unref(ctrlSelectRow)(row), ["ctrl", "exact", "stop"]),
                                  withModifiers(($event) => unref(ctrlSelectRow)(row), ["exact", "stop"])
                                ]
                              }, null, 8, ["model-value", "color", "aria-label", "onClick"])
                            ], 32)) : createCommentVNode("", true),
                            (openBlock(true), createElementBlock(Fragment, null, renderList(row.cells, (cell, cellIndex) => {
                              return openBlock(), createElementBlock("td", mergeProps({
                                key: `table-cell_${cell.column.name + cell.rowIndex}`,
                                class: ["va-data-table__table-td", unref(getClass2)(cell.column.tdClass)],
                                style: [
                                  cell.column.width ? { minWidth: cell.column.width, maxWidth: cell.column.width } : {},
                                  unref(getCellCSSVariables)(cell),
                                  unref(getStyle2)(cell.column.tdStyle)
                                ]
                              }, unref(getCellBind)(cell, row)), [
                                `cell(${cell.column.name})` in _ctx.$slots ? renderSlot(_ctx.$slots, `cell(${cell.column.name})`, normalizeProps(mergeProps({ key: 0 }, { ...cell, row, isExpanded: row.isExpandableRowVisible }))) : renderSlot(_ctx.$slots, "cell", normalizeProps(mergeProps({ key: 1 }, { cell, row })), () => [
                                  _ctx.$props.grid ? (openBlock(), createElementBlock("span", _hoisted_8, toDisplayString(unref(columnsComputed)[cellIndex].label), 1)) : createCommentVNode("", true),
                                  createTextVNode(" " + toDisplayString(cell.value), 1)
                                ])
                              ], 16);
                            }), 128))
                          ], 16, _hoisted_73),
                          row.isExpandableRowVisible ? (openBlock(), createElementBlock("td", _hoisted_9, [
                            renderSlot(_ctx.$slots, "expandableRow", normalizeProps(guardReactiveProps(row)))
                          ])) : createCommentVNode("", true)
                        ], 64);
                      }), 128))
                    ]),
                    _: 2
                  }, 1032, ["name", "css", "appear"]),
                  renderSlot(_ctx.$slots, "bodyAppend")
                ], 512),
                _ctx.$slots.footer || __props.footerClone && !_ctx.$props.grid ? (openBlock(), createElementBlock("tfoot", {
                  key: 1,
                  class: normalizeClass(["va-data-table__table-tfoot", { "va-data-table__table-tfoot--sticky": _ctx.$props.stickyFooter }]),
                  style: normalizeStyle({ bottom: isVirtualScroll.value && _ctx.$props.stickyFooter ? `${currentListOffset}px` : void 0 })
                }, [
                  renderSlot(_ctx.$slots, "footerPrepend"),
                  renderSlot(_ctx.$slots, "footer", {}, () => [
                    !__props.hideDefaultHeader ? (openBlock(), createBlock(unref(VaDataTableThRow), mergeProps({ key: 0 }, thAttributesComputed.value, {
                      "is-footer": "",
                      onToggleBulkSelection: unref(toggleBulkSelection),
                      onToggleSorting: unref(toggleSorting)
                    }), createSlots({ _: 2 }, [
                      renderList(_ctx.$slots, (_, slot) => {
                        return {
                          name: slot,
                          fn: withCtx((scope) => [
                            renderSlot(_ctx.$slots, slot, normalizeProps(guardReactiveProps(scope)))
                          ])
                        };
                      })
                    ]), 1040, ["onToggleBulkSelection", "onToggleSorting"])) : createCommentVNode("", true)
                  ]),
                  renderSlot(_ctx.$slots, "footerAppend")
                ], 6)) : createCommentVNode("", true)
              ], 16),
              unref(doRenderBottomTrigger) ? (openBlock(), createElementBlock("div", {
                key: 1,
                ref_key: "bottomTrigger",
                ref: bottomTrigger,
                class: "va-data-table__scroll-trigger"
              }, null, 512)) : createCommentVNode("", true)
            ]),
            _: 2
          }, 1032, ["style", "loading", "color"])
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-data-table/VaDataTable.js
var _style_043 = '.va-data-table {\n  --va-data-table-cell-padding: 0.625rem;\n  --va-data-table-thead-line-height: 1.6;\n  --va-data-table-thead-font-size: 0.625rem;\n  --va-data-table-thead-font-weight: 700;\n  --va-data-table-thead-text-transform: uppercase;\n  --va-data-table-thead-letter-spacing: 0.6px;\n  --va-data-table-thead-border: 1px solid var(--va-background-border);\n  --va-data-table-thead-border-top-shadow: inset 0 1px 0 0 var(--va-background-border);\n  --va-data-table-thead-border-bottom-shadow: inset 0 -1px 0 0 var(--va-background-border);\n  --va-data-table-height: unset;\n  --va-data-table-max-height: unset;\n  --va-data-table-thead-color: currentColor;\n  --va-data-table-tfoot-color: currentColor;\n  --va-data-table-header-background: var(--va-background-primary);\n  /* Hover */\n  --va-data-table-hover-th-opacity: 0.3;\n  /* Striped */\n  --va-data-table-striped-tr-background-color: var(--va-background-element);\n  --va-data-table-striped-tr-opacity: 1;\n  /* Selectable */\n  --va-data-table-selectable-tr-cursor: pointer;\n  --va-data-table-selectable-cell-width: 55px;\n  --va-data-table-selectable-cell-vertical-align: middle;\n  --va-data-table-selectable-cell-text-align: center;\n  /* No-data */\n  --va-data-table-no-data-text-align: center;\n  --va-data-table-no-data-vertical-align: middle;\n  /* Animated */\n  --va-data-table-transition: var(--va-transition);\n  /* Grid */\n  --va-data-table-grid-tbody-gap: 0.5rem;\n  --va-data-table-grid-tbody-margin-top: 1rem;\n  --va-data-table-grid-tr-padding: 1rem;\n  --va-data-table-grid-tr-border-radius: 0.5rem;\n  --va-data-table-grid-tr-border: 1px solid var(--va-background-border);\n  --va-data-table-grid-tr-header-font-weight: 600;\n  --va-data-table-grid-tr-header-color: var(--va-text-primary);\n}\n.va-data-table {\n  --va-data-table-selected-color: var(--06771dc5);\n  --va-data-table-hover-color: var(--6c4ea46a);\n  --va-data-table-height--computed: var(--56527a12);\n  --va-data-table-thead-background--computed: var(--a06f5c94);\n  --va-data-table-tfoot-background--computed: var(--a61bb678);\n  --va-data-table-grid-tbody-columns: 4;\n  min-width: unset;\n  font-family: var(--va-font-family);\n}\n@media (max-width: 1199.98px) {\n.va-data-table {\n    --va-data-table-grid-tbody-columns: 3;\n}\n}\n@media (max-width: 991.98px) {\n.va-data-table {\n    --va-data-table-grid-tbody-columns: 2;\n}\n}\n@media (max-width: 767.98px) {\n.va-data-table {\n    --va-data-table-grid-tbody-columns: 1;\n}\n}\n.va-data-table:not(.va-data-table--virtual-scroller) {\n  overflow-x: auto;\n  overflow-y: hidden;\n}\n.va-data-table--sticky:not(.va-data-table--virtual-scroller), .va-data-table--scroll {\n  overflow-y: auto;\n  height: var(--va-data-table-height--computed);\n  max-height: var(--va-data-table-max-height);\n}\n.va-data-table .va-data-table__table {\n  width: 100%;\n  cursor: default;\n  white-space: nowrap;\n}\n.va-data-table .va-data-table__table .va-data-table__table-thead {\n  color: var(--va-data-table-thead-color);\n  border-bottom: var(--va-data-table-thead-border);\n}\n.va-data-table .va-data-table__table .va-data-table__table-thead th {\n  border-bottom: none;\n  box-shadow: var(--va-data-table-thead-border-bottom-shadow);\n}\n.va-data-table .va-data-table__table .va-data-table__table-thead--sticky {\n  position: sticky;\n  top: 0;\n  z-index: 1;\n  background: var(--va-data-table-thead-background--computed);\n}\n.va-data-table .va-data-table__table .va-data-table__table-tbody .no-data {\n  text-align: var(--va-data-table-no-data-text-align);\n  vertical-align: var(--va-data-table-no-data-vertical-align);\n}\n.va-data-table .va-data-table__table .va-data-table__table-tfoot {\n  color: var(--va-data-table-tfoot-color);\n  border-top: var(--va-data-table-thead-border);\n}\n.va-data-table .va-data-table__table .va-data-table__table-tfoot th {\n  border-bottom: none;\n  box-shadow: var(--va-data-table-thead-border-top-shadow);\n}\n.va-data-table .va-data-table__table .va-data-table__table-tfoot--sticky {\n  position: sticky;\n  bottom: 0;\n  z-index: 1;\n  background: var(--va-data-table-tfoot-background--computed);\n}\n.va-data-table .va-data-table__table .va-data-table__table-td {\n  padding: var(--va-data-table-cell-padding);\n  text-align: var(--va-data-table-align);\n  vertical-align: var(--va-data-table-vertical-align);\n}\n.va-data-table .va-data-table__table .va-data-table__table-th.va-data-table__table-cell-select,\n.va-data-table .va-data-table__table .va-data-table__table-td.va-data-table__table-cell-select {\n  width: var(--va-data-table-selectable-cell-width);\n  min-width: var(--va-data-table-selectable-cell-width);\n  text-align: var(--va-data-table-selectable-cell-text-align);\n  vertical-align: var(--va-data-table-selectable-cell-vertical-align);\n  cursor: var(--va-data-table-selectable-tr-cursor);\n}\n.va-data-table .va-data-table__table .va-data-table__table-th .va-data-table__table-cell-checkbox,\n.va-data-table .va-data-table__table .va-data-table__table-td .va-data-table__table-cell-checkbox {\n  display: block;\n}\n.va-data-table .va-data-table__table .va-data-table__table-tr.selected {\n  background-color: var(--va-data-table-selected-color);\n}\n.va-data-table .va-data-table__table.clickable .va-data-table__table-tr {\n  cursor: pointer;\n}\n.va-data-table .va-data-table__table.striped .va-data-table__table-tbody .va-data-table__table-tr:nth-of-type(2n):not(.selected) td {\n  position: relative;\n  z-index: 0;\n}\n.va-data-table .va-data-table__table.striped .va-data-table__table-tbody .va-data-table__table-tr:nth-of-type(2n):not(.selected) td::after {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  content: "";\n  background: var(--va-data-table-striped-tr-background-color);\n  opacity: var(--va-data-table-striped-tr-opacity);\n  z-index: -1;\n  transition: all 0.3s ease-in-out;\n}\n.va-data-table .va-data-table__table.selectable .va-data-table__table-tbody .va-data-table__table-tr td, .va-data-table .va-data-table__table.hoverable .va-data-table__table-tbody .va-data-table__table-tr td {\n  position: relative;\n}\n.va-data-table .va-data-table__table.selectable .va-data-table__table-tbody .va-data-table__table-tr:hover td, .va-data-table .va-data-table__table.hoverable .va-data-table__table-tbody .va-data-table__table-tr:hover td {\n  z-index: 0;\n}\n.va-data-table .va-data-table__table.selectable .va-data-table__table-tbody .va-data-table__table-tr:hover td::after, .va-data-table .va-data-table__table.hoverable .va-data-table__table-tbody .va-data-table__table-tr:hover td::after {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  content: "";\n  background: var(--va-data-table-hover-color);\n  opacity: 1;\n  z-index: -1;\n  transition: all 0.3s ease-in-out;\n}\n.va-data-table .va-data-table__table .table-transition-fade-leave-active {\n  transition: opacity var(--va-data-table-transition);\n  display: none;\n}\n.va-data-table .va-data-table__table .table-transition-fade-enter-active {\n  transition: opacity var(--va-data-table-transition) 0.2s;\n}\n.va-data-table .va-data-table__table .table-transition-fade-enter-from,\n.va-data-table .va-data-table__table .table-transition-shuffle-enter-from,\n.va-data-table .va-data-table__table .table-transition-fade-leave-to,\n.va-data-table .va-data-table__table .table-transition-shuffle-leave-to {\n  opacity: 0;\n}\n.va-data-table .va-data-table__table .table-transition-shuffle-move {\n  transition: transform var(--va-data-table-transition);\n}\n.va-data-table .va-data-table__table .table-transition-shuffle-leave-active {\n  transition: none;\n  display: none;\n}\n.va-data-table .va-data-table__table .table-transition-shuffle-enter-active {\n  transition: opacity var(--va-data-table-transition);\n}\n.va-data-table__scroll-trigger {\n  -webkit-user-select: none;\n     -moz-user-select: none;\n          user-select: none;\n}\n.va-data-table--grid .va-data-table__table-thead .va-data-table__table-tr {\n  display: flex;\n  justify-content: space-between;\n}\n.va-data-table--grid .va-data-table__table-thead .va-data-table__table-tr .va-data-table__table-th {\n  box-shadow: none;\n}\n@media (max-width: 767.98px) {\n.va-data-table--grid .va-data-table__table-thead .va-data-table__table-tr {\n    flex-direction: column;\n}\n}\n.va-data-table--grid .va-data-table__table-tbody {\n  margin-top: var(--va-data-table-grid-tbody-margin-top);\n  display: grid;\n  grid-template-columns: repeat(var(--d268e7a2), minmax(0, 1fr));\n  gap: var(--va-data-table-grid-tbody-gap);\n}\n.va-data-table--grid .va-data-table__table-tbody .va-data-table__table-tr {\n  grid-column: span 1/span 1;\n  padding: var(--va-data-table-grid-tr-padding);\n  display: flex;\n  flex-direction: column;\n  border: var(--va-data-table-grid-tr-border);\n  border-radius: var(--va-data-table-grid-tr-border-radius);\n}\n.va-data-table--grid .va-data-table__table-tbody .va-data-table__table-td {\n  overflow: hidden;\n}\n.va-data-table--grid .selectable .va-data-table__table-tr {\n  cursor: pointer;\n}\n.va-data-table--grid .va-data-table__table-td {\n  display: flex;\n  flex-direction: column;\n}\n.va-data-table--grid .va-data-table__grid-column-header {\n  font-weight: var(--va-data-table-grid-tr-header-font-weight);\n  color: var(--va-data-table-grid-tr-header-color);\n}';
var _VaDataTable = _export_sfc(_sfc_main47, [["styles", [_style_043]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-data-table/index.js
var VaDataTable = withConfigTransport$1(_VaDataTable);

// node_modules/vuestic-ui/dist/web-components/src/components/va-date-input/hooks/model-value-parser.js
var isRange = (date) => {
  if (date === null) {
    return false;
  }
  return typeof date === "object" && ("start" in date || "end" in date);
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-date-input/hooks/range-model-value-guard.js
var useRangeModelValueGuard = (modelValue, disabled) => {
  const bufferValue = ref(modelValue.value);
  const valueComputed = computed({
    get: () => bufferValue.value,
    set: (value) => {
      if (disabled.value) {
        modelValue.value = value;
      }
      if (!value) {
        modelValue.value = value;
        return;
      }
      if (isRange(value)) {
        if (value.end !== null) {
          modelValue.value = value;
        }
      } else {
        modelValue.value = value;
      }
      bufferValue.value = value;
    }
  });
  watch(modelValue, (newValue) => {
    bufferValue.value = newValue;
  });
  const reset = () => {
    if (bufferValue.value && isRange(bufferValue.value)) {
      bufferValue.value = modelValue.value;
    }
  };
  return {
    valueComputed,
    reset
  };
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-date-input/hooks/input-text-parser.js
var defaultParseDateFunction = (text) => new Date(Date.parse(text));
var isValidDate = (d) => isDate$1(d) && !isNaN(d.getTime());
var useDateParser = (props) => {
  const isMultipleDates = (text) => {
    const dates = text.split(props.delimiter);
    if (dates.length < 2) {
      return false;
    }
    return dates.every((date) => {
      const parsedDate = (props.parseDate || defaultParseDateFunction)(date);
      return isValidDate(parsedDate);
    });
  };
  const isRange4 = (text) => text.includes(props.rangeDelimiter);
  const isValid = ref(true);
  const parseDate = (text) => {
    const splitDate = text.split(".");
    const valueToParse = (splitDate == null ? void 0 : splitDate.length) === 3 ? splitDate.reverse().join("-") : text;
    const date = (props.parseDate || defaultParseDateFunction)(valueToParse);
    isValid.value = isValidDate(date);
    return date;
  };
  const parseDateInputValue = (text) => {
    isValid.value = true;
    if (props.parse) {
      return props.parse(text, isValid);
    }
    if (isMultipleDates(text)) {
      return text.split(props.delimiter).map(parseDate);
    }
    if (isRange4(text)) {
      const [start, end] = text.split(props.rangeDelimiter).map(parseDate);
      return { start, end };
    }
    return parseDate(text);
  };
  return {
    parseDateInputValue,
    isValid
  };
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-date-input/utils/parse-date.js
var isISO8601 = (date) => {
  const isoDate = Date.parse(date);
  return !isNaN(isoDate) && !date.includes(" ");
};
var isRFC1123GTM = (date) => {
  return date.endsWith("GMT");
};
var isRFC1123 = (date) => {
  const rfcDate = new Date(date);
  return !isNaN(rfcDate.getTime());
};
var formatDateToTheSameStandardFormat = (date, formattedString) => {
  if (isRFC1123GTM(formattedString)) {
    return date.toUTCString();
  }
  if (isISO8601(formattedString)) {
    return date.toISOString();
  }
  if (isRFC1123(formattedString)) {
    return date.toString();
  }
  return null;
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-date-input/hooks/model-value.js
var isRange2 = (date) => {
  if (date === null) {
    return false;
  }
  return typeof date === "object" && ("start" in date || "end" in date);
};
var isMultiple = (date) => {
  if (date === null) {
    return false;
  }
  return Array.isArray(date);
};
var isSingleDate = (date) => {
  if (date === null) {
    return false;
  }
  return typeof date === "string" || typeof date === "number" || date instanceof Date;
};
var useDateInputModelValue = (modelValue, mode, parseModelValue, formatModelValue, formatModelValueSingleDate) => {
  const syncFormat = (original, target) => {
    if (formatModelValueSingleDate) {
      return formatModelValueSingleDate(target);
    }
    if (typeof original === "string") {
      const standardFormat = formatDateToTheSameStandardFormat(target, original);
      if (standardFormat) {
        return standardFormat;
      }
      return formatModelValue(target);
    }
    if (typeof original === "number") {
      return target.getTime();
    }
    return target;
  };
  const normalizeSingleDate = (value) => {
    if (value instanceof Date) {
      return value;
    }
    return new Date(value);
  };
  const dateValue = computed(() => {
    if (modelValue.value === null || modelValue.value === void 0) {
      return null;
    }
    if (typeof modelValue.value === "string") {
      return parseModelValue(modelValue.value);
    }
    if (typeof modelValue.value === "number") {
      return new Date(modelValue.value);
    }
    return modelValue.value;
  });
  const normalized = computed({
    get: () => {
      if (dateValue.value === null || dateValue.value === void 0) {
        return null;
      }
      if (isMultiple(dateValue.value)) {
        return dateValue.value.map(normalizeSingleDate);
      }
      if (isRange2(dateValue.value)) {
        const { start, end } = dateValue.value;
        return {
          start: start ? normalizeSingleDate(start) : null,
          end: end ? normalizeSingleDate(end) : null
        };
      }
      return normalizeSingleDate(dateValue.value);
    },
    set(newValue) {
      var _a2, _b;
      if (newValue === null || newValue === void 0) {
        modelValue.value = newValue;
        return;
      }
      if (isMultiple(newValue) && (isMultiple(modelValue.value) || isNil$1(modelValue.value))) {
        const originalValue = modelValue.value;
        modelValue.value = newValue.map((v, index) => syncFormat((originalValue == null ? void 0 : originalValue[index]) || (originalValue == null ? void 0 : originalValue[0]), v));
        return;
      }
      if (isRange2(newValue) && (isRange2(modelValue.value) || isNil$1(modelValue.value))) {
        const { start, end } = newValue;
        modelValue.value = {
          start: start ? syncFormat((_a2 = modelValue.value) == null ? void 0 : _a2.start, start) : null,
          // Sync end date only if start date is specified
          end: end ? syncFormat((_b = modelValue.value) == null ? void 0 : _b.start, end) : null
        };
        return;
      }
      if (isSingleDate(newValue) && (isSingleDate(modelValue.value) || isNil$1(modelValue.value))) {
        modelValue.value = syncFormat(modelValue.value, newValue);
        return;
      }
      console.log({ inputDate: newValue, modelValue: modelValue.value });
      throw new Error("Input date is not the same as date from props");
    }
  });
  const text = computed({
    get: () => {
      if (normalized.value === null || normalized.value === void 0) {
        return "";
      }
      return formatModelValue(normalized.value);
    },
    set: (value) => {
      modelValue.value = parseModelValue(value);
    }
  });
  return {
    text,
    normalized
  };
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-date-picker/utils/date-utils.js
var isDatesDayEqual = (date1, date2) => (date1 == null ? void 0 : date1.toDateString()) === (date2 == null ? void 0 : date2.toDateString());
var isDatesYearEqual = (date1, date2) => {
  return (date1 == null ? void 0 : date1.getFullYear()) === (date2 == null ? void 0 : date2.getFullYear());
};
var isDatesMonthEqual = (date1, date2) => {
  return isDatesYearEqual(date1, date2) && (date1 == null ? void 0 : date1.getMonth()) === (date2 == null ? void 0 : date2.getMonth());
};
var createYearDate = (year) => {
  const date = /* @__PURE__ */ new Date();
  date.setFullYear(year);
  return date;
};
var isRange3 = (value) => {
  if (value === null) {
    return false;
  }
  return typeof value === "object" && ("start" in value || "end" in value);
};
var isSingleDate2 = (value) => isDate$1(value);
var isDates = (value) => Array.isArray(value);

// node_modules/vuestic-ui/dist/web-components/src/components/va-date-picker/hooks/view.js
var JANUARY_MONTH_INDEX = 0;
var DECEMBER_MONTH_INDEX = 11;
var addMonth = (view) => {
  if (view.month === DECEMBER_MONTH_INDEX) {
    return { ...view, year: view.year + 1, month: JANUARY_MONTH_INDEX };
  } else {
    return { ...view, month: view.month + 1 };
  }
};
var subMonth = (view) => {
  if (view.month === JANUARY_MONTH_INDEX) {
    return { ...view, year: view.year - 1, month: DECEMBER_MONTH_INDEX };
  } else {
    return { ...view, month: view.month - 1 };
  }
};
var getDefaultDate = (modelValue) => {
  if (isDate$1(modelValue)) {
    return modelValue;
  }
  if (isDate$1(modelValue == null ? void 0 : modelValue.start)) {
    return modelValue.start;
  }
  if (Array.isArray(modelValue) && isDate$1(modelValue[0])) {
    return modelValue[0];
  }
  return /* @__PURE__ */ new Date();
};
var useView = (props, emit, defaultOverride) => {
  const defaultDate = getDefaultDate(props.modelValue);
  const defaultView = {
    type: "day",
    year: defaultDate.getFullYear(),
    month: defaultDate.getMonth(),
    ...defaultOverride
  };
  const statefulView = ref(defaultView);
  const syncView = computed({
    get() {
      return { ...statefulView.value, ...props.view };
    },
    set(view) {
      statefulView.value = view;
      emit("update:view", view);
    }
  });
  const next = () => {
    if (syncView.value.type === "day") {
      syncView.value = addMonth(syncView.value);
    } else if (syncView.value.type === "month") {
      syncView.value = { ...syncView.value, year: syncView.value.year + 1 };
    }
  };
  const prev = () => {
    if (syncView.value.type === "day") {
      syncView.value = subMonth(syncView.value);
    } else if (syncView.value.type === "month") {
      syncView.value = { ...syncView.value, year: syncView.value.year - 1 };
    }
  };
  return {
    syncView,
    next,
    prev
  };
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-date-picker/components/VaDatePickerCell.vue_vue_type_script_setup_true_lang.js
var _hoisted_128 = {
  key: 0,
  class: "va-date-picker-cell va-date-picker-cell_clear"
};
var _hoisted_213 = ["onKeypress"];
var _sfc_main48 = defineComponent({
  ...{
    name: "VaDatePickerCell"
  },
  __name: "VaDatePickerCell",
  props: {
    otherMonth: { type: Boolean, default: false },
    today: { type: Boolean, default: false },
    inRange: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false },
    selected: { type: Boolean, default: false },
    weekend: { type: Boolean, default: false },
    hidden: { type: Boolean, default: false },
    focused: { type: Boolean, default: false },
    highlightWeekend: { type: Boolean, default: false },
    highlightToday: { type: Boolean, default: false },
    readonly: { type: Boolean, default: false },
    color: { type: String, default: "primary" }
  },
  emits: ["click"],
  setup(__props, { emit: __emit }) {
    useCssVars((_ctx) => ({
      "50437be3": bg.value,
      "be8fc7f6": unref(textColorComputed)
    }));
    const props = __props;
    const emit = __emit;
    const onClick = () => {
      if (!props.disabled) {
        emit("click");
      }
    };
    const { getColor } = useColors();
    const bg = computed(() => getColor(props.color));
    const { textColorComputed } = useTextColor(bg);
    return (_ctx, _cache) => {
      return __props.hidden ? (openBlock(), createElementBlock("div", _hoisted_128)) : (openBlock(), createElementBlock("div", {
        key: 1,
        class: normalizeClass(["va-date-picker-cell", {
          "va-date-picker-cell_other-month": __props.otherMonth,
          "va-date-picker-cell_today": __props.highlightToday && __props.today,
          "va-date-picker-cell_in-range": __props.inRange,
          "va-date-picker-cell_disabled": __props.disabled,
          "va-date-picker-cell_highlighted-weekend": __props.highlightWeekend && __props.weekend,
          "va-date-picker-cell_selected": __props.selected,
          "va-date-picker-cell_focused": __props.focused,
          "va-date-picker-cell_readonly": __props.readonly
        }]),
        onClick,
        onKeypress: withKeys(withModifiers(onClick, ["prevent", "stop"]), ["space", "enter"])
      }, [
        renderSlot(_ctx.$slots, "default")
      ], 42, _hoisted_213));
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-date-picker/components/VaDatePickerCell.js
var _style_044 = '.va-date-picker-cell {\n  position: relative;\n  color: var(--va-date-picker-text-color);\n  line-height: var(--va-date-picker-cell-size);\n  min-height: var(--va-date-picker-cell-size);\n  min-width: var(--va-date-picker-cell-size);\n  cursor: pointer;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n          user-select: none;\n  border-radius: var(--va-date-picker-cell-radius);\n  box-sizing: border-box;\n  text-align: center;\n  z-index: 1;\n}\n.va-date-picker-cell::after, .va-date-picker-cell::before {\n  content: "";\n  position: absolute;\n  height: 100%;\n  width: 100%;\n  left: 0;\n  z-index: -1;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n          user-select: none;\n  box-sizing: border-box;\n  border-radius: var(--va-date-picker-cell-radius);\n}\n.va-date-picker-cell_clear {\n  cursor: default;\n  opacity: 0;\n}\n.va-date-picker-cell_highlighted-weekend {\n  color: var(--va-date-picker-weekends-color);\n}\n.va-date-picker-cell_in-range::after {\n  background-color: var(--50437be3);\n  opacity: var(--va-date-picker-cell-background-opacity-in-range);\n}\n.va-date-picker-cell_today {\n  font-weight: bold;\n}\n.va-date-picker-cell_today::before {\n  border: 2px solid var(--va-date-picker-color);\n}\n.va-date-picker-cell_selected {\n  background-color: var(--50437be3);\n  color: var(--be8fc7f6);\n}\n.va-date-picker-cell_other-month {\n  opacity: var(--va-date-picker-cell-opacity);\n}\n.va-date-picker-cell:hover:not(.va-date-picker-cell_selected):not(.va-date-picker-cell_readonly):not(.va-date-picker-cell_disabled):not(.va-date-picker-cell_other-month)::after, .va-date-picker-cell_focused:not(.va-date-picker-cell_selected):not(.va-date-picker-cell_readonly):not(.va-date-picker-cell_disabled):not(.va-date-picker-cell_other-month)::after, .va-date-picker-cell_focused:hover:not(.va-date-picker-cell_selected):not(.va-date-picker-cell_readonly):not(.va-date-picker-cell_disabled):not(.va-date-picker-cell_other-month)::after {\n  background-color: var(--va-date-picker-selected-background);\n  opacity: var(--va-date-picker-cell-background-opacity-hover);\n}\n.va-date-picker-cell_disabled {\n  cursor: not-allowed;\n  opacity: var(--va-date-picker-cell-opacity);\n}\n.va-date-picker-cell_disabled:not(.va-date-picker-cell_today) {\n  opacity: 0.5;\n}\n.va-date-picker-cell_disabled::after {\n  opacity: var(--va-date-picker-cell-opacity);\n  border: none;\n  height: 2px;\n  width: 50%;\n  background: currentColor;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n}\n.va-date-picker-cell_readonly {\n  cursor: default;\n}\n.va-date-picker-cell_readonly::before {\n  display: none;\n}';
var VaDatePickerCell = _export_sfc(_sfc_main48, [["styles", [_style_044]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-date-picker/hooks/grid-keyboard-navigation.js
function isUndefined(t) {
  return t === void 0;
}
var useGridKeyboardNavigation = ({
  rowSize,
  start,
  end,
  onSelected,
  onFocusIndex
}) => {
  const focusedCellIndex = ref(-1);
  let previouslyClicked2 = false;
  const onMousedown = () => {
    previouslyClicked2 = true;
  };
  const onFocus = () => {
    if (previouslyClicked2) {
      return;
    }
    previouslyClicked2 = false;
    const index = onFocusIndex === void 0 ? unref(start) || 0 : unref(onFocusIndex);
    focusedCellIndex.value = index;
  };
  const onBlur = () => {
    previouslyClicked2 = false;
    focusedCellIndex.value = -1;
  };
  const onKeydown = (e) => {
    if (["ArrowRight", "ArrowLeft", "ArrowDown", "ArrowUp", "Enter", "Space"].includes(e.key)) {
      e.preventDefault();
      e.stopPropagation();
    }
    if (e.key === "Enter" || e.key === "Space") {
      if (onSelected === void 0) {
        return;
      }
      onSelected(focusedCellIndex.value);
      return;
    }
    if (e.key === "ArrowRight") {
      focusedCellIndex.value += 1;
    }
    if (e.key === "ArrowLeft") {
      focusedCellIndex.value -= 1;
    }
    if (e.key === "ArrowDown") {
      focusedCellIndex.value += rowSize;
    }
    if (e.key === "ArrowUp") {
      focusedCellIndex.value -= rowSize;
    }
    if (!isUndefined(start) && focusedCellIndex.value < unref(start)) {
      focusedCellIndex.value = unref(start);
    }
    if (!isUndefined(end) && focusedCellIndex.value > unref(end) - 1) {
      focusedCellIndex.value = unref(end) - 1;
    }
  };
  const containerAttributes = {
    onFocus,
    onKeydown,
    onBlur,
    onMousedown,
    tabindex: 0
  };
  return {
    focusedCellIndex,
    containerAttributes
  };
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-date-picker/hooks/model-value-helper.js
var modeInitialValue = (date, mode) => {
  if (mode === "single") {
    return date;
  } else if (mode === "range") {
    return { start: date, end: null };
  } else if (mode === "multiple") {
    return [date];
  } else if (mode === "auto") {
    return date;
  }
  throw new Error("Unknown mode");
};
var throwIncorrectModelValueError = (modelValue, mode) => {
  throw Error(`Incorrect modelValue for mode ${mode}. Got ${JSON.stringify(modelValue)}`);
};
var modeFromModelValue = (modelValue) => {
  if (isSingleDate2(modelValue)) {
    return "single";
  } else if (isRange3(modelValue)) {
    return "range";
  } else if (isDates(modelValue)) {
    return "multiple";
  }
  return throwIncorrectModelValueError(modelValue, "auto");
};
var sortRange = (modelValue) => {
  if (modelValue.start && modelValue.end) {
    if (modelValue.start > modelValue.end) {
      return { start: modelValue.end, end: modelValue.start };
    }
  }
  return modelValue;
};
var useDatePickerModelValue = (props, emit, dateEqual) => {
  const updateModelValue = (date) => {
    if (!props.modelValue) {
      emit("update:modelValue", modeInitialValue(date, props.mode));
      return;
    }
    const mode = props.mode === "auto" ? modeFromModelValue(props.modelValue) : props.mode;
    if (mode === "single") {
      if (!isSingleDate2(props.modelValue)) {
        return throwIncorrectModelValueError(props.modelValue, mode);
      }
      emit("update:modelValue", date);
    } else if (mode === "range") {
      if (!isRange3(props.modelValue)) {
        return throwIncorrectModelValueError(props.modelValue, mode);
      }
      if (props.modelValue.end && dateEqual(props.modelValue.end, date)) {
        return emit("update:modelValue", { start: props.modelValue.start, end: null });
      }
      if (props.modelValue.start && dateEqual(props.modelValue.start, date)) {
        return emit("update:modelValue", { start: null, end: props.modelValue.end });
      }
      if (props.modelValue.end === null) {
        return emit("update:modelValue", sortRange({ start: props.modelValue.start, end: date }));
      }
      if (props.modelValue.start === null) {
        return emit("update:modelValue", sortRange({ end: props.modelValue.end, start: date }));
      }
      emit("update:modelValue", { start: date, end: null });
    } else if (mode === "multiple") {
      if (!isDates(props.modelValue)) {
        return throwIncorrectModelValueError(props.modelValue, mode);
      }
      const isDatesIncludesDate = !!props.modelValue.find((d) => dateEqual(d, date));
      if (isDatesIncludesDate) {
        emit("update:modelValue", props.modelValue.filter((d) => !dateEqual(d, date)));
      } else {
        emit("update:modelValue", [...props.modelValue, date].sort((a, b) => a.getTime() - b.getTime()));
      }
    }
  };
  return {
    updateModelValue
  };
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-date-picker/hooks/use-picker.js
var getDateEqualFunction = (type) => {
  return {
    month: isDatesMonthEqual,
    day: isDatesDayEqual,
    year: isDatesYearEqual
  }[type];
};
var useDatePicker = (type, dates, props, emit) => {
  const datesEqual = getDateEqualFunction(type);
  const isAllowedDate = props.allowedDays || props.allowedMonths || props.allowedYears;
  const isDateDisabled = (date) => isAllowedDate === void 0 ? false : !isAllowedDate(date);
  const hoveredIndex = ref(-1);
  const hoveredValue = computed(() => dates.value[hoveredIndex.value]);
  const { updateModelValue } = useDatePickerModelValue(
    props,
    emit,
    datesEqual
  );
  const onClick = (date) => {
    if (props.readonly || isDateDisabled(date)) {
      return;
    }
    updateModelValue(date);
    emit(`click:${type}`, date);
  };
  const isToday = (date) => {
    const today = /* @__PURE__ */ new Date();
    return datesEqual(today, date);
  };
  const isSelected = (date) => {
    if (!props.modelValue) {
      return false;
    }
    if (isSingleDate2(props.modelValue)) {
      return datesEqual(props.modelValue, date);
    } else if (isDates(props.modelValue)) {
      return !!props.modelValue.find((d) => datesEqual(d, date));
    } else if (isRange3(props.modelValue)) {
      return datesEqual(props.modelValue.start, date) || datesEqual(props.modelValue.end, date);
    }
    return false;
  };
  const isInRange = (date) => {
    if (!props.modelValue) {
      return false;
    }
    if (!isRange3(props.modelValue)) {
      return false;
    }
    if (props.modelValue.start && props.modelValue.end) {
      return props.modelValue.start < date && props.modelValue.end > date;
    }
    const selectedDate = props.modelValue.start || props.modelValue.end;
    if (selectedDate) {
      if (!hoveredValue.value) {
        return false;
      }
      return selectedDate < date ? hoveredValue.value >= date : hoveredValue.value <= date;
    }
    return false;
  };
  watch(hoveredValue, (date) => {
    emit(`hover:${type}`, date);
  });
  return {
    hoveredIndex,
    hoveredValue,
    onClick,
    isToday,
    isSelected,
    isInRange
  };
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-date-picker/components/VaDayPicker/va-date-picker-calendar-hook.js
var getMonthDaysCount = (year, month) => new Date(year, month + 1, 0).getDate();
var getMonthStartWeekday = (year, month) => new Date(year, month, 1).getDay();
var getNumbersArray = (length) => Array.from(Array(length).keys()).map((k) => k + 1);
var useVaDatePickerCalendar = (view, options) => {
  const CALENDAR_ROWS_COUNT = 6;
  const localizeWeekday = (weekdayNumber) => {
    var _a2;
    if (options && ((_a2 = options.firstWeekday) == null ? void 0 : _a2.value) === "Monday") {
      return weekdayNumber === 0 ? 6 : weekdayNumber - 1;
    }
    return weekdayNumber;
  };
  const currentMonthStartWeekday = computed(() => localizeWeekday(getMonthStartWeekday(view.value.year, view.value.month)));
  const getPreviousDates = () => {
    if (currentMonthStartWeekday.value === 0) {
      return [];
    }
    const prevMonthDaysCount = getMonthDaysCount(view.value.year, view.value.month - 1);
    const prevMonthDays = getNumbersArray(prevMonthDaysCount);
    return prevMonthDays.slice(-currentMonthStartWeekday.value).map((d) => new Date(view.value.year, view.value.month - 1, d));
  };
  const getCurrentDates = () => {
    const currentMonthDays = getNumbersArray(getMonthDaysCount(view.value.year, view.value.month));
    return currentMonthDays.map((d) => new Date(view.value.year, view.value.month, d));
  };
  const prevAndCurrentDays = computed(() => [...getPreviousDates(), ...getCurrentDates()]);
  const currentMonthEndIndex = computed(() => prevAndCurrentDays.value.length);
  const calendarDates = computed(() => {
    const days = prevAndCurrentDays.value;
    const daysRemaining = 7 * CALENDAR_ROWS_COUNT - days.length;
    const nextMonthDaysCount = getMonthDaysCount(view.value.year, view.value.month + 1);
    const nextMonthDays = getNumbersArray(nextMonthDaysCount);
    return [
      ...days,
      ...nextMonthDays.slice(0, daysRemaining).map((d) => new Date(view.value.year, view.value.month + 1, d))
    ];
  });
  return { calendarDates, currentMonthStartIndex: currentMonthStartWeekday, currentMonthEndIndex };
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-date-picker/components/VaDayPicker/VaDayPicker.vue_vue_type_script_setup_true_lang.js
var _hoisted_129 = ["onMouseenter"];
var _hoisted_214 = { class: "va-date-picker-cell__day" };
var _sfc_main49 = defineComponent({
  ...{
    name: "VaDayPicker"
  },
  __name: "VaDayPicker",
  props: {
    monthNames: { type: Array, required: true },
    weekdayNames: { type: Array, required: true },
    firstWeekday: { type: String, default: "Sunday" },
    hideWeekDays: { type: Boolean, default: false },
    view: { type: Object, default: () => ({ type: "day" }) },
    modelValue: { type: [Date, Array, Object] },
    mode: { type: String, default: "auto" },
    showOtherMonths: { type: Boolean, default: false },
    allowedDays: { type: Function },
    weekends: { type: Function },
    highlightWeekend: { type: Boolean, default: false },
    highlightToday: { type: Boolean, default: false },
    readonly: { type: Boolean, default: false },
    color: { type: String, default: "primary" }
  },
  emits: ["update:modelValue", "hover:day", "click:day"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const { firstWeekday, weekdayNames, view } = toRefs(props);
    const { calendarDates, currentMonthStartIndex, currentMonthEndIndex } = useVaDatePickerCalendar(view, { firstWeekday });
    const weekdayNamesComputed = computed(() => {
      return firstWeekday.value === "Sunday" ? weekdayNames.value : [...weekdayNames.value.slice(1), weekdayNames.value[0]];
    });
    const {
      hoveredIndex,
      onClick,
      isToday,
      isSelected,
      isInRange
    } = useDatePicker("day", calendarDates, props, emit);
    const gridStartIndex = computed(() => props.showOtherMonths ? 0 : currentMonthStartIndex.value);
    const gridEndIndex = computed(() => props.showOtherMonths ? calendarDates.value.length : currentMonthEndIndex.value);
    const {
      focusedCellIndex,
      containerAttributes
    } = useGridKeyboardNavigation({
      rowSize: 7,
      start: gridStartIndex,
      end: gridEndIndex,
      onSelected: (selectedValue) => onClick(calendarDates.value[selectedValue])
    });
    watch(focusedCellIndex, (index) => {
      hoveredIndex.value = index;
    });
    watch(hoveredIndex, (index) => {
      focusedCellIndex.value = index;
    });
    const isOtherMonth = (date) => props.view.month !== date.getMonth();
    const isDateDisabled = (date) => props.allowedDays === void 0 ? false : !props.allowedDays(date);
    const isDateWeekend = (date) => {
      if (props.weekends === void 0) {
        return date.getDay() === 6 || date.getDay() === 0;
      }
      return props.weekends(date);
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", mergeProps({ class: "va-day-picker" }, unref(containerAttributes)), [
        !__props.hideWeekDays ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(weekdayNamesComputed.value, (weekday) => {
          return openBlock(), createElementBlock("div", {
            key: weekday,
            class: "va-day-picker__weekday"
          }, [
            renderSlot(_ctx.$slots, "weekday", {}, () => [
              createTextVNode(toDisplayString(weekday), 1)
            ])
          ]);
        }), 128)) : createCommentVNode("", true),
        (openBlock(true), createElementBlock(Fragment, null, renderList(unref(calendarDates), (date, index) => {
          return openBlock(), createElementBlock("div", {
            class: "va-day-picker__calendar__day-wrapper",
            key: index,
            onMouseenter: ($event) => hoveredIndex.value = index,
            onMouseleave: _cache[0] || (_cache[0] = ($event) => hoveredIndex.value = -1)
          }, [
            createVNode(VaDatePickerCell, {
              hidden: isOtherMonth(date) && !__props.showOtherMonths,
              today: unref(isToday)(date),
              selected: unref(isSelected)(date),
              "in-range": unref(isInRange)(date),
              "other-month": isOtherMonth(date),
              weekend: isDateWeekend(date),
              disabled: isDateDisabled(date),
              focused: unref(hoveredIndex) === index,
              "highlight-today": __props.highlightToday,
              "highlight-weekend": __props.highlightWeekend,
              readonly: _ctx.$props.readonly,
              color: __props.color,
              onClick: ($event) => {
                unref(onClick)(date);
                focusedCellIndex.value = index;
              }
            }, {
              default: withCtx(() => [
                createBaseVNode("span", _hoisted_214, [
                  renderSlot(_ctx.$slots, "day", normalizeProps(guardReactiveProps({ date })), () => [
                    createTextVNode(toDisplayString(date.getDate()), 1)
                  ])
                ])
              ]),
              _: 2
            }, 1032, ["hidden", "today", "selected", "in-range", "other-month", "weekend", "disabled", "focused", "highlight-today", "highlight-weekend", "readonly", "color", "onClick"])
          ], 40, _hoisted_129);
        }), 128))
      ], 16);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-date-picker/components/VaDayPicker/VaDayPicker.js
var _style_045 = ".va-day-picker {\n  display: grid;\n  grid-template-columns: repeat(7, 1fr);\n  grid-gap: var(--va-date-picker-cell-gap);\n}\n.va-day-picker__weekday {\n  height: var(--va-date-picker-cell-size);\n  color: var(--va-secondary);\n  text-align: center;\n  font-size: var(--va-date-picker-weekday-font-size);\n  font-weight: bold;\n  line-height: var(--va-date-picker-cell-size);\n}";
var VaDayPicker = _export_sfc(_sfc_main49, [["styles", [_style_045]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-date-picker/components/VaDatePickerHeader/VaDatePickerHeader.vue_vue_type_script_setup_true_lang.js
var _hoisted_130 = {
  key: 0,
  class: "va-date-picker-header va-date-picker__header"
};
var _hoisted_215 = { class: "va-date-picker__header__text" };
var _hoisted_39 = { class: "va-date-picker__header__month" };
var _sfc_main50 = defineComponent({
  ...{
    name: "VaDatePickerHeader"
  },
  __name: "VaDatePickerHeader",
  props: {
    monthNames: { type: Array, required: true },
    view: { type: Object },
    color: { type: String },
    disabled: { type: Boolean, default: false },
    ariaNextPeriodLabel: { type: String, default: "$t:nextPeriod" },
    ariaPreviousPeriodLabel: { type: String, default: "$t:previousPeriod" },
    ariaSwitchViewLabel: { type: String, default: "$t:switchView" }
  },
  emits: ["update:view"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const { syncView, prev, next } = useView(props, emit);
    const switchView = () => {
      if (syncView.value.type === "day") {
        syncView.value = { ...syncView.value, type: "month" };
      } else if (syncView.value.type === "month") {
        syncView.value = { ...syncView.value, type: "year" };
      }
    };
    const changeView = (view) => {
      syncView.value = view;
    };
    const currentColor = useElementTextColor(useElementBackground(useCurrentElement()));
    const { tp } = useTranslation();
    return (_ctx, _cache) => {
      return unref(syncView).type !== "year" ? (openBlock(), createElementBlock("div", _hoisted_130, [
        renderSlot(_ctx.$slots, "buttonPrev", normalizeProps(guardReactiveProps({ onClick: unref(prev) })), () => [
          createVNode(unref(VaButton), {
            disabled: _ctx.$props.disabled,
            icon: "va-arrow-left",
            preset: "plain",
            size: "small",
            color: __props.color,
            textColor: unref(currentColor),
            "aria-label": unref(tp)(_ctx.$props.ariaPreviousPeriodLabel),
            round: "",
            onClick: unref(prev)
          }, null, 8, ["disabled", "color", "textColor", "aria-label", "onClick"])
        ]),
        createBaseVNode("div", _hoisted_215, [
          renderSlot(_ctx.$slots, "header", normalizeProps(guardReactiveProps({ year: unref(syncView).year, month: unref(syncView).month, monthNames: __props.monthNames, view: unref(syncView), changeView, switchView })), () => [
            createVNode(unref(VaButton), {
              disabled: _ctx.$props.disabled,
              preset: "plain",
              size: "small",
              color: __props.color,
              textColor: unref(currentColor),
              "aria-label": unref(tp)(_ctx.$props.ariaSwitchViewLabel),
              onClick: switchView
            }, {
              default: withCtx(() => [
                renderSlot(_ctx.$slots, "year", normalizeProps(guardReactiveProps({ year: unref(syncView).year })), () => [
                  createTextVNode(toDisplayString(unref(syncView).year), 1)
                ]),
                unref(syncView).type === "day" ? renderSlot(_ctx.$slots, "month", normalizeProps(mergeProps({ key: 0 }, { month: unref(syncView).month })), () => [
                  createBaseVNode("span", _hoisted_39, toDisplayString(__props.monthNames[unref(syncView).month]), 1)
                ]) : createCommentVNode("", true)
              ]),
              _: 3
            }, 8, ["disabled", "color", "textColor", "aria-label"])
          ])
        ]),
        renderSlot(_ctx.$slots, "buttonNext", normalizeProps(guardReactiveProps({ onClick: unref(next) })), () => [
          createVNode(unref(VaButton), {
            disabled: _ctx.$props.disabled,
            icon: "va-arrow-right",
            preset: "plain",
            size: "small",
            color: __props.color,
            textColor: unref(currentColor),
            "aria-label": unref(tp)(_ctx.$props.ariaNextPeriodLabel),
            onClick: unref(next),
            round: ""
          }, null, 8, ["disabled", "color", "textColor", "aria-label", "onClick"])
        ])
      ])) : createCommentVNode("", true);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-date-picker/components/VaDatePickerHeader/VaDatePickerHeader.js
var _style_046 = ".va-date-picker {\n  color: currentColor;\n}\n.va-date-picker__header {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n}\n.va-date-picker__header__text {\n  color: currentColor;\n}\n.va-date-picker__header__month {\n  margin-left: 0.25rem;\n}";
var VaDatePickerHeader = _export_sfc(_sfc_main50, [["styles", [_style_046]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-date-picker/components/VaMonthPicker/VaMonthPicker.vue_vue_type_script_setup_true_lang.js
var _hoisted_131 = ["onMouseenter"];
var _sfc_main51 = defineComponent({
  ...{
    name: "VaMonthPicker"
  },
  __name: "VaMonthPicker",
  props: {
    modelValue: { type: [Date, Array, Object] },
    monthNames: { type: Array, required: true },
    view: { type: Object, default: () => ({ type: "month" }) },
    allowedMonths: { type: Function, default: void 0 },
    highlightToday: { type: Boolean, default: true },
    mode: { type: String, default: "auto" },
    readonly: { type: Boolean, default: false },
    color: { type: String, default: "primary" }
  },
  emits: ["update:modelValue", "hover:month", "click:month"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const { view } = toRefs(props);
    const months = computed(() => Array.from(Array(12).keys()).map((month) => new Date(view.value.year, month)));
    const {
      hoveredIndex,
      onClick,
      isToday,
      isSelected,
      isInRange
    } = useDatePicker("month", months, props, emit);
    const isDisabled = (date) => props.allowedMonths === void 0 ? false : !props.allowedMonths(date);
    const {
      focusedCellIndex,
      containerAttributes
    } = useGridKeyboardNavigation({
      rowSize: 3,
      start: 0,
      end: months.value.length,
      onSelected: (selectedIndex) => onClick(months.value[selectedIndex])
    });
    watch(focusedCellIndex, (index) => {
      hoveredIndex.value = index;
    });
    watch(hoveredIndex, (index) => {
      focusedCellIndex.value = index;
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", mergeProps({ class: "va-month-picker" }, unref(containerAttributes)), [
        (openBlock(true), createElementBlock(Fragment, null, renderList(months.value, (month, monthIndex) => {
          return openBlock(), createElementBlock("div", {
            key: monthIndex,
            class: "va-month-picker__month-wrapper",
            onMouseenter: ($event) => hoveredIndex.value = monthIndex,
            onMouseleave: _cache[0] || (_cache[0] = ($event) => hoveredIndex.value = -1)
          }, [
            createVNode(VaDatePickerCell, {
              "in-range": !!unref(isInRange)(month),
              selected: !!unref(isSelected)(month),
              disabled: !!isDisabled(month),
              today: !!unref(isToday)(month),
              focused: unref(hoveredIndex) === monthIndex,
              "highlight-today": __props.highlightToday,
              readonly: _ctx.$props.readonly,
              color: __props.color,
              onClick: ($event) => {
                unref(onClick)(month);
                focusedCellIndex.value = monthIndex;
              }
            }, {
              default: withCtx(() => [
                renderSlot(_ctx.$slots, "month", normalizeProps(guardReactiveProps({ monthIndex, month: __props.monthNames[monthIndex] })), () => [
                  createTextVNode(toDisplayString(__props.monthNames[monthIndex]), 1)
                ])
              ]),
              _: 2
            }, 1032, ["in-range", "selected", "disabled", "today", "focused", "highlight-today", "readonly", "color", "onClick"])
          ], 40, _hoisted_131);
        }), 128))
      ], 16);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-date-picker/components/VaMonthPicker/VaMonthPicker.js
var _style_047 = ".va-month-picker {\n  display: grid;\n  grid-template-columns: repeat(3, 1fr);\n  grid-gap: var(--va-date-picker-cell-gap);\n  min-width: calc(var(--va-date-picker-cell-size) * 7 + var(--va-date-picker-cell-gap) * 6);\n  width: 100%;\n}\n.va-month-picker__month-wrapper {\n  border-radius: var(--va-date-picker-cell-radius);\n  text-align: center;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n          user-select: none;\n  overflow: hidden;\n}";
var VaMonthPicker = _export_sfc(_sfc_main51, [["styles", [_style_047]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-date-picker/components/VaYearPicker/VaYearPicker.vue_vue_type_script_setup_true_lang.js
var _sfc_main52 = defineComponent({
  ...{
    name: "VaYearPicker"
  },
  __name: "VaYearPicker",
  props: {
    modelValue: { type: [Date, Array, Object] },
    allowedYears: { type: Function, default: void 0 },
    highlightToday: { type: Boolean, default: true },
    startYear: { type: Number, default: 1970 },
    mode: { type: String, default: "auto" },
    view: { type: Object, default: () => ({ type: "year" }) },
    endYear: { type: Number, default: () => (/* @__PURE__ */ new Date()).getFullYear() + 50 },
    readonly: { type: Boolean, default: false },
    color: { type: String, default: "primary" }
  },
  emits: ["update:modelValue", "hover:year", "click:year"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const rootNode = shallowRef();
    const { view } = toRefs(props);
    const generateYearsArray = (start, end) => {
      const yearsCount = end - start + 1;
      return Array.from(Array(yearsCount).keys()).map((i) => createYearDate(start + i));
    };
    const years = computed(() => generateYearsArray(props.startYear, props.endYear));
    const scrollIntoYearIndex = (index) => {
      if (!rootNode.value) {
        return;
      }
      const scrollHeight = rootNode.value.scrollHeight;
      const rootNodeHeight = rootNode.value.offsetHeight;
      const currentYearOffset = scrollHeight / years.value.length * index;
      const cellSize = scrollHeight / years.value.length;
      const relativeScrollPosition = currentYearOffset - rootNode.value.scrollTop;
      if (relativeScrollPosition < 0) {
        rootNode.value.scrollTo({ top: currentYearOffset });
      } else if (relativeScrollPosition > rootNodeHeight) {
        rootNode.value.scrollTo({ top: currentYearOffset - rootNodeHeight + cellSize });
      }
    };
    const scrollIntoYearIndexCenter = (index) => {
      if (!rootNode.value) {
        return;
      }
      const scrollHeight = rootNode.value.scrollHeight;
      const rootNodeHeight = rootNode.value.offsetHeight;
      const currentYearOffset = scrollHeight / years.value.length * index;
      rootNode.value.scrollTo({ top: currentYearOffset - rootNodeHeight / 2 });
    };
    onMounted(() => {
      const currentYearIndex = years.value.findIndex((date) => date.getFullYear() === view.value.year);
      scrollIntoYearIndexCenter(currentYearIndex);
    });
    const {
      hoveredIndex,
      onClick,
      isToday,
      isSelected,
      isInRange
    } = useDatePicker("year", years, props, emit);
    const isYearDisabled = (year) => props.allowedYears === void 0 ? false : !props.allowedYears(year);
    const {
      focusedCellIndex,
      containerAttributes
    } = useGridKeyboardNavigation({
      rowSize: 1,
      start: 0,
      end: years.value.length,
      onFocusIndex: computed(() => years.value.findIndex((date) => date.getFullYear() === view.value.year)),
      onSelected: (selectedIndex) => onClick(years.value[selectedIndex])
    });
    watch(focusedCellIndex, (index) => index !== -1 && scrollIntoYearIndex(index));
    watch(focusedCellIndex, (index) => {
      hoveredIndex.value = index;
    });
    watch(hoveredIndex, (index) => {
      focusedCellIndex.value = index;
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", mergeProps({
        ref_key: "rootNode",
        ref: rootNode,
        class: "va-year-picker"
      }, unref(containerAttributes), {
        onKeydown: _cache[1] || (_cache[1] = withKeys(withModifiers(() => {
        }, ["prevent"]), ["space"]))
      }), [
        (openBlock(true), createElementBlock(Fragment, null, renderList(years.value, (year, index) => {
          return openBlock(), createBlock(VaDatePickerCell, {
            key: year.toString(),
            "in-range": unref(isInRange)(year),
            selected: unref(isSelected)(year),
            disabled: isYearDisabled(year),
            today: unref(isToday)(year),
            focused: unref(focusedCellIndex) === index,
            "highlight-today": __props.highlightToday,
            readonly: _ctx.$props.readonly,
            color: __props.color,
            onClick: ($event) => {
              unref(onClick)(year);
              focusedCellIndex.value = index;
            },
            onMouseenter: ($event) => hoveredIndex.value = index,
            onMouseleave: _cache[0] || (_cache[0] = ($event) => hoveredIndex.value = -1)
          }, {
            default: withCtx(() => [
              createTextVNode(toDisplayString(year.getFullYear()), 1)
            ]),
            _: 2
          }, 1032, ["in-range", "selected", "disabled", "today", "focused", "highlight-today", "readonly", "color", "onClick", "onMouseenter"]);
        }), 128))
      ], 16);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-date-picker/components/VaYearPicker/VaYearPicker.js
var _style_048 = ".va-year-picker {\n  display: flex;\n  flex-direction: column;\n  overflow: auto;\n  grid-gap: var(--va-date-picker-cell-gap);\n  max-height: 100%;\n  position: relative;\n  scrollbar-color: var(--va-background-element) transparent;\n  scrollbar-width: thin;\n  transition: scrollbar-color 0.3s ease-in-out;\n}\n.va-year-picker::-webkit-scrollbar {\n  width: 4px;\n  height: 4px;\n}\n.va-year-picker::-webkit-scrollbar-track {\n  box-shadow: none;\n  border-radius: 10px;\n}\n.va-year-picker::-webkit-scrollbar-thumb {\n  background: var(--va-background-element);\n  opacity: 0.3;\n  border-radius: 2px;\n  -webkit-transition: background 0.3s ease-in-out;\n  transition: background 0.3s ease-in-out;\n}";
var VaYearPicker = _export_sfc(_sfc_main52, [["styles", [_style_048]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-date-picker/VaDatePicker.vue_vue_type_script_setup_true_lang.js
var _hoisted_132 = { class: "va-date-picker__picker-wrapper" };
var DEFAULT_MONTH_NAMES = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
var DEFAULT_WEEKDAY_NAMES = ["SU", "MO", "TU", "WE", "TH", "FR", "SA"];
var _sfc_main53 = defineComponent({
  ...{
    name: "VaDatePicker"
  },
  __name: "VaDatePicker",
  props: {
    ...useStatefulProps,
    ...useComponentPresetProp,
    ...extractComponentProps(VaDatePickerHeader),
    ...extractComponentProps(VaDayPicker),
    ...extractComponentProps(VaMonthPicker),
    ...extractComponentProps(VaYearPicker),
    modelValue: { type: [Date, Array, Object] },
    monthNames: { type: Array, default: DEFAULT_MONTH_NAMES },
    weekdayNames: { type: Array, default: DEFAULT_WEEKDAY_NAMES },
    view: { type: Object },
    type: { type: String, default: "day" },
    readonly: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false },
    // Colors
    color: { type: String, default: void 0 },
    weekendsColor: { type: String, default: void 0 }
  },
  emits: [
    ...useStatefulEmits,
    ...extractComponentEmits(VaDatePickerHeader),
    ...extractComponentEmits(VaYearPicker),
    ...extractComponentEmits(VaDayPicker),
    ...extractComponentEmits(VaMonthPicker)
  ],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const currentPicker = ref();
    const { valueComputed } = useStateful(props, emit);
    const { syncView } = useView(props, emit, { type: props.type });
    const classComputed = computed(() => ({
      "va-date-picker_without-week-days": props.hideWeekDays,
      "va-date-picker_disabled": props.disabled
    }));
    const onDayModelValueUpdate = (modelValue) => {
      if (props.readonly) {
        return;
      }
      if (props.type === "day") {
        valueComputed.value = modelValue;
      }
    };
    const onMonthClick = (date) => {
      emit("click:month", date);
      const year = date.getFullYear();
      const month = date.getMonth();
      if (props.type !== "month") {
        syncView.value = { type: "day", year, month };
      }
    };
    const onMonthModelValueUpdate = (modelValue) => {
      if (props.type === "month") {
        valueComputed.value = modelValue;
      }
    };
    const onYearClick = (date) => {
      emit("click:year", date);
      const year = date.getFullYear();
      if (props.type !== "year") {
        syncView.value = { type: "month", year, month: syncView.value.month };
      }
    };
    const onYearModelValueUpdate = (modelValue) => {
      if (props.type === "year") {
        valueComputed.value = modelValue;
      }
    };
    const { colorsToCSSVariable } = useColors();
    const styleComputed = computed(() => ({
      ...colorsToCSSVariable({
        color: props.color,
        "weekends-color": props.weekendsColor
      }, "va-date-picker")
    }));
    const focusCurrentPicker = () => {
      var _a2;
      return (_a2 = currentPicker.value) == null ? void 0 : _a2.$el.focus();
    };
    watch(syncView, (newValue, prevValue) => {
      if (newValue.type === prevValue.type) {
        return;
      }
      nextTick(focusCurrentPicker);
    });
    const isPickerReadonly = (pickerName) => {
      return props.readonly && props.type === pickerName;
    };
    const dayPickerProps = filterComponentProps(extractComponentProps(VaDayPicker));
    const headerProps = filterComponentProps(extractComponentProps(VaDatePickerHeader));
    const monthPickerProps = filterComponentProps(extractComponentProps(VaMonthPicker));
    const yearPickerProps = filterComponentProps(extractComponentProps(VaYearPicker));
    __expose({
      focus: focusCurrentPicker,
      focusCurrentPicker
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["va-date-picker", classComputed.value]),
        style: normalizeStyle(styleComputed.value)
      }, [
        createVNode(VaDatePickerHeader, mergeProps(unref(headerProps), {
          view: unref(syncView),
          "onUpdate:view": _cache[0] || (_cache[0] = ($event) => isRef(syncView) ? syncView.value = $event : null)
        }), createSlots({ _: 2 }, [
          renderList(_ctx.$slots, (_, name) => {
            return {
              name,
              fn: withCtx((bind) => [
                renderSlot(_ctx.$slots, name, normalizeProps(guardReactiveProps(bind)))
              ])
            };
          })
        ]), 1040, ["view"]),
        createBaseVNode("div", _hoisted_132, [
          unref(syncView).type === "day" ? (openBlock(), createBlock(VaDayPicker, mergeProps({
            key: 0,
            ref_key: "currentPicker",
            ref: currentPicker
          }, unref(dayPickerProps), {
            "model-value": unref(valueComputed),
            view: unref(syncView),
            readonly: _ctx.$props.disabled || isPickerReadonly("day"),
            "onUpdate:modelValue": onDayModelValueUpdate,
            "onHover:day": _cache[1] || (_cache[1] = (value) => _ctx.$emit("hover:day", value)),
            "onClick:day": _cache[2] || (_cache[2] = (value) => _ctx.$emit("click:day", value))
          }), createSlots({ _: 2 }, [
            renderList(_ctx.$slots, (_, name) => {
              return {
                name,
                fn: withCtx((bind) => [
                  renderSlot(_ctx.$slots, name, normalizeProps(guardReactiveProps(bind)))
                ])
              };
            })
          ]), 1040, ["model-value", "view", "readonly"])) : createCommentVNode("", true),
          unref(syncView).type === "month" ? (openBlock(), createBlock(VaMonthPicker, mergeProps({
            key: 1,
            ref_key: "currentPicker",
            ref: currentPicker
          }, unref(monthPickerProps), {
            view: unref(syncView),
            "model-value": unref(valueComputed),
            readonly: _ctx.$props.disabled || isPickerReadonly("month"),
            "onUpdate:modelValue": onMonthModelValueUpdate,
            "onHover:month": _cache[3] || (_cache[3] = (value) => _ctx.$emit("hover:month", value)),
            "onClick:month": onMonthClick
          }), createSlots({ _: 2 }, [
            renderList(_ctx.$slots, (_, name) => {
              return {
                name,
                fn: withCtx((bind) => [
                  renderSlot(_ctx.$slots, name, normalizeProps(guardReactiveProps(bind)))
                ])
              };
            })
          ]), 1040, ["view", "model-value", "readonly"])) : createCommentVNode("", true),
          unref(syncView).type === "year" ? (openBlock(), createBlock(VaYearPicker, mergeProps({
            key: 2,
            ref_key: "currentPicker",
            ref: currentPicker
          }, unref(yearPickerProps), {
            view: unref(syncView),
            "model-value": unref(valueComputed),
            readonly: _ctx.$props.disabled || isPickerReadonly("year"),
            "onHover:year": _cache[4] || (_cache[4] = (value) => _ctx.$emit("hover:year", value)),
            "onUpdate:modelValue": onYearModelValueUpdate,
            "onClick:year": onYearClick
          }), createSlots({ _: 2 }, [
            renderList(_ctx.$slots, (_, name) => {
              return {
                name,
                fn: withCtx((bind) => [
                  renderSlot(_ctx.$slots, name, normalizeProps(guardReactiveProps(bind)))
                ])
              };
            })
          ]), 1040, ["view", "model-value", "readonly"])) : createCommentVNode("", true)
        ])
      ], 6);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-date-picker/VaDatePicker.js
var _style_049 = ':root,\n:host {\n  /* Font */\n  --va-date-picker-font-style: normal;\n  --va-date-picker-font-weight: 600;\n  --va-date-picker-font-size: 12px;\n  --va-date-picker-line-height: 1.25;\n  --va-date-picker-weekday-font-size: 9px;\n  /* Colors */\n  --va-date-picker-color: var(--va-primary);\n  --va-date-picker-text-color: inherit;\n  /* Sizes */\n  --va-date-picker-cell-size: 32px;\n  --va-date-picker-cell-gap: 2px;\n  --va-date-picker-cell-radius: 4px;\n  /* Selected cell */\n  --va-date-picker-selected-text: var(--va-text-inverted);\n  --va-date-picker-selected-background: var(--va-date-picker-color);\n  /* Today cell */\n  --va-date-picker-today-background: var(--va-date-picker-color);\n  --va-date-picker-today-background-opacity: 0.8;\n  /* Weekend */\n  --va-date-picker-weekends-color: var(--va-danger);\n  /* Focused */\n  --va-date-picker-focused-border-color: var(--va-date-picker-color);\n  /* Opacity */\n  --va-date-picker-cell-opacity: 0.5;\n  --va-date-picker-cell-background-opacity-hover: 0.1;\n  --va-date-picker-cell-background-opacity-in-range: 0.2;\n  --va-date-picker-cell-selected-background-opacity-hover: 0.8;\n}\n.va-date-picker {\n  --va-date-picker-content-height: calc(var(--va-date-picker-cell-size) * 7 + var(--va-date-picker-cell-gap) * 6);\n  width: calc(var(--va-date-picker-cell-size) * 7 + var(--va-date-picker-cell-gap) * 6);\n  font-family: var(--va-font-family);\n  font-style: var(--va-date-picker-font-style);\n  font-weight: var(--va-date-picker-font-weight);\n  font-size: var(--va-date-picker-font-size);\n  line-height: var(--va-date-picker-line-height);\n  color: currentColor;\n}\n.va-date-picker__picker-wrapper {\n  height: var(--va-date-picker-content-height);\n}\n.va-date-picker_without-week-days {\n  --va-date-picker-content-height: calc(var(--va-date-picker-cell-size) * 6 + var(--va-date-picker-cell-gap) * 6);\n}\n.va-date-picker_mobile .va-day-picker,\n.va-date-picker_mobile .va-month-picker,\n.va-date-picker_mobile .va-year-picker {\n  height: 100%;\n}\n.va-date-picker_disabled {\n  opacity: 0.4;\n  position: relative;\n}\n.va-date-picker_disabled::before {\n  content: "";\n  position: absolute;\n  height: 100%;\n  width: 100%;\n  z-index: 100;\n}\n.va-date-picker-header {\n  padding-bottom: 0.25rem;\n}';
var _VaDatePicker = _export_sfc(_sfc_main53, [["styles", [_style_049]]]);

// node_modules/vuestic-ui/dist/web-components/src/composables/useDropdownable.js
var VaDropdownProps2 = extractComponentProps(
  VaDropdown,
  ["innerAnchorSelector", "stateful", "keyboardNavigation", "modelValue"]
);
var useDropdownableProps = {
  ...VaDropdownProps2,
  modelValue: {},
  /**
   * Close dropdown on value updated.
   * @default null - behavior controlled by component
   */
  closeOnChange: { type: Boolean, default: null },
  isOpen: { type: Boolean, default: void 0 }
};
var useDropdownableEmits = ["update:isOpen"];
var useDropdownable = function(props, emit, options = {}) {
  const [isOpenSync] = useSyncProp("isOpen", props, emit, false);
  const doWatch = computed(() => props.closeOnChange !== null ? props.closeOnChange : unref(options.defaultCloseOnValueUpdate || false));
  watch(() => props.modelValue, () => {
    if (doWatch.value) {
      isOpenSync.value = false;
    }
  });
  return {
    dropdownProps: filterComponentProps(VaDropdownProps2),
    isOpenSync
  };
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-date-input/VaDateInput.vue_vue_type_script_setup_true_lang.js
var VaInputWrapperPropsDeclaration = extractComponentProps(VaInputWrapper, ["focused", "maxLength", "counterValue"]);
var VaDatePickerPropsDeclaration = extractComponentProps(_VaDatePicker);
var _sfc_main54 = defineComponent({
  ...{
    name: "VaDateInput",
    inheritAttrs: false
  },
  __name: "VaDateInput",
  props: {
    ...useDropdownableProps,
    ...useClearableProps,
    ...VaInputWrapperPropsDeclaration,
    ...VaDatePickerPropsDeclaration,
    ...useValidationProps,
    ...useComponentPresetProp,
    clearValue: { type: Date, default: void 0 },
    modelValue: { type: [Date, Array, Object, String, Number] },
    resetOnClose: { type: Boolean, default: true },
    closeOnContentClick: { type: Boolean, default: false },
    offset: { ...useDropdownableProps.offset, default: () => [2, 0] },
    format: { type: Function },
    formatDate: { type: Function, default: (d) => d.toLocaleDateString() },
    /** Force model value to string instead of date */
    formatValue: { type: Function },
    parse: { type: Function },
    parseDate: { type: Function },
    delimiter: { type: String, default: ", " },
    rangeDelimiter: { type: String, default: " ~ " },
    manualInput: { type: Boolean, default: false },
    color: { type: String, default: "primary" },
    leftIcon: { type: Boolean, default: false },
    icon: { type: String, default: "va-calendar" },
    ariaToggleDropdownLabel: { type: String, default: "$t:toggleDropdown" },
    ariaResetLabel: { type: String, default: "$t:resetDate" },
    ariaSelectedDateLabel: { type: String, default: "$t:selectedDate" }
  },
  emits: [
    ...useFocusEmits,
    ...extractComponentEmits(_VaDatePicker),
    ...useClearableEmits,
    ...useValidationEmits,
    ...useStatefulEmits,
    ...useDropdownableEmits,
    "update:text"
  ],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const input = shallowRef();
    const datePicker = ref();
    const { resetOnClose } = toRefs(props);
    const { trapFocusIn, freeFocus } = useTrapFocus();
    const trapFocus = () => {
      const el = unwrapEl(datePicker.value);
      if (!el) {
        freeFocus();
        return;
      }
      trapFocusIn(el);
    };
    watch([datePicker], () => {
      trapFocus();
    });
    const { valueComputed: statefulValue } = useStateful(props, emit);
    const { isOpenSync, dropdownProps } = useDropdownable(props, emit, {
      defaultCloseOnValueUpdate: computed(() => {
        if (Array.isArray(valueComputed.value)) {
          return false;
        }
        if (isRange3(valueComputed.value) && valueComputed.value.end === null) {
          return false;
        }
        return true;
      })
    });
    const isRangeModelValueGuardDisabled = computed(() => !resetOnClose.value);
    const {
      valueComputed,
      reset: resetInvalidRange
    } = useRangeModelValueGuard(statefulValue, isRangeModelValueGuardDisabled);
    watch(isOpenSync, (isOpened) => {
      if (!isOpened && !isRangeModelValueGuardDisabled.value) {
        resetInvalidRange();
      }
    });
    const { isFocused: isInputFocused, focus, blur, onFocus: focusListener, onBlur: blurListener } = useFocus(input);
    const isPickerFocused = useFocusDeep(datePicker);
    const dateOrNothing = (date) => date ? props.formatDate(date) : "...";
    const { parseDateInputValue, isValid } = useDateParser(props);
    watch(valueComputed, () => {
      isValid.value = true;
    });
    const modelValueToString = (value) => {
      if (props.format) {
        return props.format(valueComputed.value);
      }
      if (isDates(value)) {
        return value.map((d) => props.formatDate(d)).join(props.delimiter);
      }
      if (isSingleDate2(value)) {
        return props.formatDate(value);
      }
      if (isRange3(value)) {
        return dateOrNothing(value.start) + props.rangeDelimiter + dateOrNothing(value.end);
      }
      if (value === null || value === void 0) {
        return "";
      }
      throw new Error("VaDatePicker: Invalid model value. Value should be Date, Date[] or { start: Date, end: Date | null }, got " + typeof value);
    };
    const {
      text,
      normalized: valueWithoutText
    } = useDateInputModelValue(statefulValue, toRef(props, "mode"), parseDateInputValue, modelValueToString, props.formatValue);
    const valueText = computed(() => {
      if (!isValid.value) {
        return "";
      }
      if (!valueComputed.value) {
        if (!props.clearValue) {
          return "";
        }
        return modelValueToString(props.clearValue);
      }
      return text.value;
    });
    const onInputTextChanged = ({ target }) => {
      if (props.disabled) {
        return;
      }
      const parsedValue = parseDateInputValue(target.value);
      if (isValid.value) {
        valueComputed.value = parsedValue;
      }
    };
    const reset = () => withoutValidation(() => {
      statefulValue.value = props.clearValue;
      emit("clear");
      resetValidation();
    });
    const hideAndFocus = () => {
      isOpenSync.value = false;
      focus();
    };
    const focusDatePicker = () => {
      nextTick(() => {
        var _a2;
        return (_a2 = datePicker.value) == null ? void 0 : _a2.focusCurrentPicker();
      });
    };
    const focusInputOrPicker = () => {
      isOpenSync.value ? focusDatePicker() : focus();
    };
    const checkProhibitedDropdownOpening = (e) => {
      if (isOpenSync.value) {
        return false;
      }
      if (props.disabled || props.readonly) {
        return true;
      }
      if (e === void 0) {
        return false;
      }
      return props.manualInput && (e == null ? void 0 : e.code) !== "Space";
    };
    const toggleDropdown = (event) => {
      if (checkProhibitedDropdownOpening(event instanceof KeyboardEvent ? event : void 0)) {
        return;
      }
      isOpenSync.value = !isOpenSync.value;
      nextTick(focusInputOrPicker);
    };
    const showDropdown = () => {
      if (props.disabled || props.readonly) {
        return;
      }
      isOpenSync.value = true;
      nextTick(focusDatePicker);
    };
    const {
      computedError,
      computedErrorMessages,
      listeners,
      validationAriaAttributes,
      validate,
      withoutValidation,
      resetValidation
    } = useValidation(props, emit, { reset, focus, value: valueComputed });
    const hasError = computed(() => !isValid.value && valueComputed.value !== props.clearValue || computedError.value);
    const slots = useSlots();
    const filterSlots = computed(() => {
      const slotsWithIcons = [
        props.leftIcon && "prependInner",
        (!props.leftIcon || props.clearable) && "icon"
      ];
      return Object.keys(slots).filter((slot) => !slotsWithIcons.includes(slot));
    });
    const {
      canBeCleared,
      clearIconProps,
      onFocus,
      onBlur
    } = useClearable(props, valueComputed);
    const cursorStyleComputed = computed(() => {
      if (props.disabled) {
        return {};
      }
      if (props.manualInput) {
        return { cursor: "text" };
      }
      return { cursor: "pointer" };
    });
    const iconTabindexComputed = computed(() => {
      if (!props.manualInput) {
        return -1;
      }
      return props.disabled || props.readonly ? -1 : 0;
    });
    const iconProps = computed(() => ({
      role: iconTabindexComputed.value === 0 ? "button" : "none",
      ariaHidden: iconTabindexComputed.value === -1,
      name: props.icon,
      color: "secondary",
      tabindex: iconTabindexComputed.value
    }));
    const filteredWrapperProps = filterComponentProps(VaInputWrapperPropsDeclaration);
    const computedInputWrapperProps = computed(() => ({
      ...filteredWrapperProps.value,
      focused: isInputFocused.value || isPickerFocused.value,
      error: hasError.value,
      errorMessages: computedErrorMessages.value,
      readonly: props.readonly || !props.manualInput
    }));
    const computedInputListeners = computed(() => ({
      focus: () => {
        if (props.disabled) {
          return;
        }
        focusListener();
        if (props.readonly) {
          return;
        }
        onFocus();
        listeners.onFocus();
      },
      blur: () => {
        if (props.disabled) {
          return;
        }
        blurListener();
        if (props.readonly) {
          return;
        }
        onBlur();
        listeners.onBlur();
      }
    }));
    const { tp } = useTranslation();
    const attrs = useAttrs();
    const inputAttributesComputed = computed(() => ({
      readonly: props.readonly || !props.manualInput,
      disabled: props.disabled,
      tabindex: props.disabled ? -1 : 0,
      placeholder: props.placeholder,
      value: valueText.value,
      ariaLabel: props.label || tp(props.ariaSelectedDateLabel),
      ariaRequired: props.requiredMark,
      ariaDisabled: props.disabled,
      ariaReadOnly: props.readonly,
      ...validationAriaAttributes.value,
      ...omit$1(attrs, ["class", "style"])
    }));
    const dropdownPropsComputed = computed(() => ({
      ...dropdownProps.value,
      stateful: false,
      innerAnchorSelector: ".va-input-wrapper__field",
      trigger: ["click", "right-click", "enter", "space"]
    }));
    const inputWrapperProps = computedInputWrapperProps;
    const inputListeners = computedInputListeners;
    const datePickerProps = filterComponentProps(VaDatePickerPropsDeclaration);
    __expose({
      valueText,
      valueWithoutText,
      valueDate: valueWithoutText,
      focus,
      blur,
      reset,
      validate,
      showDropdown,
      hideAndFocus,
      toggleDropdown,
      focusDatePicker
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(VaDropdown), mergeProps({
        modelValue: unref(isOpenSync),
        "onUpdate:modelValue": _cache[9] || (_cache[9] = ($event) => isRef(isOpenSync) ? isOpenSync.value = $event : null),
        class: ["va-date-input", _ctx.$attrs.class],
        style: _ctx.$attrs.style
      }, dropdownPropsComputed.value, {
        onOpen: focusDatePicker,
        role: "none"
      }), {
        anchor: withCtx(() => [
          renderSlot(_ctx.$slots, "input", normalizeProps(guardReactiveProps({ valueText: valueText.value, inputAttributes: inputAttributesComputed.value, inputWrapperProps: unref(inputWrapperProps), inputListeners: unref(inputListeners) })), () => [
            createVNode(unref(VaInputWrapper), mergeProps({
              class: "va-date-input__anchor",
              style: cursorStyleComputed.value
            }, unref(inputWrapperProps), toHandlers(unref(inputListeners)), {
              "model-value": valueText.value,
              onChange: onInputTextChanged
            }), createSlots({
              icon: withCtx(() => [
                unref(canBeCleared) ? (openBlock(), createBlock(unref(VaIcon), mergeProps({
                  key: 0,
                  "aria-label": unref(tp)(_ctx.$props.ariaResetLabel)
                }, { ...iconProps.value, ...unref(clearIconProps) }, {
                  onClick: withModifiers(reset, ["stop"]),
                  onKeydown: [
                    withKeys(withModifiers(reset, ["stop"]), ["enter"]),
                    withKeys(withModifiers(reset, ["stop"]), ["space"])
                  ]
                }), null, 16, ["aria-label", "onKeydown"])) : createCommentVNode("", true),
                !_ctx.$props.leftIcon && _ctx.$props.icon ? (openBlock(), createBlock(unref(VaIcon), mergeProps({
                  key: 1,
                  "aria-label": unref(tp)(_ctx.$props.ariaToggleDropdownLabel)
                }, iconProps.value), null, 16, ["aria-label"])) : createCommentVNode("", true)
              ]),
              _: 2
            }, [
              renderList(filterSlots.value, (name) => {
                return {
                  name,
                  fn: withCtx((slotScope) => [
                    renderSlot(_ctx.$slots, name, normalizeProps(guardReactiveProps(slotScope)))
                  ])
                };
              }),
              _ctx.$slots.prependInner || _ctx.$props.leftIcon ? {
                name: "prependInner",
                fn: withCtx((slotScope) => [
                  renderSlot(_ctx.$slots, "prependInner", normalizeProps(guardReactiveProps(slotScope))),
                  _ctx.$props.leftIcon ? (openBlock(), createBlock(unref(VaIcon), mergeProps({
                    key: 0,
                    "aria-label": unref(tp)(_ctx.$props.ariaToggleDropdownLabel)
                  }, iconProps.value), null, 16, ["aria-label"])) : createCommentVNode("", true)
                ]),
                key: "0"
              } : void 0
            ]), 1040, ["style", "model-value"])
          ])
        ]),
        default: withCtx(() => [
          createVNode(unref(VaDropdownContent), {
            class: "va-date-input__dropdown-content",
            onKeydown: _cache[8] || (_cache[8] = withKeys(($event) => unref(focus)(), ["esc"])),
            role: "dialog"
          }, {
            default: withCtx(() => [
              createVNode(_VaDatePicker, mergeProps({
                ref_key: "datePicker",
                ref: datePicker
              }, unref(datePickerProps), {
                modelValue: unref(valueWithoutText),
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => isRef(valueWithoutText) ? valueWithoutText.value = $event : null),
                "onClick:day": _cache[1] || (_cache[1] = ($event) => _ctx.$emit("click:day", $event)),
                "onClick:month": _cache[2] || (_cache[2] = ($event) => _ctx.$emit("click:month", $event)),
                "onClick:year": _cache[3] || (_cache[3] = ($event) => _ctx.$emit("click:year", $event)),
                "onHover:day": _cache[4] || (_cache[4] = ($event) => _ctx.$emit("hover:day", $event)),
                "onHover:month": _cache[5] || (_cache[5] = ($event) => _ctx.$emit("hover:month", $event)),
                "onHover:year": _cache[6] || (_cache[6] = ($event) => _ctx.$emit("hover:year", $event)),
                "onUpdate:view": _cache[7] || (_cache[7] = ($event) => {
                  _ctx.$nextTick(() => trapFocus());
                  _ctx.$emit("update:view", $event);
                })
              }), createSlots({ _: 2 }, [
                renderList(_ctx.$slots, (_, name) => {
                  return {
                    name,
                    fn: withCtx((bind) => [
                      renderSlot(_ctx.$slots, name, normalizeProps(guardReactiveProps(bind)))
                    ])
                  };
                })
              ]), 1040, ["modelValue"])
            ]),
            _: 3
          })
        ]),
        _: 3
      }, 16, ["modelValue", "class", "style"]);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-date-input/VaDateInput.js
var _style_050 = ".va-date-input {\n  --va-date-picker-cell-size: 28px;\n  font-family: var(--va-font-family);\n}\n.va-date-input__anchor {\n  flex: 1;\n}\n.va-date-input__input:-moz-read-only {\n  cursor: pointer;\n}\n.va-date-input__input:read-only {\n  cursor: pointer;\n}\n.va-date-input__dropdown-content {\n  display: flex;\n  justify-content: center;\n}";
var _VaDateInput = _export_sfc(_sfc_main54, [["styles", [_style_050]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-date-input/index.js
var VaDateInput = withConfigTransport$1(_VaDateInput);

// node_modules/vuestic-ui/dist/web-components/src/components/va-date-picker/index.js
var VaDatePicker = withConfigTransport$1(_VaDatePicker);

// node_modules/vuestic-ui/dist/web-components/src/components/va-divider/VaDivider.vue_vue_type_script_setup_true_lang.js
var _hoisted_133 = ["aria-orientation"];
var _hoisted_216 = {
  key: 0,
  class: "va-divider__text"
};
var prefixClass = "va-divider";
var _sfc_main55 = defineComponent({
  ...{
    name: "VaDivider"
  },
  __name: "VaDivider",
  props: {
    ...useComponentPresetProp,
    vertical: { type: Boolean, default: false },
    dashed: { type: Boolean, default: false },
    inset: { type: Boolean, default: false },
    orientation: {
      type: String,
      default: "center",
      validator: (value) => ["left", "right", "center"].includes(value)
    },
    color: { type: String, default: "backgroundBorder" }
  },
  setup(__props) {
    useCssVars((_ctx) => ({
      "b02c41d8": colorComputed.value
    }));
    const props = __props;
    const { getColor } = useColors();
    const colorComputed = computed(() => getColor(props.color));
    const slots = useSlots();
    const hasSlot = computed(() => !!slots.default);
    const classComputed = computed(() => ({
      [`${prefixClass}--vertical`]: props.vertical,
      [`${prefixClass}--inset`]: props.inset,
      [`${prefixClass}--${props.orientation}`]: props.orientation && !props.vertical,
      [`${prefixClass}--dashed`]: props.dashed
    }));
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        role: "separator",
        class: normalizeClass(["va-divider", classComputed.value]),
        "aria-orientation": __props.vertical ? "vertical" : "horizontal",
        "aria-hidden": true
      }, [
        hasSlot.value && !__props.vertical ? (openBlock(), createElementBlock("div", _hoisted_216, [
          renderSlot(_ctx.$slots, "default")
        ])) : createCommentVNode("", true)
      ], 10, _hoisted_133);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-divider/VaDivider.js
var _style_051 = ':root,\n:host {\n  --va-divider-display: flex;\n  /* Margin around divider, not the same as CSS margin. Should be one value. */\n  --va-divider-margin: 0.5rem;\n  --va-divider-line-width: 1px;\n  --va-divider-border-style: solid;\n  --va-divider-text-font-size: 0.875rem;\n  --va-divider-text-line-height: 0;\n  --va-divider-text-height: 0;\n  --va-divider-text-vertical-align: middle;\n  --va-divider-text-transform: translateY(-50%);\n  /* This one adds offsets at the right and left for the given text orientation only for horizontal divider */\n  --va-divider-text-horizontal-offset: 1.25rem;\n  /* Vertical */\n  --va-divider-vertical-display: inline-flex;\n  /* Inset */\n  --va-divider-inset-horizontal-margin: 1rem;\n  --va-divider-inset-margin: 0.5rem var(--va-divider-inset-horizontal-margin);\n  /* Dashed */\n  --va-divider-dashed-border-top-style: dashed;\n}\n.va-divider {\n  display: var(--va-divider-display);\n  margin: var(--va-divider-margin) 0;\n  font-family: var(--va-font-family);\n}\n.va-divider--vertical {\n  margin: 0 var(--va-divider-margin);\n  border-top: 0;\n  border-right-width: var(--va-divider-line-width);\n  border-right-style: var(--va-divider-border-style);\n  border-right-color: var(--b02c41d8);\n  display: var(--va-divider-vertical-display);\n  vertical-align: top;\n}\n.va-divider--vertical.va-divider--dashed {\n  border-right-style: dashed;\n}\n.va-divider--inset {\n  margin: var(--va-divider-inset-margin);\n}\n.va-divider--inset.va-divider--vertical {\n  margin: var(--va-divider-inset-horizontal-margin) var(--va-divider-margin);\n}\n.va-divider::before, .va-divider::after {\n  content: "";\n  flex: 1;\n  border-top-width: var(--va-divider-line-width);\n  border-top-style: var(--va-divider-border-style);\n  border-top-color: var(--b02c41d8);\n}\n.va-divider--dashed::before, .va-divider--dashed::after {\n  border-top-style: var(--va-divider-dashed-border-top-style);\n}\n.va-divider--left::before {\n  flex: 0 var(--va-divider-text-horizontal-offset);\n}\n.va-divider--right::after {\n  flex: 0 var(--va-divider-text-horizontal-offset);\n}\n.va-divider__text {\n  font-size: var(--va-divider-text-font-size);\n  line-height: var(--va-divider-text-line-height);\n  height: var(--va-divider-text-height);\n  vertical-align: var(--va-divider-text-vertical-align);\n  transform: var(--va-divider-text-transform);\n}';
var _VaDivider = _export_sfc(_sfc_main55, [["styles", [_style_051]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-divider/index.js
var VaDivider = withConfigTransport$1(_VaDivider);

// node_modules/vuestic-ui/dist/web-components/src/components/va-file-upload/types.js
var VaFileUploadKey = Symbol("VaFileUpload");

// node_modules/vuestic-ui/dist/web-components/src/components/va-list/VaList.vue_vue_type_script_setup_true_lang.js
var _sfc_main56 = defineComponent({
  ...{
    name: "VaList"
  },
  __name: "VaList",
  props: {
    ...useComponentPresetProp,
    fit: { type: Boolean, default: false }
  },
  setup(__props) {
    const props = __props;
    const computedClass = computed(() => ({ "va-list--fit": props.fit }));
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["va-list", computedClass.value]),
        role: "list"
      }, [
        renderSlot(_ctx.$slots, "default")
      ], 2);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-list/VaList.js
var _style_052 = ":root,\n:host {\n  --va-list-width: 100%;\n  /* Label */\n  --va-list-label-text-align: center;\n  --va-list-label-padding: 0.3rem 0;\n  /* Item */\n  --va-list-item-display: flex;\n  --va-list-item-align-items: center;\n  --va-list-item-width: 100%;\n  --va-list-item-height: 100%;\n  /* Item label */\n  --va-list-item-label-color: #34495e;\n  --va-list-item-label-display: -webkit-box;\n  --va-list-item-label-box-orient: vertical;\n  --va-list-item-label-overflow: hidden;\n  --va-list-item-label-line-height: normal;\n  --va-list-item-label-caption-font-size: 85%;\n  --va-list-item-label-caption-color: #babfc2;\n  /* Item Section */\n  --va-list-item-section-display: flex;\n  --va-list-item-section-icon-min-width: 1.5rem;\n  --va-list-item-section-icon-align-items: center;\n  --va-list-item-section-icon-justify-content: center;\n  --va-list-item-section-icon-margin: 0.6rem 0.75rem;\n  --va-list-item-section-icon-font-size: 1.25rem;\n  --va-list-item-section-avatar-min-width: 3rem;\n}\n.va-list {\n  width: var(--va-list-width);\n  font-family: var(--va-font-family);\n}\n.va-list--fit {\n  width: -moz-fit-content;\n  width: fit-content;\n}";
var _VaList = _export_sfc(_sfc_main56, [["styles", [_style_052]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-list/VaListItem.vue_vue_type_script_setup_true_lang.js
var _sfc_main57 = defineComponent({
  ...{
    name: "VaListItem"
  },
  __name: "VaListItem",
  props: {
    ...useRouterLinkProps,
    ...useComponentPresetProp,
    tag: { type: String, default: "div" },
    disabled: { type: Boolean, default: false }
  },
  emits: ["focus", "click"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const tabIndexComputed = computed(() => props.disabled ? -1 : 0);
    const computedClass = useBem("va-list-item", () => ({
      ...pick$1(props, ["disabled"])
    }));
    const {
      tagComputed,
      hrefComputed
    } = useRouterLink(props);
    return (_ctx, _cache) => {
      return openBlock(), createBlock(resolveDynamicComponent(unref(tagComputed)), {
        class: normalizeClass(["va-list-item", unref(computedClass)]),
        role: "listitem",
        href: unref(hrefComputed),
        target: _ctx.target,
        to: _ctx.to,
        replace: _ctx.replace,
        exact: _ctx.exact,
        "active-class": _ctx.activeClass,
        "exact-active-class": _ctx.exactActiveClass,
        tabindex: tabIndexComputed.value
      }, {
        default: withCtx(() => [
          createBaseVNode("div", {
            class: "va-list-item__inner",
            onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click")),
            onFocus: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("focus"))
          }, [
            renderSlot(_ctx.$slots, "default")
          ], 32)
        ]),
        _: 3
      }, 8, ["href", "target", "to", "replace", "exact", "active-class", "exact-active-class", "class", "tabindex"]);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-list/VaListItem.js
var _style_053 = ":root,\n:host {\n  --va-list-width: 100%;\n  /* Label */\n  --va-list-label-text-align: center;\n  --va-list-label-padding: 0.3rem 0;\n  /* Item */\n  --va-list-item-display: flex;\n  --va-list-item-align-items: center;\n  --va-list-item-width: 100%;\n  --va-list-item-height: 100%;\n  /* Item label */\n  --va-list-item-label-color: #34495e;\n  --va-list-item-label-display: -webkit-box;\n  --va-list-item-label-box-orient: vertical;\n  --va-list-item-label-overflow: hidden;\n  --va-list-item-label-line-height: normal;\n  --va-list-item-label-caption-font-size: 85%;\n  --va-list-item-label-caption-color: #babfc2;\n  /* Item Section */\n  --va-list-item-section-display: flex;\n  --va-list-item-section-icon-min-width: 1.5rem;\n  --va-list-item-section-icon-align-items: center;\n  --va-list-item-section-icon-justify-content: center;\n  --va-list-item-section-icon-margin: 0.6rem 0.75rem;\n  --va-list-item-section-icon-font-size: 1.25rem;\n  --va-list-item-section-avatar-min-width: 3rem;\n}\n.va-list-item {\n  display: block;\n  font-family: var(--va-font-family);\n}\n.va-list-item--disabled {\n  cursor: default;\n  opacity: 0.4;\n  pointer-events: none;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n          user-select: none;\n}\n.va-list-item:not(.va-list-item--disabled):focus-visible {\n  outline: 2px solid var(--va-focus) !important;\n  border-radius: 2px;\n  outline-offset: -2px;\n}\n.va-list-item__inner {\n  display: var(--va-list-item-display);\n  align-items: var(--va-list-item-align-items);\n  width: var(--va-list-item-width);\n  height: var(--va-list-item-height);\n}";
var _VaListItem = _export_sfc(_sfc_main57, [["styles", [_style_053]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-list/VaListLabel.vue_vue_type_script_setup_true_lang.js
var _sfc_main58 = defineComponent({
  ...{
    name: "VaListLabel"
  },
  __name: "VaListLabel",
  props: {
    ...useComponentPresetProp,
    color: { type: String, default: "primary" }
  },
  setup(__props) {
    const props = __props;
    const { getColor } = useColors();
    const computedStyle = computed(() => ({
      color: getColor(props.color)
    }));
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: "va-list-label",
        style: normalizeStyle(computedStyle.value)
      }, [
        renderSlot(_ctx.$slots, "default")
      ], 4);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-list/VaListLabel.js
var _style_054 = ":root,\n:host {\n  --va-list-width: 100%;\n  /* Label */\n  --va-list-label-text-align: center;\n  --va-list-label-padding: 0.3rem 0;\n  /* Item */\n  --va-list-item-display: flex;\n  --va-list-item-align-items: center;\n  --va-list-item-width: 100%;\n  --va-list-item-height: 100%;\n  /* Item label */\n  --va-list-item-label-color: #34495e;\n  --va-list-item-label-display: -webkit-box;\n  --va-list-item-label-box-orient: vertical;\n  --va-list-item-label-overflow: hidden;\n  --va-list-item-label-line-height: normal;\n  --va-list-item-label-caption-font-size: 85%;\n  --va-list-item-label-caption-color: #babfc2;\n  /* Item Section */\n  --va-list-item-section-display: flex;\n  --va-list-item-section-icon-min-width: 1.5rem;\n  --va-list-item-section-icon-align-items: center;\n  --va-list-item-section-icon-justify-content: center;\n  --va-list-item-section-icon-margin: 0.6rem 0.75rem;\n  --va-list-item-section-icon-font-size: 1.25rem;\n  --va-list-item-section-avatar-min-width: 3rem;\n}\n.va-list-label {\n  font-family: var(--va-font-family);\n  font-size: 0.625rem;\n  letter-spacing: 0.6px;\n  line-height: 1.2;\n  font-weight: 700;\n  text-transform: uppercase;\n  text-align: var(--va-list-label-text-align);\n  padding: var(--va-list-label-padding);\n}";
var _VaListLabel = _export_sfc(_sfc_main58, [["styles", [_style_054]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-list/VaListItemLabel.vue_vue_type_script_setup_true_lang.js
var _sfc_main59 = defineComponent({
  ...{
    name: "VaListItemLabel"
  },
  __name: "VaListItemLabel",
  props: {
    ...useComponentPresetProp,
    caption: { type: Boolean, default: false },
    lines: { type: Number, default: 1 }
  },
  setup(__props) {
    const props = __props;
    const computedClass = computed(() => ({ "va-list-item-label--caption": props.caption }));
    const computedStyle = computed(() => ({ "-webkit-line-clamp": props.lines }));
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["va-list-item-label", computedClass.value]),
        style: normalizeStyle(computedStyle.value)
      }, [
        renderSlot(_ctx.$slots, "default")
      ], 6);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-list/VaListItemLabel.js
var _style_055 = ":root,\n:host {\n  --va-list-width: 100%;\n  /* Label */\n  --va-list-label-text-align: center;\n  --va-list-label-padding: 0.3rem 0;\n  /* Item */\n  --va-list-item-display: flex;\n  --va-list-item-align-items: center;\n  --va-list-item-width: 100%;\n  --va-list-item-height: 100%;\n  /* Item label */\n  --va-list-item-label-color: #34495e;\n  --va-list-item-label-display: -webkit-box;\n  --va-list-item-label-box-orient: vertical;\n  --va-list-item-label-overflow: hidden;\n  --va-list-item-label-line-height: normal;\n  --va-list-item-label-caption-font-size: 85%;\n  --va-list-item-label-caption-color: #babfc2;\n  /* Item Section */\n  --va-list-item-section-display: flex;\n  --va-list-item-section-icon-min-width: 1.5rem;\n  --va-list-item-section-icon-align-items: center;\n  --va-list-item-section-icon-justify-content: center;\n  --va-list-item-section-icon-margin: 0.6rem 0.75rem;\n  --va-list-item-section-icon-font-size: 1.25rem;\n  --va-list-item-section-avatar-min-width: 3rem;\n}\n.va-list-item-label {\n  font-family: var(--va-font-family);\n  color: var(--va-list-item-label-color);\n  display: var(--va-list-item-label-display);\n  -webkit-box-orient: var(--va-list-item-label-box-orient);\n  overflow: var(--va-list-item-label-overflow);\n  line-height: var(--va-list-item-label-line-height);\n}\n.va-list-item-label--caption {\n  font-size: var(--va-list-item-label-caption-font-size);\n  color: var(--va-list-item-label-caption-color);\n}";
var _VaListItemLabel = _export_sfc(_sfc_main59, [["styles", [_style_055]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-list/VaListItemSection.vue_vue_type_script_setup_true_lang.js
var _sfc_main60 = defineComponent({
  ...{
    name: "VaListItemSection"
  },
  __name: "VaListItemSection",
  props: {
    ...useComponentPresetProp,
    icon: { type: Boolean, default: false },
    avatar: { type: Boolean, default: false }
  },
  setup(__props) {
    const props = __props;
    const computedClass = computed(() => ({
      "va-list-item-section--main": !props.icon && !props.avatar,
      "va-list-item-section--icon": props.icon,
      "va-list-item-section--avatar": props.avatar
    }));
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["va-list-item-section", computedClass.value])
      }, [
        renderSlot(_ctx.$slots, "default")
      ], 2);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-list/VaListItemSection.js
var _style_056 = ":root,\n:host {\n  --va-list-width: 100%;\n  /* Label */\n  --va-list-label-text-align: center;\n  --va-list-label-padding: 0.3rem 0;\n  /* Item */\n  --va-list-item-display: flex;\n  --va-list-item-align-items: center;\n  --va-list-item-width: 100%;\n  --va-list-item-height: 100%;\n  /* Item label */\n  --va-list-item-label-color: #34495e;\n  --va-list-item-label-display: -webkit-box;\n  --va-list-item-label-box-orient: vertical;\n  --va-list-item-label-overflow: hidden;\n  --va-list-item-label-line-height: normal;\n  --va-list-item-label-caption-font-size: 85%;\n  --va-list-item-label-caption-color: #babfc2;\n  /* Item Section */\n  --va-list-item-section-display: flex;\n  --va-list-item-section-icon-min-width: 1.5rem;\n  --va-list-item-section-icon-align-items: center;\n  --va-list-item-section-icon-justify-content: center;\n  --va-list-item-section-icon-margin: 0.6rem 0.75rem;\n  --va-list-item-section-icon-font-size: 1.25rem;\n  --va-list-item-section-avatar-min-width: 3rem;\n}\n.va-list-item-section {\n  display: flex;\n  font-family: var(--va-font-family);\n}\n.va-list-item-section--main {\n  min-width: 0;\n  flex-direction: column;\n  flex: 1 0;\n}\n.va-list-item-section--icon {\n  min-width: var(--va-list-item-section-icon-min-width);\n  align-items: var(--va-list-item-section-icon-align-items);\n  justify-content: var(--va-list-item-section-icon-justify-content);\n  margin: var(--va-list-item-section-icon-margin);\n}\n.va-list-item-section--icon .va-icon {\n  font-size: var(--va-list-item-section-icon-font-size);\n}\n.va-list-item-section--avatar {\n  min-width: var(--va-list-item-section-avatar-min-width);\n}\n.va-list-item-section + .va-list-item-section {\n  margin-left: 0.5rem;\n}\n.va-list-item-section + .va-list-item-section--icon:last-child {\n  margin-left: 1rem;\n}";
var _VaListItemSection = _export_sfc(_sfc_main60, [["styles", [_style_056]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-list/VaListSeparator.vue_vue_type_script_setup_true_lang.js
var _sfc_main61 = defineComponent({
  ...{
    name: "VaListSeparator"
  },
  __name: "VaListSeparator",
  props: {
    ...useComponentPresetProp,
    fit: { type: Boolean, default: false },
    spaced: { type: Boolean, default: false }
  },
  setup(__props) {
    const props = __props;
    const computedClass = computed(() => ({
      "va-list-separator--offset": !props.fit,
      "va-list-separator--spaced": props.spaced
    }));
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        "aria-hidden": "true",
        class: normalizeClass(["va-list-separator", computedClass.value])
      }, null, 2);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-list/VaListSeparator.js
var _style_057 = ".va-list-separator {\n  height: 1px;\n  background-color: #e6e9ec;\n}\n.va-list-separator--offset {\n  margin-left: 1.5rem;\n}\n.va-list-separator--spaced {\n  margin: 1.5rem 0;\n}";
var _VaListSeparator = _export_sfc(_sfc_main61, [["styles", [_style_057]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-list/index.js
var VaListItem = withConfigTransport$1(_VaListItem);
var VaListLabel = withConfigTransport$1(_VaListLabel);
var VaListItemLabel = withConfigTransport$1(_VaListItemLabel);
var VaListItemSection = withConfigTransport$1(_VaListItemSection);
var VaListSeparator = withConfigTransport$1(_VaListSeparator);
var VaList = withConfigTransport$1(_VaList);

// node_modules/vuestic-ui/dist/web-components/src/components/va-progress-bar/VaProgressBar.vue_vue_type_script_setup_true_lang.js
var _hoisted_134 = {
  key: 0,
  class: "va-progress-bar__info"
};
var _sfc_main62 = defineComponent({
  ...{
    name: "VaProgressBar"
  },
  __name: "VaProgressBar",
  props: {
    ...useComponentPresetProp,
    modelValue: { type: Number, default: 0 },
    indeterminate: { type: Boolean, default: false },
    color: { type: String, default: "primary" },
    size: {
      type: [Number, String],
      default: "medium"
    },
    buffer: { type: Number, default: 100 },
    rounded: { type: Boolean, default: true },
    reverse: { type: Boolean, default: false },
    contentInside: { type: Boolean, default: false },
    showPercent: { type: Boolean, default: false },
    max: { type: Number, default: 100 },
    ariaLabel: { type: String, default: "$t:progressState" }
  },
  setup(__props) {
    const props = __props;
    const { getColor, getHoverColor: getHoverColor2 } = useColors();
    const colorComputed = computed(() => getColor(props.color));
    const { textColorComputed } = useTextColor(colorComputed);
    const isTextSize = computed(() => typeof props.size === "string" && ["small", "medium", "large"].includes(props.size));
    const getCSSHeight = () => {
      if (typeof props.size === "number") {
        return `${props.size}px`;
      }
      if (isTextSize.value) {
        return;
      }
      return props.size;
    };
    const { tp } = useTranslation();
    const progressBarValue = computed(() => 100 / props.max * props.modelValue);
    const rootClass = computed(() => ({
      "va-progress-bar--square": !props.rounded,
      [`va-progress-bar--${props.size}`]: isTextSize.value
    }));
    const rooStyle = computed(() => ({
      "--va-progress-bar-color": colorComputed.value,
      "--va-progress-bar-background-color": getHoverColor2(colorComputed.value)
    }));
    const wrapperStyle = computed(() => ({
      height: getCSSHeight()
    }));
    const bufferStyle = computed(() => ({
      width: `${props.indeterminate ? 100 : clamp$1(props.buffer, 0, 100)}%`,
      color: textColorComputed.value,
      [props.reverse ? "right" : "left"]: 0
    }));
    const progressStyle = computed(() => ({
      marginLeft: props.reverse ? "auto" : void 0,
      width: `${clamp$1(progressBarValue.value, 0, 100)}%`
    }));
    const intermediateStyle = computed(() => ({
      animationDirection: props.reverse ? "reverse" : "normal"
    }));
    const ariaAttributesComputed = computed(() => ({
      role: "progressbar",
      "aria-label": tp(props.ariaLabel),
      "aria-valuenow": !props.indeterminate ? props.modelValue : void 0
    }));
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", mergeProps({
        class: ["va-progress-bar", rootClass.value],
        style: rooStyle.value
      }, ariaAttributesComputed.value), [
        !_ctx.$props.contentInside ? (openBlock(), createElementBlock("div", _hoisted_134, [
          renderSlot(_ctx.$slots, "default", normalizeProps(guardReactiveProps({ value: _ctx.$props.modelValue })), () => [
            _ctx.$props.showPercent ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              createTextVNode(toDisplayString(_ctx.$props.modelValue) + "% ", 1)
            ], 64)) : createCommentVNode("", true)
          ])
        ])) : createCommentVNode("", true),
        createBaseVNode("div", {
          class: "va-progress-bar__wrapper",
          style: normalizeStyle(wrapperStyle.value)
        }, [
          createBaseVNode("div", {
            class: "va-progress-bar__buffer",
            style: normalizeStyle(bufferStyle.value)
          }, [
            _ctx.$props.contentInside ? renderSlot(_ctx.$slots, "default", normalizeProps(mergeProps({ key: 0 }, { value: _ctx.$props.modelValue })), () => [
              _ctx.$props.showPercent ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                createTextVNode(toDisplayString(_ctx.$props.modelValue) + "% ", 1)
              ], 64)) : createCommentVNode("", true)
            ]) : createCommentVNode("", true)
          ], 4),
          __props.indeterminate ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
            createBaseVNode("div", {
              class: "va-progress-bar__progress--indeterminate-start",
              style: normalizeStyle(intermediateStyle.value)
            }, null, 4),
            createBaseVNode("div", {
              class: "va-progress-bar__progress--indeterminate-end",
              style: normalizeStyle(intermediateStyle.value)
            }, null, 4)
          ], 64)) : (openBlock(), createElementBlock("div", {
            key: 1,
            class: "va-progress-bar__progress",
            style: normalizeStyle(progressStyle.value)
          }, null, 4))
        ], 4)
      ], 16);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-progress-bar/VaProgressBar.js
var _style_058 = ":root,\n:host {\n  --va-progress-bar-width: 100%;\n  --va-progress-bar-position: relative;\n  --va-progress-bar-overflow: hidden;\n  --va-progress-bar-height: 0.5rem;\n  --va-progress-bar-border-radius: 9999999px;\n  /* Small */\n  --va-progress-bar-sm-height: 2px;\n  /* Large */\n  --va-progress-bar-lg-height: 16px;\n  /* Info */\n  --va-progress-bar-info-font-weight: 700;\n  --va-progress-bar-info-text-align: center;\n  --va-progress-bar-info-text-transform: uppercase;\n  --va-progress-bar-info-not-empty-margin-bottom: 0.1rem;\n  /* Buffer */\n  --va-progress-bar-buffer-opacity: 0.3;\n  --va-progress-bar-buffer-transition: width ease 2s;\n  /* Overlay */\n  --va-progress-bar-transition: width ease 2s;\n  --va-progress-bar-letter-spacing: 0.6px;\n  --va-progress-bar-line-height: 1;\n  --va-progress-bar-font-size: 0.8em;\n  --va-progress-bar-font-weight: 700;\n}\n.va-progress-bar {\n  width: var(--va-progress-bar-width);\n  position: relative;\n  overflow: hidden;\n  font-family: var(--va-font-family);\n  line-height: var(--va-progress-bar-line-height);\n}\n.va-progress-bar__info {\n  font-weight: var(--va-progress-bar-info-font-weight);\n  text-align: var(--va-progress-bar-info-text-align);\n  text-transform: var(--va-progress-bar-info-text-transform);\n}\n.va-progress-bar__info:not(:empty) {\n  margin-bottom: var(--va-progress-bar-info-not-empty-margin-bottom);\n}\n.va-progress-bar__wrapper {\n  position: relative;\n  overflow: hidden;\n  border-radius: var(--va-progress-bar-border-radius);\n}\n.va-progress-bar--small .va-progress-bar__wrapper {\n  height: var(--va-progress-bar-sm-height);\n}\n.va-progress-bar--medium .va-progress-bar__wrapper {\n  height: var(--va-progress-bar-height);\n}\n.va-progress-bar--large .va-progress-bar__wrapper {\n  height: var(--va-progress-bar-lg-height);\n}\n.va-progress-bar--square .va-progress-bar__wrapper {\n  --va-progress-bar-border-radius: 0;\n}\n.va-progress-bar__buffer {\n  position: absolute;\n  top: 0;\n  height: inherit;\n  border-radius: inherit;\n  transition: var(--va-progress-bar-buffer-transition);\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  letter-spacing: var(--va-progress-bar-letter-spacing);\n  font-size: var(--va-progress-bar-font-size);\n  font-weight: var(--va-progress-bar-font-weight);\n  background-color: var(--va-progress-bar-background-color);\n}\n.va-progress-bar__progress {\n  height: inherit;\n  border-radius: inherit;\n  transition: var(--va-progress-bar-transition);\n  background-color: var(--va-progress-bar-color);\n}\n.va-progress-bar__progress--indeterminate-start {\n  background-color: var(--va-progress-bar-color);\n  animation: va-progress-bar-indeterminate-start 2s ease-in infinite;\n  position: absolute;\n  height: inherit;\n}\n.va-progress-bar__progress--indeterminate-end {\n  background-color: var(--va-progress-bar-color);\n  animation: va-progress-bar-indeterminate-end 2s ease-out 1s infinite;\n  position: absolute;\n  height: inherit;\n}\n@keyframes va-progress-bar-indeterminate-start {\n0% {\n    width: 10%;\n    left: -10%;\n}\n50% {\n    width: 100%;\n    left: 100%;\n}\n100% {\n    width: 100%;\n    left: 100%;\n}\n}\n@keyframes va-progress-bar-indeterminate-end {\n0% {\n    width: 100%;\n    left: -100%;\n}\n50% {\n    width: 10%;\n    left: 100%;\n}\n100% {\n    width: 10%;\n    left: 100%;\n}\n}";
var _VaProgressBar = _export_sfc(_sfc_main62, [["styles", [_style_058]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-progress-bar/index.js
var VaProgressBar = withConfigTransport$1(_VaProgressBar);

// node_modules/vuestic-ui/dist/web-components/src/composables/useStrictInject.js
var useStrictInject = (injectionSymbol, errorMessage) => {
  const strictInjection = inject(injectionSymbol);
  if (!strictInjection) {
    throw new Error(errorMessage);
  }
  return strictInjection;
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-file-upload/VaFileUploadUndo/VaFileUploadUndo.vue_vue_type_script_setup_true_lang.js
var _hoisted_135 = { class: "va-file-upload-undo__text" };
var INJECTION_ERROR_MESSAGE = "The VaFileUploadUndo component should be used in the context of VaFileUpload component";
var _sfc_main63 = defineComponent({
  ...{
    name: "VaFileUploadUndo"
  },
  __name: "VaFileUploadUndo",
  props: {
    vertical: { type: Boolean, default: false }
  },
  emits: ["recover"],
  setup(__props, { emit: __emit }) {
    useCssVars((_ctx) => ({
      "52296ed2": undoDurationStyle.value
    }));
    const props = __props;
    const progress = ref(100);
    const {
      undoDuration,
      undoButtonText,
      deletedFileMessage
    } = useStrictInject(VaFileUploadKey, INJECTION_ERROR_MESSAGE);
    const computedClasses = useBem("va-file-upload-undo", () => ({
      vertical: props.vertical
    }));
    const undoDurationStyle = computed(() => `${undoDuration.value ?? 0}ms`);
    onMounted(() => {
      const timer = setTimeout(() => {
        progress.value = 0;
        clearTimeout(timer);
      }, 0);
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock(Fragment, null, [
        createVNode(unref(VaProgressBar), {
          "model-value": progress.value,
          rounded: false,
          class: "va-file-upload-undo-progress-bar"
        }, null, 8, ["model-value"]),
        createBaseVNode("div", {
          class: normalizeClass(["va-file-upload-undo", unref(computedClasses)])
        }, [
          createBaseVNode("span", _hoisted_135, toDisplayString(unref(deletedFileMessage)), 1),
          createVNode(unref(VaButton), {
            class: "va-file-upload-undo__button",
            "aria-label": unref(undoButtonText),
            size: "small",
            outline: "",
            onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("recover"))
          }, {
            default: withCtx(() => [
              createTextVNode(toDisplayString(unref(undoButtonText)), 1)
            ]),
            _: 1
          }, 8, ["aria-label"])
        ], 2)
      ], 64);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-file-upload/VaFileUploadUndo/VaFileUploadUndo.js
var _style_059 = ":root,\n:host {\n  --va-file-upload-undo-button-line-height: 1.1428;\n  --va-file-upload-undo-button-margin-top: 0;\n  --va-file-upload-undo-button-margin-bottom: 0;\n  --va-file-upload-undo-margin-left: 0.5rem;\n}\n.va-file-upload-undo-progress-bar {\n  position: absolute;\n  top: 0;\n  left: 0;\n  --va-progress-bar-transition: width var(--52296ed2) linear;\n}\n.va-file-upload-undo {\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n  flex-wrap: wrap;\n}\n.va-file-upload-undo__button {\n  line-height: var(--va-file-upload-undo-button-line-height);\n  margin-left: var(--va-file-upload-undo-margin-left);\n  margin-top: var(--va-file-upload-undo-button-margin-top);\n  margin-bottom: var(--va-file-upload-undo-button-margin-bottom);\n}\n.va-file-upload-undo--vertical {\n  justify-content: center;\n  align-items: center;\n  align-content: center;\n  padding: var(--va-file-upload-undo-padding);\n}\n.va-file-upload-undo--vertical .va-file-upload-undo__text {\n  margin: 1rem 0 0;\n  text-align: center;\n}\n.va-file-upload-undo--vertical .va-file-upload-undo__button {\n  margin: 1rem 0 0;\n}";
var _VaFileUploadUndo = _export_sfc(_sfc_main63, [["styles", [_style_059]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-file-upload/VaFileUploadUndo/index.js
var VaFileUploadUndo = withConfigTransport$1(_VaFileUploadUndo);

// node_modules/vuestic-ui/dist/web-components/src/components/va-file-upload/VaFileUploadListItem/VaFileUploadListItem.vue_vue_type_script_setup_true_lang.js
var _hoisted_136 = { class: "va-file-upload-list-item__content" };
var _hoisted_217 = {
  key: 0,
  class: "va-file-upload-list-item__name"
};
var _hoisted_310 = { class: "va-file-upload-list-item__size" };
var INJECTION_ERROR_MESSAGE2 = "The VaFileUploadListItem component should be used in the context of VaFileUpload component";
var _sfc_main64 = defineComponent({
  ...{
    name: "VaFileUploadListItem"
  },
  __name: "VaFileUploadListItem",
  props: {
    file: { type: Object, default: null },
    color: { type: String, default: "success" },
    ariaRemoveFileLabel: { type: String, default: "$t:removeFile" }
  },
  emits: ["remove"],
  setup(__props, { emit: __emit }) {
    const { tp } = useTranslation();
    const emit = __emit;
    const {
      undo,
      disabled,
      undoDuration
    } = useStrictInject(VaFileUploadKey, INJECTION_ERROR_MESSAGE2);
    const { onFocus, onBlur } = useFocus();
    const removed = ref(false);
    const removeFile = () => {
      if (undo.value) {
        removed.value = true;
        setTimeout(() => {
          if (removed.value) {
            emit("remove");
            removed.value = false;
          }
        }, undoDuration.value ?? 0);
      } else {
        emit("remove");
        removed.value = false;
      }
    };
    const recoverFile = () => {
      removed.value = false;
    };
    const computedClasses = useBem("va-file-upload-list-item", () => ({
      undo: removed.value
    }));
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(VaListItem), {
        class: normalizeClass(["va-file-upload-list-item", unref(computedClasses)]),
        tabindex: "-1",
        disabled: unref(disabled),
        "aria-disabled": unref(disabled)
      }, {
        default: withCtx(() => [
          removed.value && unref(undo) ? (openBlock(), createBlock(unref(VaListItemSection), { key: 0 }, {
            default: withCtx(() => [
              createVNode(unref(VaFileUploadUndo), { onRecover: recoverFile })
            ]),
            _: 1
          })) : (openBlock(), createBlock(unref(VaListItemSection), { key: 1 }, {
            default: withCtx(() => [
              createBaseVNode("div", _hoisted_136, [
                __props.file && __props.file.name ? (openBlock(), createElementBlock("div", _hoisted_217, toDisplayString(__props.file && __props.file.name), 1)) : createCommentVNode("", true),
                createBaseVNode("div", _hoisted_310, toDisplayString(__props.file && __props.file.size), 1),
                !unref(disabled) ? (openBlock(), createBlock(unref(VaButton), {
                  key: 1,
                  flat: "",
                  color: "danger",
                  icon: "clear",
                  class: "va-file-upload-list-item__delete",
                  "aria-label": unref(tp)(_ctx.$props.ariaRemoveFileLabel),
                  onClick: withModifiers(removeFile, ["stop"]),
                  onKeydown: [
                    withKeys(withModifiers(removeFile, ["stop"]), ["enter"]),
                    withKeys(withModifiers(removeFile, ["stop"]), ["space"])
                  ],
                  onFocus: unref(onFocus),
                  onBlur: unref(onBlur)
                }, null, 8, ["aria-label", "onKeydown", "onFocus", "onBlur"])) : createCommentVNode("", true)
              ])
            ]),
            _: 1
          }))
        ]),
        _: 1
      }, 8, ["class", "disabled", "aria-disabled"]);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-file-upload/VaFileUploadListItem/VaFileUploadListItem.js
var _style_060 = ":root,\n:host {\n  --va-file-upload-list-item-size-text-color: var(--va-secondary);\n  --va-file-upload-list-item-border-radius: 0.375rem;\n  --va-file-upload-list-item-background-color: var(--va-white);\n  --va-file-upload-list-item-box-shadow: var(--va-box-shadow);\n}\n.va-file-upload-list-item {\n  background-color: var(--va-file-upload-list-item-background-color);\n  box-shadow: var(--va-file-upload-list-item-box-shadow, var(--va-block-box-shadow));\n  border-radius: var(--va-file-upload-list-item-border-radius, var(--va-block-border-radius));\n  position: relative;\n  line-height: 1.5rem;\n  padding: 1.125rem 0.5rem 1rem 1rem;\n  max-width: 100%;\n  width: 100%;\n}\n.va-file-upload-list-item + .va-file-upload-list-item {\n  margin-top: 0.5rem;\n}\n.va-file-upload-list-item .va-list-item__inner {\n  padding: 0;\n  overflow: hidden;\n}\n.va-file-upload-list-item__content {\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n}\n.va-file-upload-list-item__name {\n  white-space: nowrap;\n  text-overflow: ellipsis;\n  flex-basis: 60%;\n  overflow: hidden;\n}\n.va-file-upload-list-item__size {\n  color: var(--va-file-upload-list-item-size-text-color);\n}\n.va-file-upload-list-item__delete {\n  font-size: 1.5rem;\n  cursor: pointer;\n  --va-button-size: 1.5rem;\n}\n.va-file-upload-list-item--undo {\n  overflow: hidden;\n  position: relative;\n}\n.va-file-upload-list-item--undo .va-list-item-section {\n  padding: 0;\n}";
var _VaFileUploadListItem = _export_sfc(_sfc_main64, [["styles", [_style_060]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-file-upload/VaFileUploadListItem/index.js
var VaFileUploadListItem = withConfigTransport$1(_VaFileUploadListItem);

// node_modules/vuestic-ui/dist/web-components/src/components/va-file-upload/VaFileUploadGalleryItem/VaFileUploadGalleryItem.vue_vue_type_script_setup_true_lang.js
var _hoisted_137 = ["src", "alt"];
var _hoisted_218 = { class: "va-file-upload-gallery-item__overlay" };
var _hoisted_311 = ["title"];
var INJECTION_ERROR_MESSAGE3 = "The VaFileUploadGalleryItem component should be used in the context of VaFileUpload component";
var _sfc_main65 = defineComponent({
  ...{
    name: "VaFileUploadGalleryItem"
  },
  __name: "VaFileUploadGalleryItem",
  props: {
    file: { type: Object, default: null },
    color: { type: String, default: "success" },
    ariaRemoveFileLabel: { type: String, default: "$t:removeFile" }
  },
  emits: ["remove"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const {
      undo,
      disabled,
      undoDuration
    } = useStrictInject(VaFileUploadKey, INJECTION_ERROR_MESSAGE3);
    const { isFocused, onFocus, onBlur } = useFocus();
    const previewImage = ref("");
    const removed = ref(false);
    const overlayStylesComputed = computed(() => ({
      backgroundColor: colorToRgba(props.color, 0.7)
    }));
    const classesComputed = useBem("va-file-upload-gallery-item", () => ({
      notImage: !previewImage.value,
      focused: isFocused.value,
      undo: removed.value
    }));
    const removeImage = () => {
      if (undo.value) {
        removed.value = true;
        setTimeout(() => {
          if (!removed.value) {
            return;
          }
          emit("remove");
          removed.value = false;
        }, undoDuration.value ?? 0);
      } else {
        emit("remove");
        removed.value = false;
      }
    };
    const recoverImage = () => {
      removed.value = false;
    };
    const convertToImg = () => {
      if (!props.file.name || !props.file.image) {
        return;
      }
      if (props.file.image.url) {
        previewImage.value = props.file.image.url;
      } else if (props.file.image instanceof File) {
        const reader = new FileReader();
        reader.readAsDataURL(props.file.image);
        reader.onload = (e) => {
          var _a2, _b;
          if (((_a2 = e.target) == null ? void 0 : _a2.result).includes("image")) {
            previewImage.value = (_b = e.target) == null ? void 0 : _b.result;
          }
        };
      }
    };
    onMounted(convertToImg);
    watch(() => props.file, convertToImg);
    const { t, tp } = useTranslation();
    const { textColorComputed } = useTextColor(toRef(props, "color"));
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(VaListItem), {
        class: normalizeClass(["va-file-upload-gallery-item", unref(classesComputed)]),
        tabindex: "-1",
        disabled: unref(disabled),
        "aria-disabled": unref(disabled),
        onFocus: unref(onFocus),
        onBlur: unref(onBlur)
      }, {
        default: withCtx(() => [
          removed.value && unref(undo) ? (openBlock(), createBlock(unref(VaListItemSection), { key: 0 }, {
            default: withCtx(() => [
              createVNode(unref(VaFileUploadUndo), {
                vertical: "",
                onRecover: recoverImage
              })
            ]),
            _: 1
          })) : (openBlock(), createBlock(unref(VaListItemSection), { key: 1 }, {
            default: withCtx(() => [
              previewImage.value ? (openBlock(), createElementBlock("img", {
                key: 0,
                src: previewImage.value,
                alt: __props.file.name || "",
                class: "va-file-upload-gallery-item__image"
              }, null, 8, _hoisted_137)) : createCommentVNode("", true),
              createBaseVNode("div", _hoisted_218, [
                createBaseVNode("div", {
                  class: "va-file-upload-gallery-item__overlay-background",
                  style: normalizeStyle(overlayStylesComputed.value)
                }, null, 4),
                __props.file && __props.file.name ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  class: "va-file-upload-gallery-item__name",
                  title: __props.file.name,
                  style: normalizeStyle({ color: unref(textColorComputed) })
                }, toDisplayString(__props.file.name), 13, _hoisted_311)) : createCommentVNode("", true),
                !unref(disabled) ? (openBlock(), createBlock(unref(VaButton), {
                  key: 1,
                  flat: "",
                  color: "danger",
                  icon: "va-delete",
                  class: "va-file-upload-gallery-item__delete",
                  "aria-label": unref(tp)(_ctx.$props.ariaRemoveFileLabel),
                  onClick: removeImage,
                  onFocus: unref(onFocus),
                  onBlur: unref(onBlur)
                }, null, 8, ["aria-label", "onFocus", "onBlur"])) : createCommentVNode("", true)
              ])
            ]),
            _: 1
          }))
        ]),
        _: 1
      }, 8, ["class", "disabled", "aria-disabled", "onFocus", "onBlur"]);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-file-upload/VaFileUploadGalleryItem/VaFileUploadGalleryItem.js
var _style_061 = ":root,\n:host {\n  --va-file-upload-gallery-item-card-box-shadow: var(--va-box-shadow);\n  --va-file-upload-gallery-item-text: var(--va-text-primary);\n  --va-file-upload-gallery-item-text-hover: var(--va-text-inverted);\n}\n.va-file-upload-gallery-item {\n  display: flex;\n  position: relative;\n  margin-bottom: 1rem;\n  margin-right: 0.5rem;\n  flex-basis: calc(14.2857% - 0.5rem);\n  max-width: calc(14.2857% - 0.5rem);\n  min-width: 8.5714rem;\n  border-radius: 0.375rem;\n  overflow: hidden;\n  width: 100%;\n  align-items: stretch;\n}\n@media (max-width: 991.98px) {\n.va-file-upload-gallery-item {\n    flex-basis: calc(16.667% - 0.5rem);\n    max-width: calc(16.667% - 0.5rem);\n}\n}\n@media (max-width: 767.98px) {\n.va-file-upload-gallery-item {\n    flex-basis: calc(20% - 0.5rem);\n    max-width: calc(20% - 0.5rem);\n}\n}\n@media (max-width: 575.98px) {\n.va-file-upload-gallery-item {\n    flex-basis: calc(50% - 0.5rem);\n    max-width: calc(50% - 0.5rem);\n}\n}\n.va-file-upload-gallery-item:last-of-type {\n  margin-right: 0;\n}\n.va-file-upload-gallery-item:hover .va-file-upload-gallery-item__overlay, .va-file-upload-gallery-item:focus .va-file-upload-gallery-item__overlay, .va-file-upload-gallery-item--focused .va-file-upload-gallery-item__overlay {\n  z-index: 3;\n  opacity: 1;\n}\n.va-file-upload-gallery-item:hover .va-file-upload-gallery-item__name, .va-file-upload-gallery-item:focus .va-file-upload-gallery-item__name, .va-file-upload-gallery-item--focused .va-file-upload-gallery-item__name {\n  color: var(--va-file-upload-gallery-item-text-hover);\n}\n.va-file-upload-gallery-item__overlay {\n  display: flex;\n  position: absolute;\n  height: 100%;\n  width: 100%;\n  top: 0;\n  left: 0;\n  flex-direction: column;\n  padding: 0.5rem;\n  z-index: -1;\n  opacity: 0;\n}\n.va-file-upload-gallery-item__overlay-background {\n  position: absolute;\n  height: 100%;\n  width: 100%;\n  top: 0;\n  left: 0;\n  z-index: -1;\n}\n.va-file-upload-gallery-item__image {\n  width: 100%;\n  box-shadow: var(--va-box-shadow);\n  object-fit: cover;\n  z-index: 1;\n}\n.va-file-upload-gallery-item__name {\n  color: var(--va-file-upload-gallery-item-text);\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  font-size: 0.875rem;\n}\n.va-file-upload-gallery-item__delete {\n  cursor: pointer;\n  font-size: 1.5rem;\n  margin-top: auto;\n}\n.va-file-upload-gallery-item--not-image .va-file-upload-gallery-item__overlay {\n  display: flex;\n}\n.va-file-upload-gallery-item--undo .va-list-item__inner {\n  display: flex;\n  align-items: flex-start;\n  position: relative;\n}\n.va-file-upload-gallery-item--undo .va-list-item-section {\n  height: inherit;\n  padding: 0;\n}\n.va-file-upload-gallery-item--undo .va-file-upload-undo {\n  flex: 1;\n}";
var _VaFileUploadGalleryItem = _export_sfc(_sfc_main65, [["styles", [_style_061]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-file-upload/VaFileUploadGalleryItem/index.js
var VaFileUploadGalleryItem = withConfigTransport$1(_VaFileUploadGalleryItem);

// node_modules/vuestic-ui/dist/web-components/src/components/va-file-upload/VaFileUploadSingleItem/VaFileUploadSingleItem.vue_vue_type_script_setup_true_lang.js
var _hoisted_138 = { class: "va-file-upload-single-item__name" };
var INJECTION_ERROR_MESSAGE4 = "The VaFileUploadSingleItem component should be used in the context of VaFileUpload component";
var _sfc_main66 = defineComponent({
  ...{
    name: "VaFileUploadSingleItem"
  },
  __name: "VaFileUploadSingleItem",
  props: {
    file: { type: Object, default: null },
    ariaRemoveFileLabel: { type: String, default: "$t:removeFile" }
  },
  emits: ["remove"],
  setup(__props, { emit: __emit }) {
    const { t, tp } = useTranslation();
    const { disabled } = useStrictInject(VaFileUploadKey, INJECTION_ERROR_MESSAGE4);
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(VaListItem), {
        disabled: unref(disabled),
        "aria-disabled": unref(disabled),
        class: "va-file-upload-single-item",
        tabindex: "-1"
      }, {
        default: withCtx(() => [
          createVNode(unref(VaListItemSection), { class: "va-file-upload-single-item__content" }, {
            default: withCtx(() => [
              createBaseVNode("div", _hoisted_138, toDisplayString(__props.file && __props.file.name), 1),
              !unref(disabled) ? (openBlock(), createBlock(unref(VaButton), {
                key: 0,
                class: "va-file-upload-single-item__button",
                "aria-label": unref(tp)(_ctx.$props.ariaRemoveFileLabel),
                size: "small",
                color: "danger",
                preset: "secondary",
                onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("remove"))
              }, {
                default: withCtx(() => [
                  createTextVNode(" Delete ")
                ]),
                _: 1
              }, 8, ["aria-label"])) : createCommentVNode("", true)
            ]),
            _: 1
          })
        ]),
        _: 1
      }, 8, ["disabled", "aria-disabled"]);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-file-upload/VaFileUploadSingleItem/VaFileUploadSingleItem.js
var _style_062 = ".va-file-upload-single-item {\n  width: 100%;\n}\n.va-file-upload-single-item__content {\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n  max-width: 100%;\n  width: 100%;\n}\n.va-file-upload-single-item__name {\n  margin-right: 0.25rem;\n  max-width: 80%;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n  line-height: normal;\n}\n.va-file-upload-single-item__button {\n  margin-top: 0;\n  margin-bottom: 0;\n  font-weight: 700;\n}";
var _VaFileUploadSingleItem = _export_sfc(_sfc_main66, [["styles", [_style_062]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-file-upload/VaFileUploadSingleItem/index.js
var VaFileUploadSingleItem = withConfigTransport$1(_VaFileUploadSingleItem);

// node_modules/vuestic-ui/dist/web-components/src/components/va-file-upload/VaFileUploadList/VaFileUploadList.vue_vue_type_script_setup_true_lang.js
var VaFileUploadGalleryItemProps = extractComponentProps(VaFileUploadGalleryItem);
var VaFileUploadListItemProps = extractComponentProps(VaFileUploadListItem);
var VaFileUploadSingleItemProps = extractComponentProps(VaFileUploadSingleItem);
var _sfc_main67 = defineComponent({
  ...{
    name: "VaFileUploadList"
  },
  __name: "VaFileUploadList",
  props: {
    type: { type: String, default: "" },
    files: { type: Array, default: null },
    ...VaFileUploadGalleryItemProps,
    ...VaFileUploadListItemProps,
    ...VaFileUploadSingleItemProps
  },
  emits: ["remove", "removeSingle"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const filesList = computed(() => props.files.map(convertFile));
    const convertFile = (file) => ({
      name: file.name || file.url || "",
      size: formatSize(file.size),
      date: formatDate(/* @__PURE__ */ new Date()),
      image: file
    });
    const formatSize = (bytes) => {
      if (bytes === 0) {
        return "0 Bytes";
      }
      if (!bytes) {
        return "";
      }
      const k = 1024;
      const sizes = ["Bytes", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
    };
    const formatDate = (date = /* @__PURE__ */ new Date()) => {
      return date.toLocaleDateString("en-US", {
        hour: "2-digit",
        minute: "2-digit",
        month: "short",
        day: "numeric",
        year: "numeric"
      });
    };
    const galleryItemProps = filterComponentProps(VaFileUploadGalleryItemProps);
    const itemProps = filterComponentProps(VaFileUploadListItemProps);
    const singleItemProps = filterComponentProps(VaFileUploadSingleItemProps);
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(VaList), {
        class: normalizeClass(["va-file-upload-list", `va-file-upload-list--${__props.type}`]),
        role: __props.type !== "single" ? "list" : void 0
      }, {
        default: withCtx(() => [
          __props.type === "list" ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(filesList.value, (file, index) => {
            return openBlock(), createBlock(unref(VaFileUploadListItem), mergeProps({
              key: file.name
            }, unref(itemProps), {
              file,
              role: "listitem",
              onRemove: ($event) => _ctx.$emit("remove", index)
            }), null, 16, ["file", "onRemove"]);
          }), 128)) : createCommentVNode("", true),
          __props.type === "gallery" ? (openBlock(true), createElementBlock(Fragment, { key: 1 }, renderList(filesList.value, (file, index) => {
            return openBlock(), createBlock(unref(VaFileUploadGalleryItem), mergeProps(unref(galleryItemProps), {
              key: file.name,
              file,
              role: "listitem",
              onRemove: ($event) => _ctx.$emit("remove", index)
            }), null, 16, ["file", "onRemove"]);
          }), 128)) : createCommentVNode("", true),
          __props.type === "single" && filesList.value.length ? (openBlock(), createBlock(unref(VaFileUploadSingleItem), mergeProps({ key: 2 }, unref(singleItemProps), {
            file: filesList.value[filesList.value.length - 1],
            onRemove: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("removeSingle"))
          }), null, 16, ["file"])) : createCommentVNode("", true)
        ]),
        _: 1
      }, 8, ["role", "class"]);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-file-upload/VaFileUploadList/VaFileUploadList.js
var _style_063 = ".va-file-upload-list {\n  display: flex;\n  flex-wrap: wrap;\n  padding: 0 0 1.5rem;\n}\n.va-file-upload-list--gallery {\n  padding-bottom: 0.5rem;\n}";
var _VaFileUploadList = _export_sfc(_sfc_main67, [["styles", [_style_063]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-file-upload/VaFileUploadList/index.js
var VaFileUploadList = withConfigTransport$1(_VaFileUploadList);

// node_modules/vuestic-ui/dist/web-components/src/components/va-file-upload/VaFileUpload.vue_vue_type_script_setup_true_lang.js
var _hoisted_139 = { class: "va-file-upload__field" };
var _hoisted_219 = {
  key: 0,
  class: "va-file-upload__field__text"
};
var _hoisted_312 = ["accept", "multiple", "disabled"];
var VaFileUploadListProps = extractComponentProps(VaFileUploadList);
var _sfc_main68 = defineComponent({
  ...{
    name: "VaFileUpload"
  },
  __name: "VaFileUpload",
  props: {
    ...useComponentPresetProp,
    ...VaFileUploadListProps,
    fileTypes: { type: String, default: "" },
    dropzone: { type: Boolean, default: false },
    hideFileList: { type: Boolean, default: false },
    color: { type: String, default: "primary" },
    disabled: { type: Boolean, default: false },
    undo: { type: Boolean, default: false },
    undoDuration: { type: Number, default: 3e3 },
    undoButtonText: { type: String, default: "$t:undo" },
    dropZoneText: { type: String, default: "$t:dropzone" },
    uploadButtonText: { type: String, default: "$t:uploadFile" },
    deletedFileMessage: { type: String, default: "$t:fileDeleted" },
    modelValue: {
      type: [Object, Array],
      default: () => []
    },
    type: {
      type: String,
      default: "list",
      validator: (value) => ["list", "gallery", "single"].includes(value)
    }
  },
  emits: ["update:modelValue", "file-removed", "file-added"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const fileInputRef = shallowRef();
    const modal = ref(false);
    const dropzoneHighlight = ref(false);
    const { getColor, shiftHSLAColor: shiftHSLAColor2 } = useColors();
    const colorComputed = computed(() => getColor(props.color));
    const computedStyle = computed(() => ({
      backgroundColor: props.dropzone ? shiftHSLAColor2(colorComputed.value, { a: dropzoneHighlight.value ? -0.82 : -0.92 }) : "transparent"
    }));
    const computedClasses = useBem("va-file-upload", () => ({
      dropzone: props.dropzone,
      disabled: props.disabled
    }));
    const files = computed({
      get() {
        return Array.isArray(props.modelValue) ? props.modelValue : [props.modelValue];
      },
      set(files2) {
        if (props.type === "single") {
          emit("update:modelValue", files2[0]);
        } else {
          emit("update:modelValue", files2);
        }
      }
    });
    const filterInvalidFiles = (files2) => files2.filter((file) => {
      const fileName = file.name || file.url;
      if (!fileName) {
        return false;
      }
      if (file.url) {
        return true;
      }
      const MIMETypes = ["audio/*", "video/*", "image/*"];
      const isContainedMIMEType = MIMETypes.find((t) => props.fileTypes.includes(t));
      if (isContainedMIMEType) {
        return true;
      }
      const extension = fileName.substring(fileName.lastIndexOf(".") + 1).toLowerCase();
      const isCorrectExt = props.fileTypes.includes(extension);
      if (!isCorrectExt) {
        modal.value = true;
      }
      return isCorrectExt;
    });
    const uploadFile = (e) => {
      var _a2, _b;
      const f = ((_a2 = e.target) == null ? void 0 : _a2.files) || ((_b = e.dataTransfer) == null ? void 0 : _b.files);
      if (!f) {
        return;
      }
      const validatedFiles = props.fileTypes ? filterInvalidFiles(Array.from(f)) : f;
      files.value = props.type === "single" ? validatedFiles : [...files.value, ...validatedFiles];
      emit("file-added", validatedFiles);
    };
    const changeFieldValue = (e) => {
      uploadFile(e);
      if (fileInputRef.value) {
        fileInputRef.value.value = "";
      }
    };
    const removeFile = (index) => {
      if (index in files.value) {
        const removedFile = files.value[index];
        files.value = files.value.filter((item, idx) => idx !== index);
        emit("file-removed", removedFile);
      }
    };
    const removeSingleFile = () => {
      if (files.value.length > 0) {
        const removedFile = files.value[0];
        files.value = [];
        emit("file-removed", removedFile);
      }
    };
    const callFileDialogue = () => {
      if (fileInputRef.value) {
        fileInputRef.value.click();
      }
    };
    onMounted(() => {
      if (Array.isArray(files.value)) {
        const filteredFiles = filterInvalidFiles(files.value);
        if (filteredFiles.length !== files.value.length) {
          files.value = filteredFiles;
        }
      }
    });
    const { tp } = useTranslation();
    provide(VaFileUploadKey, {
      undo: toRef(props, "undo"),
      disabled: toRef(props, "disabled"),
      undoDuration: toRef(props, "undoDuration"),
      undoButtonText: computed(() => tp(props.undoButtonText)),
      deletedFileMessage: computed(() => tp(props.deletedFileMessage))
    });
    const fileUploadListProps = filterComponentProps(VaFileUploadListProps);
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["va-file-upload", unref(computedClasses)]),
        style: normalizeStyle(computedStyle.value)
      }, [
        renderSlot(_ctx.$slots, "default", {}, () => [
          createBaseVNode("div", _hoisted_139, [
            __props.dropzone ? (openBlock(), createElementBlock("div", _hoisted_219, toDisplayString(unref(tp)(__props.dropZoneText)), 1)) : createCommentVNode("", true),
            createVNode(unref(VaButton), {
              class: "va-file-upload__field__button",
              disabled: __props.disabled,
              "aria-disabled": __props.disabled,
              color: colorComputed.value,
              style: normalizeStyle({ "pointer-events": dropzoneHighlight.value ? "none" : void 0 }),
              onChange: changeFieldValue,
              onClick: callFileDialogue
            }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(unref(tp)(__props.uploadButtonText)), 1)
              ]),
              _: 1
            }, 8, ["disabled", "aria-disabled", "color", "style"])
          ])
        ]),
        createBaseVNode("input", {
          ref_key: "fileInputRef",
          ref: fileInputRef,
          type: "file",
          class: "va-file-upload__field__input",
          tabindex: -1,
          "aria-hidden": "true",
          accept: __props.fileTypes,
          multiple: __props.type !== "single",
          disabled: __props.disabled,
          onChange: changeFieldValue,
          onDragenter: _cache[0] || (_cache[0] = ($event) => dropzoneHighlight.value = true),
          onDragleave: _cache[1] || (_cache[1] = ($event) => dropzoneHighlight.value = false)
        }, null, 40, _hoisted_312),
        files.value.length && !_ctx.$props.hideFileList ? (openBlock(), createBlock(unref(VaFileUploadList), mergeProps({ key: 0 }, unref(fileUploadListProps), {
          type: __props.type,
          files: files.value,
          color: colorComputed.value,
          onRemove: removeFile,
          onRemoveSingle: removeSingleFile
        }), null, 16, ["type", "files", "color"])) : createCommentVNode("", true),
        createVNode(unref(VaModal), {
          modelValue: modal.value,
          "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => modal.value = $event),
          "hide-default-actions": "",
          title: "File validation",
          message: "File type is incorrect!"
        }, null, 8, ["modelValue"])
      ], 6);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-file-upload/VaFileUpload.js
var _style_064 = ':root,\n:host {\n  --va-file-upload-position: relative;\n  --va-file-upload-margin: 0.5rem 0;\n  --va-file-upload-list-margin-top: 1rem;\n  --va-file-upload-dropzone-border-radius: 0.375rem;\n  --va-file-upload-dropzone-cursor: pointer;\n  --va-file-upload-dropzone-text-padding-sm: 0 0 1rem;\n  --va-file-upload-dropzone-field-padding: 1.5rem 2rem;\n  --va-file-upload-dropzone-field-padding-sm: 1.5rem 1rem;\n  --va-file-upload-dropzone-field-button-margin: 0;\n  --va-file-upload-dropzone-field-button-z-index: 10;\n  --va-file-upload-dropzone-field-text-pr: 10px;\n  --va-file-upload-dropzone-list-padding: 0 2rem 1rem;\n}\n.va-file-upload {\n  position: var(--va-file-upload-position);\n  font-family: var(--va-font-family);\n  margin: var(--va-file-upload-margin);\n}\n.va-file-upload .va-file-upload-list {\n  margin-top: var(--va-file-upload-list-margin-top);\n}\n.va-file-upload__field {\n  overflow: hidden;\n  display: flex;\n  align-items: center;\n  position: relative;\n}\n.va-file-upload__field__button {\n  margin: var(--va-file-upload-dropzone-field-button-margin);\n  z-index: 10;\n}\n.va-file-upload__field__text {\n  padding-right: var(--va-file-upload-dropzone-field-text-pr);\n}\n.va-file-upload__field__input {\n  position: absolute;\n  top: 0;\n  right: 0;\n  height: 100%;\n  width: 100%;\n  color: transparent;\n  opacity: 0;\n  cursor: pointer;\n}\n.va-file-upload__field__input::-webkit-file-upload-button {\n  cursor: pointer;\n}\n.va-file-upload--dropzone {\n  background-color: var(--va-file-upload-dropzone-background-color);\n  overflow: hidden;\n  border-radius: var(--va-file-upload-dropzone-border-radius);\n  cursor: var(--va-file-upload-dropzone-cursor);\n}\n.va-file-upload--dropzone .va-file-upload__field {\n  justify-content: center;\n  display: flex;\n  align-items: center;\n  padding: var(--va-file-upload-dropzone-field-padding);\n  transition: height 0.2s;\n  overflow: visible;\n  flex-wrap: wrap;\n}\n@media (max-width: 767.98px) {\n.va-file-upload--dropzone .va-file-upload__field {\n    flex-direction: column;\n    padding: var(--va-file-upload-dropzone-field-padding-sm);\n}\n.va-file-upload--dropzone .va-file-upload__field__text {\n    padding: var(--va-file-upload-dropzone-text-padding-sm);\n    text-align: center;\n}\n}\n.va-file-upload--dropzone .va-file-upload-list {\n  padding: var(--va-file-upload-dropzone-list-padding);\n  margin-top: 0;\n}\n.va-file-upload--disabled .va-file-upload__field__input {\n  cursor: default;\n}\n.va-file-upload--disabled .va-file-upload__field__input::-webkit-file-upload-button {\n  cursor: inherit;\n}\n.va-file-upload .va-button:focus-visible {\n  outline: 2px solid var(--va-focus) !important;\n  border-radius: "inherit";\n  outline-offset: -2px;\n}';
var _VaFileUpload = _export_sfc(_sfc_main68, [["styles", [_style_064]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-file-upload/index.js
var VaFileUpload = withConfigTransport$1(_VaFileUpload);

// node_modules/vuestic-ui/dist/web-components/src/composables/useForm/useFormParent.js
var createFormContext = (options) => {
  const fields = ref(/* @__PURE__ */ new Map());
  return {
    // Vue unwrap ref automatically, but types are not for some reason
    immediate: computed(() => options.immediate),
    fields: computed(() => [...fields.value.values()]),
    doShowError: computed(() => !options.hideErrors),
    doShowErrorMessages: computed(() => !options.hideErrorMessages),
    doShowLoading: computed(() => !options.hideLoading),
    isFormDirty: ref(false),
    registerField: (uid, field) => {
      fields.value.set(uid, field);
    },
    unregisterField: (uid) => {
      fields.value.delete(uid);
    }
  };
};
var useFormParent = (options) => {
  const formContext = createFormContext(options);
  provide(FormServiceKey, formContext);
  const { fields, isFormDirty } = formContext;
  const fieldNames = computed(() => fields.value.map((field) => unref(field.name)).filter(Boolean));
  const fieldsNamed = computed(() => fields.value.reduce((acc, field) => {
    if (unref(field.name)) {
      acc[unref(field.name)] = field;
    }
    return acc;
  }, {}));
  const formData = computed(() => fields.value.reduce((acc, field) => {
    if (unref(field.name)) {
      acc[unref(field.name)] = field.value;
    }
    return acc;
  }, {}));
  const isValid = computed(() => fields.value.every((field) => unref(field.isValid)));
  const isLoading = computed(() => fields.value.some((field) => unref(field.isLoading)));
  const isDirty = computed({
    get() {
      return fields.value.some((field) => unref(field.isLoading)) || isFormDirty.value;
    },
    set(v) {
      isFormDirty.value = v;
    }
  });
  const errorMessages = computed(() => fields.value.map((field) => unref(field.errorMessages)).flat());
  const errorMessagesNamed = computed(() => fields.value.reduce((acc, field) => {
    if (unref(field.name)) {
      acc[unref(field.name)] = unref(field.errorMessages);
    }
    return acc;
  }, {}));
  const validate = () => {
    isDirty.value = true;
    return fields.value.reduce((acc, field) => {
      return field.validate() && acc;
    }, true);
  };
  const validateAsync = () => {
    isDirty.value = true;
    return Promise.all(fields.value.map((field) => field.validateAsync())).then((results) => {
      return results.every(Boolean);
    });
  };
  const reset = () => {
    isDirty.value = false;
    fields.value.forEach((field) => field.reset());
  };
  const resetValidation = () => {
    isDirty.value = false;
    fields.value.forEach((field) => field.resetValidation());
  };
  const focus = () => {
    var _a2;
    (_a2 = fields.value[0]) == null ? void 0 : _a2.focus();
  };
  const focusInvalidField = () => {
    const invalidField = fields.value.find((field) => !field.isValid);
    invalidField == null ? void 0 : invalidField.focus();
  };
  useFormChild({
    name: ref(void 0),
    isValid,
    isLoading,
    isDirty,
    validate,
    validateAsync,
    reset,
    resetValidation,
    focus,
    errorMessages
  });
  return {
    immediate: computed(() => options.immediate),
    isDirty,
    formData,
    fields,
    fieldsNamed,
    fieldNames,
    isValid,
    isLoading,
    errorMessages,
    errorMessagesNamed,
    validate,
    validateAsync,
    reset,
    resetValidation,
    focus,
    focusInvalidField
  };
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-form/VaForm.vue_vue_type_script_setup_true_lang.js
var statefulProps = { stateful: true };
var statefulConfig = {
  VaInput: statefulProps,
  VaSelect: statefulProps,
  VaCheckbox: statefulProps,
  VaRadio: statefulProps,
  VaDatePicker: statefulProps,
  VaTimePicker: statefulProps,
  VaColorPicker: statefulProps,
  VaSlider: statefulProps,
  VaSwitch: statefulProps,
  VaFileUpload: statefulProps,
  VaRating: statefulProps,
  VaDateInput: statefulProps,
  VaTimeInput: statefulProps
};
var _sfc_main69 = defineComponent({
  ...{
    name: "VaForm"
  },
  __name: "VaForm",
  props: {
    ...useComponentPresetProp,
    autofocus: { type: Boolean, default: false },
    immediate: { type: Boolean, default: false },
    tag: { type: String, default: "div" },
    trigger: { type: String, default: "blur" },
    modelValue: { type: Boolean, default: true },
    hideErrors: { type: Boolean, default: false },
    hideErrorMessages: { type: Boolean, default: false },
    hideLoading: { type: Boolean, default: false },
    stateful: { type: Boolean, default: false }
  },
  emits: ["update:modelValue"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const context = useFormParent(props);
    watch(context.isValid, (value) => {
      emit("update:modelValue", value);
    });
    watch(() => props.autofocus, (value) => {
      if (value) {
        context.focus();
      }
    }, { immediate: true });
    watch(context.fields, (newVal) => {
      if (newVal.length && props.immediate) {
        context.validate();
      }
    }, { immediate: true });
    useLocalConfigProvider(computed(() => {
      if (!props.stateful) {
        return {};
      }
      return statefulConfig;
    }));
    const {
      immediate: immediateComputed,
      isDirty,
      formData,
      fields,
      fieldsNamed,
      fieldNames,
      isValid,
      isLoading,
      errorMessages,
      errorMessagesNamed,
      validate,
      validateAsync,
      reset,
      resetValidation,
      focus,
      focusInvalidField
    } = context;
    __expose({
      immediate: immediateComputed,
      isDirty,
      formData,
      fields,
      fieldsNamed,
      fieldNames,
      isValid,
      isLoading,
      errorMessages,
      errorMessagesNamed,
      validate,
      validateAsync,
      reset,
      resetValidation,
      focus,
      focusInvalidField
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(resolveDynamicComponent(__props.tag), mergeProps({ class: "va-form" }, _ctx.$attrs), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default", normalizeProps(guardReactiveProps({ isValid: unref(isValid), validate: unref(validate) })))
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-form/VaForm.js
var _style_065 = ".va-form {\n  font-family: var(--va-font-family);\n}";
var _VaForm = _export_sfc(_sfc_main69, [["styles", [_style_065]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-form/index.js
var VaForm = withConfigTransport$1(_VaForm);

// node_modules/vuestic-ui/dist/web-components/src/utils/sleep.js
var sleep = (ms = 0) => {
  return new Promise((resolve) => setTimeout(resolve, ms));
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-infinite-scroll/hooks/useScroll.js
var useScroll = (props, element, handler) => {
  const addScrollListener = () => {
    var _a2;
    (_a2 = element.value) == null ? void 0 : _a2.addEventListener(
      "scroll",
      handler.value,
      { passive: true }
    );
  };
  const removeScrollListener = () => {
    var _a2;
    (_a2 = element.value) == null ? void 0 : _a2.removeEventListener(
      "scroll",
      handler.value
    );
  };
  onMounted(() => {
    if (!element.value) {
      return;
    }
    element.value.style.overflowY = "scroll";
    if (props.reverse) {
      element.value.scrollTop = element.value.scrollHeight;
    }
    addScrollListener();
  });
  onBeforeUnmount(removeScrollListener);
  return {
    addScrollListener,
    removeScrollListener
  };
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-infinite-scroll/VaInfiniteScroll.vue_vue_type_script_setup_true_lang.js
var _hoisted_140 = { class: "va-infinite-scroll__spinner__default" };
var _sfc_main70 = defineComponent({
  ...{
    name: "VaInfiniteScroll"
  },
  __name: "VaInfiniteScroll",
  props: {
    ...useComponentPresetProp,
    load: { type: Function, required: true },
    offset: { type: Number, default: 500 },
    reverse: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false },
    scrollTarget: { type: [String, Object], default: null },
    debounce: { type: Number, default: 100 },
    tag: { type: String, default: "div" }
  },
  emits: ["onload", "onerror"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const element = shallowRef();
    const spinnerSlotContainer = shallowRef();
    const fetching = ref(false);
    const error = ref(false);
    const forcedScrolling = ref(false);
    const debouncedLoad = ref();
    const notScrolledContentBeforeLoad = ref(0);
    const prevScrollTop = ref(0);
    const scrollTargetElement = computed(() => {
      var _a2;
      let target;
      if (typeof props.scrollTarget === "string") {
        target = document.querySelector(props.scrollTarget);
      } else {
        target = props.scrollTarget || ((_a2 = element.value) == null ? void 0 : _a2.parentElement);
      }
      return target || document.body;
    });
    const {
      addScrollListener,
      removeScrollListener
    } = useScroll(props, scrollTargetElement, debouncedLoad);
    const { getColor } = useColors();
    const spinnerColor = computed(() => {
      return error.value ? getColor("danger") : getColor("primary");
    });
    const spinnerHeight = computed(() => {
      var _a2;
      return ((_a2 = spinnerSlotContainer.value) == null ? void 0 : _a2.offsetHeight) || 0;
    });
    const computedOffset = computed(() => {
      return props.offset + spinnerHeight.value;
    });
    const stop = () => {
      if (props.disabled) {
        return;
      }
      fetching.value = false;
      removeScrollListener();
    };
    const resume = () => {
      if (props.disabled) {
        return;
      }
      addScrollListener();
    };
    const onLoad = () => {
      const { scrollTop, scrollHeight, clientHeight } = scrollTargetElement.value;
      notScrolledContentBeforeLoad.value = scrollHeight - scrollTop;
      const scrollDelta = scrollTop - prevScrollTop.value;
      prevScrollTop.value = scrollTop;
      if (props.disabled || error.value || fetching.value) {
        return;
      }
      if (forcedScrolling.value) {
        forcedScrolling.value = false;
        return;
      }
      const isReverseScrollDirection = props.reverse && scrollDelta > 0 || !props.reverse && scrollDelta < 0;
      if (isReverseScrollDirection) {
        return;
      }
      const offset2 = props.reverse ? scrollTop : scrollHeight - scrollTop - clientHeight;
      if (offset2 > computedOffset.value) {
        return;
      }
      fetching.value = true;
      props.load().then(finishLoading).catch(onError);
    };
    const forceSetScrollTopToTarget = (value) => {
      forcedScrolling.value = true;
      scrollTargetElement.value.scrollTop = value;
    };
    const updateTargetElementScrollTop = () => {
      const { scrollTop, scrollHeight, clientHeight } = scrollTargetElement.value;
      if (props.reverse) {
        const isScrolledUp = scrollHeight - scrollTop < notScrolledContentBeforeLoad.value;
        const isSpinnerHidden = scrollTop >= spinnerHeight.value;
        if (isScrolledUp && isSpinnerHidden) {
          return;
        }
        scrollHeight - notScrolledContentBeforeLoad.value > spinnerHeight.value ? forceSetScrollTopToTarget(scrollHeight - notScrolledContentBeforeLoad.value) : forceSetScrollTopToTarget(spinnerHeight.value);
      }
      if (!props.reverse) {
        const isSpinnerHidden = scrollHeight - scrollTop - clientHeight >= spinnerHeight.value;
        !isSpinnerHidden && forceSetScrollTopToTarget(scrollHeight - clientHeight - spinnerHeight.value);
      }
    };
    const finishLoading = () => {
      updateTargetElementScrollTop();
      fetching.value = false;
      emit("onload");
    };
    const stopErrorDisplay = () => {
      updateTargetElementScrollTop();
      forcedScrolling.value = false;
      error.value = false;
      fetching.value = false;
      emit("onerror");
    };
    const onError = () => {
      stop();
      error.value = true;
      sleep(1200).then(stopErrorDisplay).then(resume);
    };
    watch(() => props.debounce, (value) => {
      debouncedLoad.value = debounce$2(onLoad, value);
    }, { immediate: true });
    watch(() => props.disabled, (value) => {
      value ? stop() : resume();
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(resolveDynamicComponent(_ctx.$props.tag), {
        ref_key: "element",
        ref: element,
        role: "feed",
        class: normalizeClass(["va-infinite-scroll", { "va-infinite-scroll--reversed": _ctx.$props.reverse }]),
        "aria-busy": fetching.value
      }, {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default"),
          createBaseVNode("div", {
            ref_key: "spinnerSlotContainer",
            ref: spinnerSlotContainer,
            class: normalizeClass(["va-infinite-scroll__spinner", { "va-infinite-scroll__spinner--invisible": !fetching.value }])
          }, [
            !_ctx.$props.disabled ? renderSlot(_ctx.$slots, "loading", { key: 0 }, () => [
              createBaseVNode("div", _hoisted_140, [
                createVNode(unref(VaProgressCircle), {
                  size: "small",
                  thickness: 0.15,
                  color: spinnerColor.value,
                  indeterminate: ""
                }, null, 8, ["color"])
              ])
            ]) : createCommentVNode("", true)
          ], 2)
        ]),
        _: 3
      }, 8, ["class", "aria-busy"]);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-infinite-scroll/VaInfiniteScroll.js
var _style_066 = ":root,\n:host {\n  --va-infinite-scroll-display: flex;\n  --va-infinite-scroll-flex-direction: column;\n  --va-infinite-scroll-spinner-default-width: 100%;\n  --va-infinite-scroll-spinner-default-min-height: 70px;\n  /* Reversed */\n  --va-infinite-scroll-reversed-flex-direction: column-reverse;\n}\n.va-infinite-scroll {\n  display: var(--va-infinite-scroll-display);\n  flex-direction: var(--va-infinite-scroll-flex-direction);\n  font-family: var(--va-font-family);\n}\n.va-infinite-scroll--reversed {\n  flex-direction: var(--va-infinite-scroll-reversed-flex-direction);\n}\n.va-infinite-scroll__spinner {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n}\n.va-infinite-scroll__spinner__default {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  width: var(--va-infinite-scroll-spinner-default-width);\n  min-height: var(--va-infinite-scroll-spinner-default-min-height);\n}\n.va-infinite-scroll__spinner--invisible {\n  visibility: hidden !important;\n}";
var _VaInfiniteScroll = _export_sfc(_sfc_main70, [["styles", [_style_066]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-infinite-scroll/index.js
var VaInfiniteScroll = withConfigTransport$1(_VaInfiniteScroll);

// node_modules/vuestic-ui/dist/web-components/src/components/va-layout/hooks/useGridTemplateArea.js
var areaIndexes = {
  top: [0, 1, 2],
  left: [0, 3, 6],
  right: [2, 5, 8],
  bottom: [6, 7, 8]
};
var areaElements = ["left", "right", "top", "bottom"];
var useGridTemplateArea = (props) => {
  const sort = () => {
    return [...areaElements].sort((a, b) => {
      return (props[a].order ?? 0) - (props[b].order ?? 0);
    });
  };
  const applyTemplate = (template, areaIndexes2, areaName) => {
    areaIndexes2.forEach((index) => {
      template[index] = areaName;
    });
  };
  return computed(() => {
    const sorted = sort();
    const template = [
      ".",
      ".",
      ".",
      ".",
      ".",
      ".",
      ".",
      ".",
      "."
    ].map(() => "content");
    sorted.forEach((areaName) => {
      applyTemplate(template, areaIndexes[areaName], areaName);
    });
    return [
      '"' + template.slice(0, 3).join(" ") + '"',
      '"' + template.slice(3, 6).join(" ") + '"',
      '"' + template.slice(6, 9).join(" ") + '"'
    ].join(" ");
  });
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-layout/hooks/useLayout.js
var useLayoutProps = {
  top: {
    type: Object,
    default: () => ({ order: 2 })
  },
  right: {
    type: Object,
    default: () => ({ order: 1 })
  },
  left: {
    type: Object,
    default: () => ({ order: 1 })
  },
  bottom: {
    type: Object,
    default: () => ({ order: 2 })
  }
};
var VaLayoutKey = "VaLayout";
var useLayout = (props) => {
  const items2 = ref({
    top: null,
    right: null,
    bottom: null,
    left: null
  });
  const paddings = computed(() => {
    const { top, right, bottom, left } = items2.value;
    const { top: topConfig, right: rightConfig, bottom: bottomConfig, left: leftConfig } = props;
    return {
      top: top && !topConfig.absolute ? top.sizes.height : 0,
      right: right && !rightConfig.absolute ? right.sizes.width : 0,
      bottom: bottom && !bottomConfig.absolute ? bottom.sizes.height : 0,
      left: left && !leftConfig.absolute ? left.sizes.width : 0
    };
  });
  const orders = computed(() => ({
    top: props.top.order || 0,
    right: props.right.order || 0,
    bottom: props.bottom.order || 0,
    left: props.left.order || 0
  }));
  provide(VaLayoutKey, {
    items: items2,
    paddings,
    orders
  });
  return {
    paddings,
    orders,
    items: items2
  };
};
var useFixedLayoutChild = (area, sizes) => {
  const layout = inject(VaLayoutKey, null);
  if (!layout) {
    throw new Error("VaLayoutChild must be used inside VaLayout");
  }
  watchEffect(() => {
    if (sizes.value) {
      layout.items.value[area] = {
        sizes: sizes.value
      };
    } else {
      layout.items.value[area] = null;
    }
  });
  onBeforeUnmount(() => {
    layout.items.value[area] = null;
  });
  return {
    paddings: computed(() => {
      return Object.keys(layout.paddings.value).reduce((acc, key) => {
        if (layout.orders.value[key] > layout.orders.value[area]) {
          acc[key] = layout.paddings.value[key];
        }
        return acc;
      }, {});
    })
  };
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-layout/components/VaLayoutAbsoluteWrapper.js
var _style_067 = ".va-layout__absolute-area-wrapper .va-layout__area {\n  position: absolute;\n}\n.va-layout__absolute-area-wrapper .va-layout__area--top {\n  width: 100%;\n}\n.va-layout__absolute-area-wrapper .va-layout__area--bottom {\n  width: 100%;\n}\n.va-layout__absolute-area-wrapper .va-layout__area--right {\n  right: 0;\n  height: 100%;\n}\n.va-layout__absolute-area-wrapper .va-layout__area--left {\n  left: 0;\n  height: 100%;\n}";
var _sfc_main71 = {};
var _hoisted_141 = { class: "va-layout__absolute-area-wrapper" };
function _sfc_render3(_ctx, _cache) {
  return openBlock(), createElementBlock("div", _hoisted_141, [
    renderSlot(_ctx.$slots, "default")
  ]);
}
var VaLayoutAbsoluteWrapper = _export_sfc(_sfc_main71, [["render", _sfc_render3], ["styles", [...(_sfc_main71.components ? Object.values(_sfc_main71.components) : []).map((c) => c.styles || []).flat(), _style_067]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-layout/components/VaResizeObserver.vue_vue_type_script_setup_true_lang.js
var _sfc_main72 = defineComponent({
  ...{
    name: "VaLayoutSizeKeeper"
  },
  __name: "VaResizeObserver",
  emits: {
    resize: (size2) => true
  },
  setup(__props, { emit: __emit }) {
    const emit = __emit;
    const el = ref();
    let observer = null;
    watch(el, (newEl) => {
      if (observer) {
        observer.disconnect();
      }
      observer = new ResizeObserver(([el2]) => {
        emit("resize", el2.contentRect);
      });
      observer.observe(newEl);
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: "va-resize-observer",
        ref_key: "el",
        ref: el
      }, [
        renderSlot(_ctx.$slots, "default")
      ], 512);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-layout/components/VaLayoutFixedWrapper.vue_vue_type_script_setup_true_lang.js
var _sfc_main73 = defineComponent({
  ...{
    name: "VaLayoutFixedWrapper"
  },
  __name: "VaLayoutFixedWrapper",
  props: {
    area: { type: String, required: true }
  },
  setup(__props) {
    useCssVars((_ctx) => ({
      "5bc48db5": styles.value.width,
      "02fe2f18": styles.value.height
    }));
    const props = __props;
    const size2 = ref(null);
    const direction = computed(() => {
      if (props.area === "top" || props.area === "bottom") {
        return "vertical";
      } else {
        return "horizontal";
      }
    });
    const getPxOrZero = (value) => {
      if (!value) {
        return "0px";
      }
      return value + "px";
    };
    const styles = computed(() => {
      if (direction.value === "vertical") {
        return { width: `calc(100% - ${getPxOrZero(paddings.value.left)} - ${getPxOrZero(paddings.value.right)})`, [props.area]: 0 };
      } else {
        return { height: `calc(100% - ${getPxOrZero(paddings.value.top)} - ${getPxOrZero(paddings.value.bottom)})`, [props.area]: 0 };
      }
    });
    const { paddings } = useFixedLayoutChild(props.area, size2);
    computed(() => {
      return Object.keys(paddings.value).reduce((acc, key) => {
        if (key === props.area) {
          return acc;
        }
        return {
          ...acc,
          [key]: `${paddings.value[key]}px`
        };
      }, {});
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: "va-layout-fixed-wrapper",
        style: normalizeStyle([{
          height: size2.value && direction.value === "vertical" ? size2.value.height + "px" : "auto",
          width: size2.value && direction.value === "horizontal" ? size2.value.width + "px" : "auto"
        }])
      }, [
        createVNode(_sfc_main72, {
          class: normalizeClass(["va-layout-fixed-wrapper__content", `va-layout-fixed-wrapper__content--${__props.area}`]),
          style: normalizeStyle(!size2.value ? { position: "relative" } : {}),
          onResize: _cache[0] || (_cache[0] = ($event) => size2.value = $event)
        }, {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "default")
          ]),
          _: 3
        }, 8, ["class", "style"])
      ], 4);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-layout/components/VaLayoutFixedWrapper.js
var _style_068 = ".va-layout-fixed-wrapper {\n  position: relative;\n  flex: 1;\n}\n.va-layout-fixed-wrapper__content {\n  position: fixed;\n  width: var(--5bc48db5);\n  height: var(--02fe2f18);\n}\n@media print {\n.va-layout-fixed-wrapper__content {\n    position: relative !important;\n    height: -moz-max-content !important;\n    height: max-content !important;\n    width: -moz-max-content !important;\n    width: max-content !important;\n}\n}\n.va-layout-fixed-wrapper__content--top {\n  top: 0;\n}\n.va-layout-fixed-wrapper__content--bottom {\n  bottom: 0;\n}\n.va-layout-fixed-wrapper__content--right {\n  right: 0;\n}\n.va-layout-fixed-wrapper__content--left {\n  left: 0;\n}";
var VaLayoutFixedWrapper = _export_sfc(_sfc_main73, [["styles", [_style_068]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-layout/components/VaLayoutArea.vue_vue_type_script_setup_true_lang.js
var _sfc_main74 = defineComponent({
  ...{
    name: "VaLayoutArea"
  },
  __name: "VaLayoutArea",
  props: {
    area: { type: String, required: true },
    config: { type: Object, required: true }
  },
  emits: ["overlay-click"],
  setup(__props, { emit: __emit }) {
    useCssVars((_ctx) => ({
      "4f653294": _ctx.$props.area,
      "2ca82833": zIndex.value,
      "619be0de": zIndex.value - 1
    }));
    const props = __props;
    const absolute = computed(() => props.config.absolute || false);
    const fixed = computed(() => props.config.fixed || false);
    const overlay = computed(() => props.config.overlay || false);
    const zIndex = computed(() => (props.config.order || 0) + 1);
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock(Fragment, null, [
        absolute.value ? (openBlock(), createBlock(VaLayoutAbsoluteWrapper, { key: 0 }, {
          default: withCtx(() => [
            createBaseVNode("div", {
              class: normalizeClass(`va-layout-area va-layout__area va-layout__area--${__props.area}`)
            }, [
              fixed.value ? (openBlock(), createBlock(VaLayoutFixedWrapper, {
                key: 0,
                area: __props.area
              }, {
                default: withCtx(() => [
                  renderSlot(_ctx.$slots, "default")
                ]),
                _: 3
              }, 8, ["area"])) : renderSlot(_ctx.$slots, "default", { key: 1 })
            ], 2)
          ]),
          _: 3
        })) : (openBlock(), createElementBlock("div", {
          key: 1,
          class: normalizeClass(`va-layout-area va-layout__area va-layout__area--${__props.area}`)
        }, [
          fixed.value ? (openBlock(), createBlock(VaLayoutFixedWrapper, {
            key: 0,
            area: __props.area
          }, {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "default")
            ]),
            _: 3
          }, 8, ["area"])) : renderSlot(_ctx.$slots, "default", { key: 1 })
        ], 2)),
        createVNode(Transition, null, {
          default: withCtx(() => [
            overlay.value ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: normalizeClass(["va-layout-area__overlay", { "va-layout-area__overlay--fixed": fixed.value }]),
              onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("overlay-click"))
            }, null, 2)) : createCommentVNode("", true)
          ]),
          _: 1
        })
      ], 64);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-layout/components/VaLayoutArea.js
var _style_069 = ".va-layout__area {\n  grid-area: var(--4f653294);\n  z-index: var(--2ca82833);\n}\n.va-layout__absolute-area-wrapper {\n  z-index: var(--2ca82833);\n}\n.va-layout-area {\n  display: flex;\n}\n.va-layout-area__overlay {\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  background: var(--va-layout-overlay-color);\n  z-index: var(--619be0de);\n}\n.va-layout-area__overlay.v-enter-active, .va-layout-area__overlay.v-leave-active {\n  transition: opacity 0.5s ease;\n}\n.va-layout-area__overlay.v-enter-from, .va-layout-area__overlay.v-leave-to {\n  opacity: 0;\n}\n.va-layout-area__overlay--fixed {\n  position: fixed;\n}";
var VaLayoutArea = _export_sfc(_sfc_main74, [["styles", [_style_069]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-layout/VaLayout.vue_vue_type_script_setup_true_lang.js
var _hoisted_142 = { class: "va-layout" };
var _hoisted_220 = { class: "va-layout__area va-layout__area--content" };
var areaNames = [
  "top",
  "left",
  "right",
  "bottom"
];
var _sfc_main75 = defineComponent({
  ...{
    name: "VaLayout"
  },
  __name: "VaLayout",
  props: {
    ...useLayoutProps,
    allowBodyScrollOnOverlay: { type: Boolean, default: false }
  },
  emits: [
    "top-overlay-click",
    "left-overlay-click",
    "right-overlay-click",
    "bottom-overlay-click"
  ],
  setup(__props, { emit: __emit }) {
    useCssVars((_ctx) => ({
      "26bb68e3": horizontalTemplate.value,
      "6c829775": verticalTemplate.value,
      "21ec940c": unref(templateArea),
      "54ed9602": unref(paddings).top + "px",
      "5729798a": unref(paddings).bottom + "px",
      "7da6afc2": unref(paddings).left + "px",
      "6d0e4ed0": unref(paddings).right + "px"
    }));
    const props = __props;
    const { paddings } = useLayout(props);
    const doDisableScroll = computed(() => {
      return !props.allowBodyScrollOnOverlay && areaNames.some((area) => {
        var _a2;
        return (_a2 = props[area]) == null ? void 0 : _a2.overlay;
      });
    });
    const document2 = useDocument();
    watchEffect(() => {
      var _a2;
      const overflowParent = (_a2 = document2.value) == null ? void 0 : _a2.body;
      if (!overflowParent) {
        return;
      }
      if (doDisableScroll.value) {
        overflowParent.style.overflow = "hidden";
      } else {
        overflowParent.style.overflow = "";
      }
    });
    const templateArea = useGridTemplateArea(props);
    const slots = useSlots();
    const verticalTemplate = computed(() => {
      return [
        slots.top ? "min-content" : "0fr",
        "1fr",
        slots.bottom ? "min-content" : "0fr"
      ].filter(Boolean).join(" ");
    });
    const horizontalTemplate = computed(() => {
      return [
        slots.left ? "min-content" : "0fr",
        "1fr",
        slots.right ? "min-content" : "0fr"
      ].filter(Boolean).join(" ");
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_142, [
        (openBlock(), createElementBlock(Fragment, null, renderList(areaNames, (area) => {
          return createVNode(VaLayoutArea, {
            key: area,
            area,
            config: _ctx.$props[area] || {},
            onOverlayClick: ($event) => _ctx.$emit(`${area}-overlay-click`)
          }, {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, area)
            ]),
            _: 2
          }, 1032, ["area", "config", "onOverlayClick"]);
        }), 64)),
        createBaseVNode("div", _hoisted_220, [
          renderSlot(_ctx.$slots, "default", {}, () => [
            renderSlot(_ctx.$slots, "content")
          ])
        ])
      ]);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-layout/VaLayout.js
var _style_070 = ":root,\n:host {\n  --va-layout-overlay-color: rgba(0, 0, 0, 0.5);\n  --va-layout-scroll-padding: 1rem;\n}\n.va-layout {\n  display: grid;\n  grid-template-columns: var(--26bb68e3);\n  grid-template-rows: var(--6c829775);\n  grid-template-areas: var(--21ec940c);\n  gap: 0;\n  position: relative;\n  z-index: 0;\n  max-width: 100%;\n  max-height: 100%;\n}\n.va-layout__area {\n  scrollbar-color: var(--va-background-element) transparent;\n  scrollbar-width: thin;\n  transition: scrollbar-color 0.3s ease-in-out;\n}\n.va-layout__area::-webkit-scrollbar {\n  width: 4px;\n  height: 4px;\n}\n.va-layout__area::-webkit-scrollbar-track {\n  box-shadow: none;\n  border-radius: 10px;\n}\n.va-layout__area::-webkit-scrollbar-thumb {\n  background: var(--va-background-element);\n  opacity: 0.3;\n  border-radius: 2px;\n  -webkit-transition: background 0.3s ease-in-out;\n  transition: background 0.3s ease-in-out;\n}\n.va-layout__area--content {\n  grid-area: content;\n  z-index: 0;\n  min-width: 0;\n  min-height: 0;\n}\n.va-layout__area--content [id] {\n  scroll-margin-top: calc(var(--54ed9602) + var(--va-layout-scroll-padding));\n  scroll-margin-bottom: calc(var(--5729798a) + var(--va-layout-scroll-padding));\n  scroll-margin-left: calc(var(--7da6afc2) + var(--va-layout-scroll-padding));\n  scroll-margin-right: calc(var(--6d0e4ed0) + var(--va-layout-scroll-padding));\n}";
var _VaLayout = _export_sfc(_sfc_main75, [["styles", [_style_070]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-layout/index.js
var VaLayout = withConfigTransport(_VaLayout);

// node_modules/vuestic-ui/dist/web-components/src/components/va-navbar/VaNavbar.vue_vue_type_script_setup_true_lang.js
var _hoisted_143 = { class: "va-navbar__left" };
var _hoisted_221 = { class: "va-navbar__center" };
var _hoisted_313 = { class: "va-navbar__right" };
var _sfc_main76 = defineComponent({
  ...{
    name: "VaNavbar"
  },
  __name: "VaNavbar",
  props: {
    ...useFixedBarProps,
    ...useComponentPresetProp,
    color: { type: String, default: "background-secondary" },
    textColor: { type: String },
    shape: { type: Boolean, default: false },
    shadowed: { type: Boolean, default: false },
    bordered: { type: Boolean, default: false }
  },
  setup(__props) {
    const props = __props;
    const { scrollRoot, isScrolledDown } = setupScroll(props.fixed);
    const { fixedBarStyleComputed } = useFixedBar(props, isScrolledDown);
    const { getColor, shiftHSLAColor: shiftHSLAColor2 } = useColors();
    const color = computed(() => getColor(props.color));
    const { textColorComputed } = useTextColor(color);
    const shapeStyleComputed = computed(() => ({
      borderTopColor: shiftHSLAColor2(color.value, { h: -1, s: -11, l: 10 })
    }));
    const computedStyle = computed(() => ({
      ...fixedBarStyleComputed.value,
      backgroundColor: color.value,
      color: textColorComputed.value,
      fill: textColorComputed.value
    }));
    const bemClasses = useBem("va-navbar", () => ({
      shadowed: props.shadowed,
      bordered: props.bordered
    }));
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("header", {
        ref_key: "scrollRoot",
        ref: scrollRoot,
        class: normalizeClass(["va-navbar", unref(bemClasses)]),
        style: normalizeStyle(computedStyle.value)
      }, [
        renderSlot(_ctx.$slots, "default", {}, () => [
          createBaseVNode("div", _hoisted_143, [
            renderSlot(_ctx.$slots, "left")
          ]),
          createBaseVNode("div", _hoisted_221, [
            renderSlot(_ctx.$slots, "center")
          ]),
          createBaseVNode("div", _hoisted_313, [
            renderSlot(_ctx.$slots, "right")
          ])
        ]),
        __props.shape ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: "va-navbar__background-shape",
          style: normalizeStyle(shapeStyleComputed.value)
        }, null, 4)) : createCommentVNode("", true)
      ], 6);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-navbar/VaNavbar.js
var _style_071 = '.va-navbar {\n  --va-navbar-mobile-height: 6.5rem;\n  --va-navbar-height: 4.0625rem;\n  --va-navbar-padding-x: 1rem;\n  --va-navbar-padding-y: 1.2rem;\n  --va-navbar-transition: transform 0.5s ease;\n  --va-navbar-position: relative;\n  --va-nav-z-index: calc(var(--va-z-index-teleport-overlay) - 100);\n  --va-navbar-sm-padding: 1.1875rem 1rem 1rem;\n  --va-navbar-shape-width: 33%;\n  --va-navbar-shape-max-width: 467px;\n  --va-navbar-shape-bg: rgba(0, 0, 0, 0.5);\n  --va-navbar-shape-border-left: 3.1875rem solid transparent;\n  --va-navbar-shape-border-right: 3.1875rem solid transparent;\n  --va-navbar-shape-transition: border-top-color 0.3s ease;\n  --va-navbar-item-margin: 0.75rem;\n  --va-navbar-item-margin-side: calc(2 * var(--va-navbar-item-margin));\n}\n.va-navbar {\n  display: grid;\n  grid-template: "left center right"/1fr auto 1fr;\n  align-items: center;\n  transition: var(--va-navbar-transition);\n  position: var(--va-navbar-position);\n  padding: var(--va-navbar-padding-y) var(--va-navbar-padding-x);\n  background-color: var(--va-primary);\n  font-family: var(--va-font-family);\n  top: 0;\n  left: 0;\n  width: 100%;\n  min-width: 100%;\n  z-index: var(--va-navbar-z-index);\n}\n.va-navbar__left {\n  display: flex;\n  grid-area: left;\n}\n.va-navbar__left > .va-navbar__item {\n  margin-right: var(--va-navbar-item-margin-side);\n}\n.va-navbar__left > .va-navbar__item:last-child {\n  margin-right: 0;\n}\n.va-navbar__center {\n  display: flex;\n  justify-content: center;\n  grid-area: center;\n}\n.va-navbar__center > .va-navbar__item {\n  margin: 0 var(--va-navbar-item-margin);\n}\n.va-navbar__center > .va-navbar__item:last-child {\n  margin-right: 0;\n}\n.va-navbar__center > .va-navbar__item:first-child {\n  margin-left: 0;\n}\n.va-navbar__right {\n  display: flex;\n  flex-direction: row;\n  justify-content: flex-end;\n  grid-area: right;\n}\n.va-navbar__right > .va-navbar__item {\n  margin-right: var(--va-navbar-item-margin-side);\n}\n.va-navbar__right > .va-navbar__item:last-child {\n  margin-right: 0;\n}\n.va-navbar__background-shape {\n  transition: var(--va-navbar-shape-transition);\n  width: var(--va-navbar-shape-width);\n  max-width: var(--va-navbar-shape-max-width);\n  position: absolute;\n  left: 0;\n  right: 0;\n  top: 0;\n  margin: auto;\n  border-top: var(--va-navbar-height) solid var(--va-navbar-shape-bg);\n  border-left: var(--va-navbar-shape-border-left);\n  border-right: var(--va-navbar-shape-border-right);\n  height: 0;\n}\n@media (max-width: 767.98px) {\n.va-navbar__background-shape {\n    display: none;\n}\n}\n.va-navbar--shadowed {\n  box-shadow: 0 2px 8px var(--va-shadow);\n}\n.va-navbar--bordered {\n  border-bottom: var(--va-background-border);\n}';
var _VaNavbar = _export_sfc(_sfc_main76, [["styles", [_style_071]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-navbar/VaNavbarItem/VaNavbarItem.js
var _style_072 = ".va-navbar__item {\n  display: flex;\n  align-items: center;\n  font-family: var(--va-font-family);\n}";
var _sfc_main77 = defineComponent({
  name: "VaNavbarItem",
  props: {}
  // TODO: In web components build props are required (it's a vue bug)
});
var _hoisted_144 = { class: "va-navbar__item" };
function _sfc_render4(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_144, [
    renderSlot(_ctx.$slots, "default")
  ]);
}
var _VaNavbarItem = _export_sfc(_sfc_main77, [["render", _sfc_render4], ["styles", [...(_sfc_main77.components ? Object.values(_sfc_main77.components) : []).map((c) => c.styles || []).flat(), _style_072]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-navbar/index.js
var VaNavbar = withConfigTransport$1(_VaNavbar);
var VaNavbarItem = withConfigTransport$1(_VaNavbarItem);

// node_modules/vuestic-ui/dist/web-components/src/components/va-radio/VaRadio.vue_vue_type_script_setup_true_lang.js
var _hoisted_145 = ["role"];
var _hoisted_222 = ["value", "checked", "aria-checked", "onChange"];
var _hoisted_314 = createBaseVNode("span", {
  "aria-hidden": "true",
  class: "va-radio__icon"
}, [
  createBaseVNode("span", { class: "va-radio__icon__background" }),
  createBaseVNode("span", { class: "va-radio__icon__dot" })
], -1);
var _sfc_main78 = defineComponent({
  ...{
    name: "VaRadio"
  },
  __name: "VaRadio",
  props: {
    ...useSelectableProps,
    ...useComponentPresetProp,
    ...useSelectableListProps,
    modelValue: {
      type: [Boolean, Array, String, Object, Number],
      default: null
    },
    options: {
      type: Array,
      default: () => []
    },
    name: { type: String, default: "" },
    label: { type: String, default: void 0 },
    leftLabel: { type: Boolean, default: false },
    color: { type: String, default: "primary" },
    option: {
      type: [Object, String, Number],
      default: void 0
    },
    vertical: { type: Boolean, default: false }
  },
  emits: useSelectableEmits,
  setup(__props, { emit: __emit }) {
    useCssVars((_ctx) => ({
      "f4c02cf8": flexDirection.value,
      "2df07694": labelStyle.value.color,
      "2c372ada": iconComputedStyles.value.borderColor,
      "afbb22b4": iconDotComputedStyles.value.borderColor,
      "29e43f64": iconDotComputedStyles.value.backgroundColor,
      "14de13df": iconBackgroundComputedStyles.value.backgroundColor
    }));
    const props = __props;
    const emit = __emit;
    const { getColor } = useColors();
    const elements = {
      container: shallowRef(),
      input: shallowRef(),
      label: shallowRef()
    };
    const {
      computedError,
      computedErrorMessages,
      validationAriaAttributes,
      onBlur,
      onFocus
    } = useSelectable(props, emit, elements);
    const { getText: originalGetText, getDisabled: originalGetDisabled, getValue: getValue2 } = useSelectableList(props);
    const getText = (option) => {
      if (props.options.length > 0) {
        return originalGetText(option);
      }
      return props.label ?? originalGetText(option);
    };
    const getDisabled = (option) => originalGetDisabled(option) || props.disabled;
    const isNoOption = computed(() => props.options.length === 0 && !props.option);
    const isChecked = (option) => {
      if (isNoOption.value) {
        return props.modelValue;
      }
      return props.modelValue === getValue2(option);
    };
    const computedOptions = computed(() => {
      if (isNoOption.value) {
        return [{}];
      }
      if (props.option) {
        return [props.option];
      } else {
        return props.options;
      }
    });
    const radioClass = (option) => ({
      "va-radio--left-label": props.leftLabel,
      "va-radio--selected": isChecked(option),
      "va-radio--readonly": props.readonly,
      "va-radio--disabled": props.disabled,
      "va-radio--indeterminate": props.indeterminate,
      "va-radio--error": computedError.value,
      "va-radio--single-option": isNoOption.value
    });
    const selectOption = (option, event) => {
      var _a2;
      if (isNoOption.value) {
        emit("update:modelValue", ((_a2 = event == null ? void 0 : event.target) == null ? void 0 : _a2.checked) || false);
        return;
      }
      emit("update:modelValue", option);
    };
    const labelStyle = computed(() => {
      return {
        color: computedError.value ? getColor("danger") : ""
      };
    });
    computed(() => {
      const style = {
        background: getColor(props.color),
        borderColor: getColor(props.color)
      };
      if (computedError.value) {
        style.borderColor = getColor("danger");
      }
      return style;
    });
    const iconBackgroundComputedStyles = computed(() => ({
      backgroundColor: getColor(props.color)
    }));
    const iconDotComputedStyles = computed(() => {
      return {
        borderColor: computedError.value ? getColor("danger") : getColor(props.color),
        backgroundColor: getColor(props.color)
      };
    });
    const iconComputedStyles = computed(() => {
      return { borderColor: computedError.value ? getColor("danger") : getColor(props.color) };
    });
    const computedName = computed(() => props.name || generateUniqueId());
    const inputAttributesComputed = (option) => {
      const disabled = getDisabled(option);
      return {
        name: computedName.value,
        disabled,
        readonly: props.readonly,
        tabindex: disabled ? -1 : 0
      };
    };
    const flexDirection = computed(() => props.vertical ? "column" : "row");
    const roleComputed = computed(() => {
      var _a2;
      return ((_a2 = props.options) == null ? void 0 : _a2.length) > 0 ? "radiogroup" : "";
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(VaMessageListWrapper), {
        disabled: _ctx.disabled,
        success: _ctx.success,
        messages: _ctx.messages,
        error: unref(computedError),
        "error-messages": unref(computedErrorMessages),
        "error-count": _ctx.errorCount,
        onBlur: unref(onBlur)
      }, {
        default: withCtx(({ ariaAttributes }) => [
          createBaseVNode("div", mergeProps({
            ref: "container",
            class: "va-radio",
            role: roleComputed.value
          }, ariaAttributes), [
            (openBlock(true), createElementBlock(Fragment, null, renderList(computedOptions.value, (option, index) => {
              return openBlock(), createElementBlock("label", {
                key: index,
                class: normalizeClass([radioClass(option), "va-radio__square"])
              }, [
                createBaseVNode("input", mergeProps({
                  ref_for: true,
                  ref: "input",
                  class: "va-radio__input",
                  type: "radio",
                  role: "radio",
                  value: isChecked(option),
                  checked: isChecked(option),
                  "aria-checked": isChecked(option)
                }, { ...inputAttributesComputed(option), ...ariaAttributes }, {
                  onChange: ($event) => selectOption(unref(getValue2)(option), $event),
                  onFocus: _cache[0] || (_cache[0] = //@ts-ignore
                  (...args) => unref(onFocus) && unref(onFocus)(...args)),
                  onBlur: _cache[1] || (_cache[1] = //@ts-ignore
                  (...args) => unref(onBlur) && unref(onBlur)(...args))
                }), null, 16, _hoisted_222),
                renderSlot(_ctx.$slots, "icon", normalizeProps(guardReactiveProps({
                  value: isChecked(option),
                  text: getText(option),
                  disabled: getDisabled(option),
                  index
                })), () => [
                  _hoisted_314
                ]),
                getText(option) || _ctx.$slots.default ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  ref_for: true,
                  ref: "label",
                  class: "va-radio__text"
                }, [
                  renderSlot(_ctx.$slots, "default", normalizeProps(guardReactiveProps({
                    value: isChecked(option),
                    text: getText(option),
                    disabled: getDisabled(option),
                    index
                  })), () => [
                    createTextVNode(toDisplayString(getText(option)), 1)
                  ])
                ], 512)) : createCommentVNode("", true)
              ], 2);
            }), 128))
          ], 16, _hoisted_145)
        ]),
        _: 3
      }, 8, ["disabled", "success", "messages", "error", "error-messages", "error-count", "onBlur"]);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-radio/VaRadio.js
var _style_073 = ':root,\n:host {\n  --va-radio-display: inline-flex;\n  --va-radio-cursor: pointer;\n  --va-radio-position: relative;\n  --va-radio-gap: 0.5rem;\n  --va-radio-transition: 0.3s cubic-bezier(0.25, 0.8, 0.5, 1);\n  --va-radio-disabled-cursor: default;\n  --va-radio-border-color: var(--va-background-border);\n  --va-radio-background: transparent;\n  /* Icon */\n  --va-radio-icon-transition: 0.3s cubic-bezier(0.25, 0.8, 0.5, 1);\n  --va-radio-icon-width: 1.4rem;\n  --va-radio-icon-height: 1.4rem;\n  --va-radio-icon-border-radius: 100%;\n  --va-radio-icon-border: var(--va-background-border) solid var(--va-form-element-border-width);\n  /* Dot */\n  --va-radio-dot-transition: 0.3s cubic-bezier(0.25, 0.8, 0.5, 1);\n  --va-radio-dot-top: 50%;\n  --va-radio-dot-left: 50%;\n  --va-radio-dot-right: 50%;\n  --va-radio-dot-bottom: 50%;\n  --va-radio-dot-border-radius: 100%;\n  --va-radio-dot-background-color: inherit;\n  --va-radio-dot-opacity: 0;\n  /* Background */\n  --va-radio-background-transition: 0.3s cubic-bezier(0.25, 0.8, 0.5, 1);\n  --va-radio-background-top: -0.35rem;\n  --va-radio-background-left: -0.35rem;\n  --va-radio-background-right: -0.35rem;\n  --va-radio-background-bottom: -0.35rem;\n  --va-radio-background-background-color: var(--va-background-element);\n  --va-radio-background-border-radius: 100%;\n  --va-radio-background-z-index: 0;\n  --va-radio-background-opacity: 0;\n  /* Text */\n  --va-radio-text-display: inline-flex;\n  --va-radio-text-margin-left: 0.5rem;\n  --va-radio-text-margin-right: 0;\n}\n.va-radio {\n  display: flex;\n  width: -moz-max-content;\n  width: max-content;\n  flex-direction: var(--f4c02cf8);\n  gap: var(--va-radio-gap);\n}\n.va-radio__square {\n  display: inline-flex;\n  align-items: center;\n  width: 100%;\n  cursor: var(--va-radio-cursor);\n  position: var(--va-radio-position);\n  margin-top: var(--va-radio-margin-top);\n  margin-right: var(--va-radio-margin-right);\n  transition: var(--va-radio-transition, var(--va-swing-transition));\n  font-family: var(--va-font-family);\n  color: var(--2df07694);\n}\n.va-radio + .va-radio {\n  margin-top: 0.5rem;\n}\n.va-radio .va-radio:last-child {\n  margin: 0;\n}\n.va-radio--disabled {\n  cursor: var(--va-radio-disabled-cursor);\n}\n.va-radio--readonly {\n  cursor: default;\n  pointer-events: none;\n}\n.va-radio--readonly .va-radio--left-label,\n.va-radio--readonly .va-radio__text {\n  cursor: initial;\n  pointer-events: none;\n}\n.va-radio--left-label {\n  flex-direction: row-reverse;\n  display: inline-flex;\n  align-items: center;\n}\n.va-radio--left-label.va-radio__square {\n  justify-content: space-between;\n}\n.va-radio__input {\n  position: absolute;\n  width: 1px;\n  height: 1px;\n  margin: -1px;\n  border: 0;\n  padding: 0;\n  white-space: nowrap;\n  -webkit-clip-path: inset(100%);\n          clip-path: inset(100%);\n  clip: rect(0 0 0 0);\n  overflow: hidden;\n}\n.va-radio__icon {\n  transition: var(--va-radio-icon-transition);\n  display: flex;\n  align-items: center;\n  width: var(--va-radio-icon-width);\n  height: var(--va-radio-icon-height);\n  border-color: var(--2c372ada);\n  border-radius: var(--va-radio-icon-border-radius);\n  background: var(--va-radio-background);\n  position: relative;\n  border: var(--va-radio-icon-border);\n  box-sizing: border-box;\n  margin: 4px;\n}\n.va-radio__input:disabled + .va-radio__icon {\n  cursor: default;\n  opacity: 0.4;\n  pointer-events: none;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n          user-select: none;\n}\n.va-radio__input:focus-visible + .va-radio__icon {\n  outline: 2px solid var(--va-focus) !important;\n  border-radius: "inherit";\n}\n.va-radio__icon__dot {\n  transition: var(--va-radio-dot-transition, var(--va-swing-transition));\n  position: absolute;\n  top: var(--va-radio-dot-top);\n  left: var(--va-radio-dot-left);\n  right: var(--va-radio-dot-right);\n  bottom: var(--va-radio-dot-bottom);\n  border-radius: var(--va-radio-dot-border-radius);\n  opacity: var(--va-radio-dot-opacity);\n  border-color: var(--afbb22b4);\n  background-color: var(--29e43f64);\n}\n.va-radio__input:checked + .va-radio__icon .va-radio__icon__dot {\n  opacity: 1;\n  top: 0.25rem;\n  left: 0.25rem;\n  right: 0.25rem;\n  bottom: 0.25rem;\n}\n.va-radio__icon__background {\n  transition: var(--va-radio-background-transition, var(--va-swing-transition));\n  position: absolute;\n  top: var(--va-radio-background-top);\n  left: var(--va-radio-background-left);\n  right: var(--va-radio-background-right);\n  bottom: var(--va-radio-background-bottom);\n  border-radius: var(--va-radio-background-border-radius);\n  z-index: var(--va-radio-background-z-index);\n  opacity: var(--va-radio-background-opacity);\n  background-color: var(--14de13df);\n}\n.va-radio__square:hover .va-radio__icon__background {\n  opacity: 0.2;\n}\n.va-radio--disabled .va-radio__square:hover .va-radio__icon__background {\n  opacity: 0;\n}\n.va-radio__text {\n  display: var(--va-radio-text-display);\n  margin-left: var(--va-radio-text-margin-left);\n  margin-right: var(--va-radio-text-margin-right);\n  white-space: nowrap;\n}\n.va-radio--disabled .va-radio__text {\n  cursor: default;\n  opacity: 0.4;\n  pointer-events: none;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n          user-select: none;\n}\n.va-radio--left-label .va-radio__text {\n  margin-right: var(--va-radio-text-margin-left);\n  margin-left: var(--va-radio-text-margin-right);\n}';
var _VaRadio = _export_sfc(_sfc_main78, [["styles", [_style_073]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-radio/index.js
var VaRadio = withConfigTransport$1(_VaRadio);

// node_modules/vuestic-ui/dist/web-components/src/components/va-switch/VaSwitch.vue_vue_type_script_setup_true_lang.js
var _hoisted_146 = { class: "va-switch__inner" };
var _hoisted_223 = { class: "va-switch__checker-wrapper" };
var _hoisted_315 = { class: "va-switch__checker" };
var _hoisted_48 = { class: "va-switch__checker-circle" };
var _hoisted_57 = ["id"];
var _sfc_main79 = defineComponent({
  ...{
    name: "VaSwitch"
  },
  __name: "VaSwitch",
  props: {
    ...useSelectableProps,
    ...useComponentPresetProp,
    id: { type: String, default: "" },
    name: { type: String, default: "" },
    modelValue: {
      type: [Number, Boolean, Array, String, Object],
      default: false
    },
    trueLabel: { type: String, default: null },
    falseLabel: { type: String, default: null },
    trueInnerLabel: { type: String, default: null },
    falseInnerLabel: { type: String, default: null },
    ariaLabel: { type: String, default: "$t:switch" },
    color: { type: String, default: "primary" },
    offColor: { type: String, default: "background-element" },
    size: {
      type: String,
      default: "medium",
      validator: (value) => ["medium", "small", "large"].includes(value)
    }
  },
  emits: [
    ...useSelectableEmits,
    "focus",
    "blur",
    "update:modelValue"
  ],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const elements = {
      container: shallowRef(),
      input: shallowRef(),
      label: shallowRef()
    };
    const { getColor } = useColors();
    const { hasKeyboardFocus, keyboardFocusListeners } = useKeyboardOnlyFocus();
    const {
      isChecked,
      computedError,
      isIndeterminate,
      computedErrorMessages,
      validationAriaAttributes,
      toggleSelection,
      onBlur,
      onFocus,
      reset,
      focus
    } = useSelectable(props, emit, elements);
    const computedBackground = computed(() => getColor(isChecked.value ? props.color : props.offColor));
    const { textColorComputed } = useTextColor(computedBackground);
    const computedInnerLabel = computed(() => {
      if (props.trueInnerLabel && isChecked.value) {
        return props.trueInnerLabel;
      }
      if (props.falseInnerLabel && !isChecked.value) {
        return props.falseInnerLabel;
      }
      return "";
    });
    const computedLabel = computed(() => {
      if (props.trueLabel && isChecked.value) {
        return props.trueLabel;
      }
      if (props.falseLabel && !isChecked.value) {
        return props.falseLabel;
      }
      return props.label;
    });
    const computedClass = useBem("va-switch", () => ({
      ...pick$1(props, ["readonly", "disabled", "leftLabel"]),
      checked: isChecked.value,
      indeterminate: isIndeterminate.value,
      small: props.size === "small",
      large: props.size === "large",
      error: computedError.value,
      keyboardFocus: hasKeyboardFocus.value
    }));
    const styleComputed = computed(() => ({
      lineHeight: computedErrorMessages.value.length ? 1 : 0
    }));
    const progressCircleSize = computed(() => {
      const size2 = { small: "15px", medium: "20px", large: "25px" };
      return size2[props.size];
    });
    const trackStyle = computed(() => ({
      borderColor: computedError.value ? getColor("danger") : "",
      backgroundColor: computedBackground.value
    }));
    const labelStyle = computed(() => ({
      color: computedError.value ? getColor("danger") : ""
    }));
    const trackLabelStyle = computed(() => ({
      color: textColorComputed.value,
      "text-align": isChecked.value ? "left" : "right"
    }));
    const slots = useSlots();
    const ariaLabelIdComputed = computed(() => `aria-label-id-${generateUniqueId()}`);
    const inputAttributesComputed = computed(() => ({
      id: props.id || void 0,
      name: props.name || void 0,
      disabled: props.disabled,
      readonly: props.readonly,
      "aria-disabled": props.disabled,
      "aria-readonly": props.readonly,
      "aria-checked": !!props.modelValue,
      "aria-label": !slots.default ? props.ariaLabel : void 0,
      "aria-labelledby": computedLabel.value || slots.default ? ariaLabelIdComputed.value : void 0,
      tabindex: props.disabled ? -1 : 0,
      checked: isChecked.value,
      ...validationAriaAttributes.value
    }));
    const onEnterKeyPress = () => {
      var _a2;
      (_a2 = elements.input.value) == null ? void 0 : _a2.click();
    };
    const input = elements.input;
    __expose({
      focus,
      reset
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(VaMessageListWrapper), {
        class: normalizeClass(["va-switch", unref(computedClass)]),
        style: normalizeStyle(styleComputed.value),
        disabled: _ctx.$props.disabled,
        success: _ctx.$props.success,
        messages: _ctx.$props.messages,
        error: unref(computedError),
        "error-messages": unref(computedErrorMessages),
        "error-count": _ctx.$props.errorCount
      }, {
        default: withCtx(() => [
          createBaseVNode("div", {
            ref: "container",
            class: "va-switch__container",
            tabindex: "-1",
            onBlur: _cache[6] || (_cache[6] = //@ts-ignore
            (...args) => unref(onBlur) && unref(onBlur)(...args))
          }, [
            createBaseVNode("div", _hoisted_146, [
              createBaseVNode("input", mergeProps({
                ref_key: "input",
                ref: input,
                type: "checkbox",
                class: "va-switch__input",
                role: "switch"
              }, inputAttributesComputed.value, toHandlers(unref(keyboardFocusListeners), true), {
                onFocus: _cache[0] || (_cache[0] = //@ts-ignore
                (...args) => unref(onFocus) && unref(onFocus)(...args)),
                onBlur: _cache[1] || (_cache[1] = //@ts-ignore
                (...args) => unref(onBlur) && unref(onBlur)(...args)),
                onKeypress: withKeys(onEnterKeyPress, ["enter"]),
                onChange: _cache[2] || (_cache[2] = //@ts-ignore
                (...args) => unref(toggleSelection) && unref(toggleSelection)(...args))
              }), null, 16),
              createBaseVNode("div", {
                class: "va-switch__track",
                "aria-hidden": "true",
                style: normalizeStyle(trackStyle.value)
              }, [
                computedInnerLabel.value || _ctx.$slots.innerLabel ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  class: "va-switch__track-label",
                  style: normalizeStyle(trackLabelStyle.value)
                }, [
                  renderSlot(_ctx.$slots, "innerLabel", {}, () => [
                    createTextVNode(toDisplayString(computedInnerLabel.value), 1)
                  ])
                ], 4)) : createCommentVNode("", true),
                createBaseVNode("div", _hoisted_223, [
                  createBaseVNode("div", _hoisted_315, [
                    renderSlot(_ctx.$slots, "checker", normalizeProps(guardReactiveProps({ value: unref(isChecked) })), () => [
                      createBaseVNode("div", _hoisted_48, [
                        _ctx.$props.loading ? (openBlock(), createBlock(unref(VaProgressCircle), {
                          key: 0,
                          indeterminate: "",
                          size: progressCircleSize.value,
                          color: trackStyle.value.backgroundColor
                        }, null, 8, ["size", "color"])) : createCommentVNode("", true)
                      ])
                    ])
                  ])
                ])
              ], 4)
            ]),
            computedLabel.value || _ctx.$slots.default ? (openBlock(), createElementBlock("div", {
              key: 0,
              ref: "label",
              class: "va-switch__label",
              style: normalizeStyle(labelStyle.value),
              id: ariaLabelIdComputed.value,
              onBlur: _cache[3] || (_cache[3] = //@ts-ignore
              (...args) => unref(onBlur) && unref(onBlur)(...args)),
              onClick: _cache[4] || (_cache[4] = //@ts-ignore
              (...args) => unref(toggleSelection) && unref(toggleSelection)(...args)),
              onKeydown: _cache[5] || (_cache[5] = withKeys(withModifiers(
                //@ts-ignore
                (...args) => unref(toggleSelection) && unref(toggleSelection)(...args),
                ["stop"]
              ), ["enter"]))
            }, [
              renderSlot(_ctx.$slots, "default", {}, () => [
                createTextVNode(toDisplayString(computedLabel.value), 1)
              ])
            ], 44, _hoisted_57)) : createCommentVNode("", true)
          ], 544)
        ]),
        _: 3
      }, 8, ["class", "style", "disabled", "success", "messages", "error", "error-messages", "error-count"]);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-switch/VaSwitch.js
var _style_074 = ':root,\n:host {\n  --va-switch-display: inline-block;\n  /* Checker */\n  --va-switch-checker-margin: auto;\n  --va-switch-checker-transform: translateX(0.3rem);\n  --va-switch-checker-height: 1.5rem;\n  --va-switch-checker-width: 1.5rem;\n  --va-switch-checker-active-background-color: #ffffff;\n  --va-switch-checker-background-color: var(--va-secondary);\n  --va-switch-checker-border-radius: 50%;\n  --va-switch-checker-box-shadow: 0 0 0 var(--va-background-border);\n  --va-switch-checker-transition: all 0.2s ease;\n  /* Checker Wrapper */\n  --va-switch-checker-wrapper-transform: translateX(0);\n  --va-switch-checker-wrapper-top: 0;\n  --va-switch-checker-wrapper-left: 0;\n  --va-switch-checker-wrapper-bottom: 0;\n  --va-switch-checker-wrapper-right: 0;\n  --va-switch-checker-wrapper-width: 100%;\n  --va-switch-checker-wrapper-height: 100%;\n  --va-switch-checker-wrapper-transition: all 0.2s ease;\n  --va-switch-checker-wrapper-pointer-events: none;\n  /* Label */\n  --va-switch-label-left-padding: 0.3rem;\n  --va-switch-label-right-padding: 0.3rem;\n  /* Track */\n  --va-switch-track-border-radius: 1rem;\n  --va-switch-track-height: 100%;\n  --va-switch-track-width: 100%;\n  --va-switch-track-background: var(--va-background-element);\n  --va-switch-track-box-shadow: inset 0 0 0 var(--va-shadow);\n  --va-switch-track-transition: background-color 0.2s ease;\n  /* Inner */\n  --va-switch-inner-cursor: pointer;\n  --va-switch-inner-height: 2rem;\n  --va-switch-inner-width: auto;\n  --va-switch-inner-min-width: 4rem;\n  --va-switch-inner-border-radius: 1rem;\n  /* Small */\n  --va-switch-sm-inner-height: 1.5rem;\n  --va-switch-sm-inner-width: auto;\n  --va-switch-sm-inner-min-width: 3rem;\n  /* Large */\n  --va-switch-lg-inner-height: 2.5rem;\n  --va-switch-lg-inner-width: auto;\n  --va-switch-lg-inner-min-width: 5rem;\n}\n.va-switch {\n  line-height: 0;\n  display: var(--va-switch-display);\n}\n.va-switch__container {\n  display: inline-flex;\n  align-items: center;\n  width: 100%;\n}\n.va-switch:focus {\n  outline: none;\n}\n.va-switch__inner {\n  cursor: var(--va-switch-inner-cursor);\n  display: inline-block;\n  position: relative;\n  height: var(--va-switch-inner-height);\n  width: var(--va-switch-inner-width);\n  min-width: var(--va-switch-inner-min-width);\n  border-radius: var(--va-switch-inner-border-radius);\n}\n.va-switch__inner:focus {\n  outline: 0;\n  box-shadow: 0 0 0 0.3rem rgba(52, 144, 220, 0.5);\n}\n.va-switch--small .va-switch__inner {\n  height: var(--va-switch-sm-inner-height);\n  width: var(--va-switch-sm-inner-width);\n  min-width: var(--va-switch-sm-inner-min-width);\n}\n.va-switch--small .va-switch__checker-circle {\n  height: 1.1rem;\n  width: 1.1rem;\n}\n.va-switch--large .va-switch__inner {\n  height: var(--va-switch-lg-inner-height);\n  width: var(--va-switch-lg-inner-width);\n  min-width: var(--va-switch-lg-inner-min-width);\n}\n.va-switch--large .va-switch__checker-circle {\n  height: 1.8rem;\n  width: 1.8rem;\n}\n.va-switch--disabled {\n  cursor: default;\n  opacity: 0.4;\n  pointer-events: none;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n          user-select: none;\n}\n.va-switch--readonly {\n  cursor: default;\n  pointer-events: none;\n}\n.va-switch--readonly .va-switch__label {\n  cursor: initial;\n  pointer-events: auto;\n}\n.va-switch--left-label .va-switch__container {\n  flex-direction: row-reverse;\n}\n.va-switch--left-label .va-switch__label {\n  padding: 0 var(--va-switch-label-left-padding) 0 0;\n}\n.va-switch--indeterminate .va-switch__checker {\n  margin: auto 0;\n  transform: translateX(-50%);\n}\n.va-switch--indeterminate .va-switch__checker-wrapper {\n  transform: translateX(50%);\n}\n.va-switch--checked .va-switch__checker {\n  transform: translateX(calc(-100% - 0.3rem));\n}\n.va-switch--checked .va-switch__checker-circle {\n  background-color: var(--va-switch-checker-active-background-color);\n}\n.va-switch--checked .va-switch__checker-wrapper {\n  transform: translateX(100%);\n}\n.va-switch--error .va-switch__track {\n  border: 0.1rem solid;\n}\n.va-switch__label {\n  cursor: pointer;\n  text-align: left;\n  padding: 0 0 0 var(--va-switch-label-right-padding);\n}\n.va-switch .va-switch__track {\n  display: flex;\n  overflow: hidden;\n  border-radius: var(--va-switch-track-border-radius);\n  height: var(--va-switch-track-height);\n  width: var(--va-switch-track-width);\n  background: var(--va-switch-track-background);\n  box-shadow: var(--va-switch-track-box-shadow);\n  transition: var(--va-switch-track-transition);\n}\n.va-switch--keyboard-focus.va-switch .va-switch__track {\n  outline: 2px solid var(--va-focus) !important;\n  border-radius: "inherit";\n}\n.va-switch--small.va-switch .va-switch__track {\n  border-radius: 0.75rem;\n}\n.va-switch--large.va-switch .va-switch__track {\n  border-radius: 1.25rem;\n}\n.va-switch .va-switch__track-label {\n  color: #ffffff;\n  margin: auto 0.5rem auto 2rem;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n          user-select: none;\n  width: 100%;\n}\n.va-switch--checked.va-switch .va-switch__track-label {\n  margin: auto 2rem auto 0.5rem;\n}\n.va-switch--small.va-switch .va-switch__track-label {\n  margin: auto 0.5rem auto 1.55rem;\n}\n.va-switch--checked.va-switch--small.va-switch .va-switch__track-label {\n  margin: auto 1.55rem auto 0.5rem;\n}\n.va-switch--large.va-switch .va-switch__track-label {\n  margin: auto 0.5rem auto 2.3rem;\n}\n.va-switch--checked.va-switch--large.va-switch .va-switch__track-label {\n  margin: auto 2.3rem auto 0.5rem;\n}\n.va-switch__checker {\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  margin: var(--va-switch-checker-margin);\n  transform: var(--va-switch-checker-transform);\n  box-shadow: var(--va-switch-checker-box-shadow);\n  transition: var(--va-switch-checker-transition);\n  display: flex;\n  justify-content: center;\n  align-items: center;\n}\n.va-switch__checker-circle {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  height: var(--va-switch-checker-height);\n  width: var(--va-switch-checker-width);\n  background-color: var(--va-switch-checker-background-color);\n  border-radius: var(--va-switch-checker-border-radius);\n}\n.va-switch__checker-wrapper {\n  position: absolute;\n  margin: auto;\n  transform: var(--va-switch-checker-wrapper-transform);\n  top: var(--va-switch-checker-wrapper-top);\n  left: var(--va-switch-checker-wrapper-left);\n  bottom: var(--va-switch-checker-wrapper-bottom);\n  right: var(--va-switch-checker-wrapper-right);\n  width: var(--va-switch-checker-wrapper-width);\n  height: var(--va-switch-checker-wrapper-height);\n  transition: var(--va-switch-checker-wrapper-transition);\n  pointer-events: var(--va-switch-checker-wrapper-pointer-events);\n}\n.va-switch__input {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  margin: 0;\n  opacity: 0;\n  cursor: inherit;\n}';
var _VaSwitch = _export_sfc(_sfc_main79, [["styles", [_style_074]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-switch/index.js
var VaSwitch = withConfigTransport$1(_VaSwitch);

// node_modules/vuestic-ui/dist/web-components/src/composables/useArrayRefs.js
var useArrayRefs = () => {
  const itemRefs = shallowRef([]);
  const setItemRef = (el) => {
    if (!el) {
      return;
    }
    itemRefs.value.push(el);
  };
  const setItemRefByIndex = (index) => (el) => {
    if (!el) {
      return;
    }
    itemRefs.value[index] = el;
  };
  onBeforeUpdate(() => {
    itemRefs.value = [];
  });
  return {
    itemRefs,
    setItemRef,
    setItemRefByIndex
  };
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-option-list/VaOptionList.vue_vue_type_script_setup_true_lang.js
var _hoisted_147 = { class: "va-option-list__list" };
var _sfc_main80 = defineComponent({
  ...{
    name: "VaOptionList"
  },
  __name: "VaOptionList",
  props: {
    ...useComponentPresetProp,
    ...useSelectableListProps,
    ...useValidationProps,
    ...useStatefulProps,
    type: {
      type: String,
      default: "checkbox",
      validator: (type) => ["radio", "checkbox", "switch"].includes(type)
    },
    disabled: { type: Boolean, default: false },
    readonly: { type: Boolean, default: false },
    defaultValue: { type: [String, Number, Boolean, Object, Array] },
    name: { type: String, default: "" },
    color: { type: String, default: "primary" },
    leftLabel: { type: Boolean, default: false },
    modelValue: { type: [String, Number, Boolean, Object, Array] }
  },
  emits: [...useStatefulEmits, ...useValidationEmits, "clear"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const { valueComputed } = useStateful(props, emit, "modelValue", { defaultValue: props.defaultValue });
    const { getValue: getValue2, getText, getTrackBy, getDisabled } = useSelectableList(props);
    const { itemRefs, setItemRef } = useArrayRefs();
    const isRadio = computed(() => props.type === "radio");
    const selectedValue = computed({
      get() {
        const value = isRadio.value ? null : [];
        return valueComputed.value || value;
      },
      set(value) {
        if (props.readonly) {
          return;
        }
        if (isRadio.value && !Array.isArray(value)) {
          valueComputed.value = value ? getValue2(value) : value;
        } else {
          valueComputed.value = Array.isArray(value) ? value.map(getValue2) : [value ? getValue2(value) : value];
        }
      }
    });
    const isDisabled = (option) => props.disabled || getDisabled(option);
    const reset = () => withoutValidation(() => {
      valueComputed.value = null;
      emit("clear");
      resetValidation();
    });
    const focus = () => {
      const firstActiveEl = Array.isArray(itemRefs.value) && itemRefs.value.find((el) => !el.disabled);
      if (firstActiveEl && typeof firstActiveEl.focus === "function") {
        firstActiveEl.focus();
      }
    };
    const {
      computedError,
      computedErrorMessages,
      withoutValidation,
      resetValidation
    } = useValidation(props, emit, { reset, focus, value: valueComputed });
    const computedProps = computed(() => pick$1(props, ["name", "color", "readonly", "leftLabel"]));
    onMounted(() => {
      if (isDev && props.type !== "radio" && !Array.isArray(props.modelValue)) {
        console.warn(`Prop 'modelValue = ${props.modelValue}' has not a proper type!
 For component property 'type = ${props.type}' it must be of type 'array'.`);
      }
    });
    __expose({
      focus,
      reset
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(VaMessageListWrapper), {
        error: unref(computedError),
        "error-messages": unref(computedErrorMessages),
        "error-count": _ctx.$props.errorCount
      }, {
        default: withCtx(() => [
          createBaseVNode("ul", _hoisted_147, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.$props.options, (option) => {
              return openBlock(), createElementBlock("li", {
                key: unref(getTrackBy)(option)
              }, [
                renderSlot(_ctx.$slots, "default", normalizeProps(guardReactiveProps({ option, selectedValue: selectedValue.value, isDisabled, getText: unref(getText), getValue: unref(getValue2) })), () => [
                  _ctx.$props.type === "radio" ? (openBlock(), createBlock(unref(VaRadio), mergeProps({
                    key: 0,
                    ref_for: true,
                    ref: unref(setItemRef),
                    modelValue: selectedValue.value,
                    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => selectedValue.value = $event),
                    label: unref(getText)(option),
                    disabled: isDisabled(option),
                    option: unref(getValue2)(option)
                  }, computedProps.value), null, 16, ["modelValue", "label", "disabled", "option"])) : _ctx.$props.type === "checkbox" ? (openBlock(), createBlock(unref(VaCheckbox), mergeProps({
                    key: 1,
                    ref_for: true,
                    ref: unref(setItemRef),
                    modelValue: selectedValue.value,
                    "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => selectedValue.value = $event),
                    label: unref(getText)(option),
                    disabled: isDisabled(option),
                    "array-value": unref(getValue2)(option)
                  }, computedProps.value), null, 16, ["modelValue", "label", "disabled", "array-value"])) : (openBlock(), createBlock(unref(VaSwitch), mergeProps({
                    key: 2,
                    ref_for: true,
                    ref: unref(setItemRef),
                    modelValue: selectedValue.value,
                    "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => selectedValue.value = $event),
                    label: unref(getText)(option),
                    disabled: isDisabled(option),
                    "array-value": unref(getValue2)(option)
                  }, computedProps.value), null, 16, ["modelValue", "label", "disabled", "array-value"]))
                ])
              ]);
            }), 128))
          ])
        ]),
        _: 3
      }, 8, ["error", "error-messages", "error-count"]);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-option-list/VaOptionList.js
var _style_075 = ":root,\n:host {\n  --va-option-list-line-height: 1.5;\n}\n.va-option-list__list {\n  line-height: var(--va-option-list-line-height);\n  margin: 0;\n  padding: 0;\n  list-style: none;\n  vertical-align: baseline;\n}";
var _VaOptionList = _export_sfc(_sfc_main80, [["styles", [_style_075]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-option-list/index.js
var VaOptionList = withConfigTransport$1(_VaOptionList);

// node_modules/vuestic-ui/dist/web-components/src/components/va-pagination/setPaginationRange.js
var setPaginationRange = (currentPage = 1, visiblePages, pages, includeBoundary = false) => {
  let start = 0;
  if (pages === 0) {
    pages = 1;
  }
  if (visiblePages > pages) {
    visiblePages = pages;
  }
  if (visiblePages === 0) {
    start = 1;
    visiblePages = pages > 10 ? 10 : pages;
  } else {
    const paginationMiddlePage = visiblePages / 2;
    if (currentPage - paginationMiddlePage <= 0 || currentPage > pages) {
      start = 1;
    } else {
      start = currentPage + paginationMiddlePage > pages ? pages - visiblePages + 1 : Math.ceil(currentPage - paginationMiddlePage);
    }
  }
  const range = [];
  for (let i = 0; i < visiblePages; i++) {
    range.push(start + i);
  }
  if (includeBoundary && visiblePages < 7) {
    pages >= 7 && warn(
      "[va-pagination] To work in a proper way, the `boundaryNumbers` prop needs at least 7 visible pages to be set via the `visiblePages` prop (first, last, 2 boundaries, current, previous, next)."
    );
  } else if (includeBoundary) {
    start !== 1 && range.splice(0, 2, 1, "...");
    range[range.length - 1] !== pages && range.splice(-2, 2, "...", pages);
  }
  return range;
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-pagination/VaPagination.vue_vue_type_script_setup_true_lang.js
var _hoisted_148 = ["aria-label", "onKeydown"];
var _hoisted_224 = ["aria-label"];
var _sfc_main81 = defineComponent({
  ...{
    name: "VaPagination"
  },
  __name: "VaPagination",
  props: {
    ...useStatefulProps,
    ...useComponentPresetProp,
    modelValue: { type: Number, default: 1 },
    visiblePages: { type: Number, default: 0 },
    pages: { type: Number, default: 0 },
    disabled: { type: Boolean, default: false },
    color: { type: String, default: "primary" },
    size: {
      type: String,
      default: "medium",
      validator: (v) => ["small", "medium", "large"].includes(v)
    },
    boundaryLinks: { type: Boolean, default: true },
    boundaryNumbers: { type: Boolean, default: false },
    directionLinks: { type: Boolean, default: true },
    input: { type: Boolean, default: false },
    hideOnSinglePage: { type: Boolean, default: false },
    total: { type: Number, default: null },
    pageSize: { type: Number, default: null },
    boundaryIconLeft: { type: String, default: "va-arrow-first" },
    boundaryIconRight: { type: String, default: "va-arrow-last" },
    directionIconLeft: { type: String, default: "va-arrow-left" },
    directionIconRight: { type: String, default: "va-arrow-right" },
    gapped: { type: Boolean, default: false },
    borderColor: { type: String, default: "" },
    rounded: { type: Boolean, default: false },
    /** @deprecated Use activeButtonProps="{ color: 'myColor' }" */
    activePageColor: { type: String, default: "" },
    activeButtonProps: { type: Object, default: () => ({}) },
    buttonProps: { type: Object, default: () => ({}) },
    buttonsPreset: { type: String, default: "primary" },
    ariaLabel: { type: String, default: "$t:pagination" },
    ariaGoToTheFirstPageLabel: { type: String, default: "$t:goToTheFirstPage" },
    ariaGoToPreviousPageLabel: { type: String, default: "$t:goToPreviousPage" },
    ariaGoToSpecificPageLabel: { type: String, default: "$t:goToSpecificPage" },
    ariaGoToSpecificPageInputLabel: { type: String, default: "$t:goToSpecificPageInput" },
    ariaGoToNextPageLabel: { type: String, default: "$t:goNextPage" },
    ariaGoToLastPageLabel: { type: String, default: "$t:goLastPage" }
  },
  emits: [...useStatefulEmits],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const htmlInput = shallowRef();
    const inputValue = ref("");
    const usesTotal = computed(() => !!((props.total || props.total === 0) && props.pageSize));
    const { valueComputed } = useStateful(props, emit);
    const currentValue = computed({
      get: () => usesTotal.value ? Math.ceil(valueComputed.value / props.pageSize) || 1 : valueComputed.value,
      set: (value) => {
        valueComputed.value = value;
      }
    });
    const paginationRange = computed(() => {
      const { visiblePages, total, pageSize, boundaryNumbers, pages } = props;
      const value = currentValue.value || 1;
      const totalPages = usesTotal.value ? Math.ceil(total / pageSize) : pages;
      return setPaginationRange(value, visiblePages, totalPages, boundaryNumbers);
    });
    const lastPage = computed(() => usesTotal.value ? Math.ceil(props.total / props.pageSize) || 1 : +props.pages);
    const isLastPageNotVisible = computed(() => !!props.visiblePages && lastPage.value > props.visiblePages || props.input);
    const showBoundaryLinks = computed(() => {
      const { boundaryLinks, boundaryNumbers } = props;
      return isLastPageNotVisible.value && boundaryLinks && !boundaryNumbers;
    });
    const showDirectionLinks = computed(() => isLastPageNotVisible.value && props.directionLinks);
    const showPagination = computed(() => lastPage.value > 1 || !props.hideOnSinglePage && lastPage.value <= 1);
    const focusInput = () => {
      inputValue.value = String(currentValue.value);
      nextTick(() => {
        var _a2;
        return (_a2 = htmlInput.value) == null ? void 0 : _a2.setSelectionRange(0, htmlInput.value.value.length);
      });
    };
    const { setItemRefByIndex, itemRefs } = useArrayRefs();
    const onUserInput = (pageNum) => {
      var _a2;
      if (pageNum === "..." || pageNum === currentValue.value) {
        return;
      }
      const limitedPageNum = clamp$1(pageNum, 1, lastPage.value);
      currentValue.value = usesTotal.value ? (limitedPageNum - 1) * props.pageSize + 1 : limitedPageNum;
      (_a2 = itemRefs.value[pageNum - 1]) == null ? void 0 : _a2.focus();
    };
    const resetInput = () => {
      var _a2;
      inputValue.value = "";
      (_a2 = htmlInput.value) == null ? void 0 : _a2.blur();
    };
    const changeValue = () => {
      if (+inputValue.value === currentValue.value) {
        resetInput();
      }
      if (!inputValue.value.length) {
        return;
      }
      let pageNum = Number.parseInt(inputValue.value);
      switch (true) {
        case pageNum < 1:
          pageNum = 1;
          break;
        case pageNum > lastPage.value:
          pageNum = lastPage.value;
          break;
        case isNaN(pageNum):
          pageNum = currentValue.value;
          break;
      }
      onUserInput(pageNum);
      resetInput();
    };
    const { getColor, colorToRgba: colorToRgba2 } = useColors();
    const inputBorderColorComputed = computed(() => {
      const { color, buttonsPreset } = toRefs(props);
      if (!color.value) {
        return "transparent";
      }
      switch (buttonsPreset.value) {
        case "default":
          return getColor(color.value);
        case void 0:
        case "primary":
          return colorToRgba2(getColor(color.value), 0.1);
        default:
          return "transparent";
      }
    });
    const inputStyleComputed = computed(() => ({
      cursor: "default",
      color: getColor(props.color),
      opacity: props.disabled ? 0.4 : 1,
      borderColor: inputBorderColorComputed.value
    }));
    watch([usesTotal, () => props.pages], () => {
      if (isDev && usesTotal.value && props.pages) {
        throw new Error("Please, use either `total` and `page-size` props, or `pages`.");
      }
    });
    const inputAttributesComputed = computed(() => ({
      disabled: props.disabled,
      placeholder: `${currentValue.value}/${lastPage.value}`
    }));
    const buttonPropsComputed = computed(() => ({
      size: props.size,
      preset: props.buttonsPreset,
      color: props.color,
      borderColor: props.borderColor,
      round: props.rounded,
      ...props.buttonProps
    }));
    const currentPageButtonProps = computed(() => ({
      preset: props.buttonsPreset === "default" ? "primary" : "default",
      color: props.activePageColor || props.color,
      ...props.activeButtonProps
    }));
    const getPageButtonProps = (n) => {
      if (!isNaN(+n) && n === currentValue.value) {
        return Object.assign({}, buttonPropsComputed.value, currentPageButtonProps.value);
      }
      return buttonPropsComputed.value;
    };
    const isStandAloneInput = computed(() => props.input && !props.boundaryLinks && !props.directionLinks);
    const inputClassComputed = useBem("va-pagination__input", () => ({
      sm: props.size === "small" && isStandAloneInput.value,
      md: props.size === "medium" && isStandAloneInput.value,
      lg: props.size === "large" && isStandAloneInput.value,
      auto: !isStandAloneInput.value
    }));
    const classComputed = useBem("va-pagination", () => ({
      ...pick$1(props, ["gapped", "rounded", "disabled"]),
      bordered: !!props.borderColor
    }));
    const goNextPage = () => onUserInput(currentValue.value + 1);
    const goPrevPage = () => onUserInput(currentValue.value - 1);
    const { tp } = useTranslation();
    __expose({
      goNextPage,
      goPrevPage
    });
    return (_ctx, _cache) => {
      return showPagination.value ? (openBlock(), createElementBlock("nav", {
        key: 0,
        class: normalizeClass(["va-pagination", unref(classComputed)]),
        "aria-label": unref(tp)(_ctx.$props.ariaLabel),
        onKeydown: [
          withKeys(withModifiers(goPrevPage, ["stop"]), ["left"]),
          withKeys(withModifiers(goNextPage, ["stop"]), ["right"]),
          withKeys(withModifiers(goPrevPage, ["stop"]), ["up"]),
          withKeys(withModifiers(goNextPage, ["stop"]), ["down"])
        ]
      }, [
        showBoundaryLinks.value ? renderSlot(_ctx.$slots, "firstPageLink", normalizeProps(mergeProps({ key: 0 }, { onClick: () => onUserInput(1), disabled: _ctx.$props.disabled || currentValue.value === 1 })), () => [
          showBoundaryLinks.value ? (openBlock(), createBlock(unref(VaButton), mergeProps({
            key: 0,
            "aria-label": unref(tp)(_ctx.$props.ariaGoToTheFirstPageLabel),
            disabled: _ctx.$props.disabled || currentValue.value === 1,
            icon: _ctx.$props.boundaryIconLeft
          }, buttonPropsComputed.value, {
            onClick: _cache[0] || (_cache[0] = ($event) => onUserInput(1))
          }), null, 16, ["aria-label", "disabled", "icon"])) : createCommentVNode("", true)
        ]) : createCommentVNode("", true),
        showDirectionLinks.value ? renderSlot(_ctx.$slots, "prevPageLink", normalizeProps(mergeProps({ key: 1 }, { onClick: goPrevPage, disabled: _ctx.$props.disabled || currentValue.value === 1 })), () => [
          showDirectionLinks.value ? (openBlock(), createBlock(unref(VaButton), mergeProps({
            key: 0,
            "aria-label": unref(tp)(_ctx.$props.ariaGoToPreviousPageLabel),
            disabled: _ctx.$props.disabled || currentValue.value === 1,
            icon: _ctx.$props.directionIconLeft
          }, buttonPropsComputed.value, { onClick: goPrevPage }), null, 16, ["aria-label", "disabled", "icon"])) : createCommentVNode("", true)
        ]) : createCommentVNode("", true),
        !_ctx.$props.input ? renderSlot(_ctx.$slots, "default", { key: 2 }, () => [
          (openBlock(true), createElementBlock(Fragment, null, renderList(paginationRange.value, (n, i) => {
            return openBlock(), createBlock(unref(VaButton), mergeProps({
              key: i,
              ref_for: true,
              ref: unref(setItemRefByIndex)(i),
              class: { "va-button--ellipsis": n === "...", "va-button--current": n === currentValue.value },
              "aria-label": unref(tp)(_ctx.$props.ariaGoToSpecificPageLabel, { page: n }),
              "aria-current": n === currentValue.value,
              disabled: _ctx.$props.disabled || n === "..."
            }, getPageButtonProps(n), {
              onClick: ($event) => onUserInput(n)
            }), {
              default: withCtx(() => [
                createTextVNode(toDisplayString(n), 1)
              ]),
              _: 2
            }, 1040, ["class", "aria-label", "aria-current", "disabled", "onClick"]);
          }), 128))
        ]) : withDirectives((openBlock(), createElementBlock("input", mergeProps({
          key: 3,
          "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => inputValue.value = $event),
          ref_key: "htmlInput",
          ref: htmlInput,
          class: ["va-pagination__input va-button", unref(inputClassComputed)],
          "aria-label": unref(tp)(_ctx.$props.ariaGoToSpecificPageInputLabel),
          style: inputStyleComputed.value
        }, inputAttributesComputed.value, {
          onKeydown: withKeys(changeValue, ["enter"]),
          onFocus: focusInput,
          onBlur: changeValue
        }), null, 16, _hoisted_224)), [
          [vModelDynamic, inputValue.value]
        ]),
        showDirectionLinks.value ? renderSlot(_ctx.$slots, "nextPageLink", normalizeProps(mergeProps({ key: 4 }, { onClick: goNextPage, disabled: _ctx.$props.disabled || currentValue.value === lastPage.value })), () => [
          showDirectionLinks.value ? (openBlock(), createBlock(unref(VaButton), mergeProps({
            key: 0,
            "aria-label": unref(tp)(_ctx.$props.ariaGoToNextPageLabel),
            disabled: _ctx.$props.disabled || currentValue.value === lastPage.value,
            icon: _ctx.$props.directionIconRight
          }, buttonPropsComputed.value, { onClick: goNextPage }), null, 16, ["aria-label", "disabled", "icon"])) : createCommentVNode("", true)
        ]) : createCommentVNode("", true),
        showBoundaryLinks.value ? renderSlot(_ctx.$slots, "lastPageLink", normalizeProps(mergeProps({ key: 5 }, { onClick: () => onUserInput(lastPage.value), disabled: _ctx.$props.disabled || currentValue.value === lastPage.value })), () => [
          showBoundaryLinks.value ? (openBlock(), createBlock(unref(VaButton), mergeProps({
            key: 0,
            "aria-label": unref(tp)(_ctx.$props.ariaGoToLastPageLabel),
            disabled: _ctx.$props.disabled || currentValue.value === lastPage.value,
            icon: _ctx.$props.boundaryIconRight
          }, buttonPropsComputed.value, {
            onClick: _cache[2] || (_cache[2] = ($event) => onUserInput(lastPage.value))
          }), null, 16, ["aria-label", "disabled", "icon"])) : createCommentVNode("", true)
        ]) : createCommentVNode("", true)
      ], 42, _hoisted_148)) : createCommentVNode("", true);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-pagination/VaPagination.js
var _style_076 = ':root,\n:host {\n  --va-pagination-gap: 0.5rem;\n  --va-pagination-input-background: var(--va-background-primary);\n  --va-pagination-input-border-style: solid;\n  --va-pagination-input-border-width: 1px 0;\n  --va-pagination-input-text-align: center;\n  --va-pagination-input-font-size: 1rem;\n  --va-pagination-button-content-width: 0.5rem;\n  --va-pagination-button-sm-size: var(--va-button-sm-size);\n  --va-pagination-button-size: var(--va-button-size);\n  --va-pagination-button-lg-size: var(--va-button-lg-ze);\n}\n.va-pagination {\n  display: flex;\n  font-family: var(--va-font-family);\n}\n.va-pagination__input {\n  background: var(--va-pagination-input-background);\n  border-style: var(--va-pagination-input-border-style);\n  border-width: var(--va-pagination-input-border-width);\n  text-align: var(--va-pagination-input-text-align);\n  font-size: var(--va-pagination-input-font-size);\n  font-weight: normal;\n}\n.va-pagination__input--sm {\n  height: var(--va-pagination-button-sm-size);\n}\n.va-pagination__input--md {\n  height: var(--va-pagination-button-size);\n}\n.va-pagination__input--lg {\n  height: var(--va-pagination-button-lg-size);\n}\n.va-pagination__input--auto {\n  height: auto;\n}\n.va-pagination .va-button.va-input {\n  cursor: default;\n}\n.va-pagination .va-button--small {\n  height: var(--va-pagination-button-sm-size);\n  min-width: var(--va-pagination-button-sm-size);\n}\n.va-pagination .va-button--normal {\n  height: var(--va-pagination-button-size);\n  min-width: var(--va-pagination-button-size);\n}\n.va-pagination .va-button--large {\n  height: var(--va-pagination-button-lg-size);\n  min-width: var(--va-pagination-button-lg-size);\n}\n.va-pagination .va-button--ellipsis {\n  cursor: default;\n  opacity: 1;\n}\n.va-pagination .va-button--ellipsis > .va-button__content {\n  opacity: 0.4;\n}\n.va-pagination .va-button:focus-visible {\n  outline-offset: -2px;\n}\n.va-pagination .va-button:focus-visible:focus-visible {\n  outline: 2px solid var(--va-focus) !important;\n  border-radius: "inherit";\n}\n.va-pagination > :not(:first-child):not(:last-child) {\n  border-radius: 0;\n}\n.va-pagination > :first-child {\n  border-top-right-radius: 0;\n  border-bottom-right-radius: 0;\n}\n.va-pagination > :last-child {\n  border-top-left-radius: 0;\n  border-bottom-left-radius: 0;\n}\n.va-pagination--gapped.va-pagination > .va-button {\n  border-radius: var(--va-button-border-radius);\n  margin-right: var(--va-pagination-gap);\n  border-style: solid;\n}\n.va-pagination--gapped.va-pagination > .va-button:last-child {\n  margin-right: 0;\n}\n.va-pagination--bordered.va-pagination > .va-button {\n  border-style: solid;\n}\n.va-pagination--bordered.va-pagination > .va-button::before {\n  border-radius: unset;\n}\n.va-pagination--rounded.va-pagination > .va-button {\n  border-radius: 50%;\n}\n.va-pagination--rounded.va-pagination > .va-button::before {\n  border-radius: inherit;\n}\n.va-pagination--rounded.va-pagination > .va-button.va-button--small.va-button--icon-only {\n  height: var(--va-pagination-button-sm-size);\n  width: var(--va-pagination-button-sm-size);\n}\n.va-pagination--rounded.va-pagination > .va-button.va-button--small .va-button__content {\n  padding-right: var(--va-button-sm-content-px);\n  padding-left: var(--va-button-sm-content-px);\n}\n.va-pagination--rounded.va-pagination > .va-button.va-button--normal.va-button--icon-only {\n  height: var(--va-pagination-button-size);\n  width: var(--va-pagination-button-size);\n}\n.va-pagination--rounded.va-pagination > .va-button.va-button--normal .va-button__content {\n  padding-right: var(--va-button-content-px);\n  padding-left: var(--va-button-content-px);\n}\n.va-pagination--rounded.va-pagination > .va-button.va-button--large.va-button--icon-only {\n  height: var(--va-pagination-button-lg-size);\n  width: var(--va-pagination-button-lg-size);\n}\n.va-pagination--rounded.va-pagination > .va-button.va-button--large .va-button__content {\n  padding-right: var(--va-button-lg-content-px);\n  padding-left: var(--va-button-lg-content-px);\n}';
var _VaPagination = _export_sfc(_sfc_main81, [["styles", [_style_076]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-pagination/index.js
var VaPagination = withConfigTransport$1(_VaPagination);

// node_modules/vuestic-ui/dist/web-components/src/composables/useScrollParent.js
var useScrollParent = () => {
  const window2 = useWindow();
  const fakeWindow = new Proxy(window2.value || {}, {
    get: (target, key, rec) => {
      var _a2, _b;
      if (key === "scrollTop") {
        return (_a2 = window2.value) == null ? void 0 : _a2.scrollY;
      }
      if (key === "scrollLeft") {
        return (_b = window2.value) == null ? void 0 : _b.scrollX;
      }
      const value = Reflect.get(target, key, rec);
      if (typeof value === "function") {
        return value.bind(target);
      }
      return value;
    }
  });
  const getScrollableParent = (element) => {
    if (!element) {
      return fakeWindow;
    }
    if (element.scrollHeight > element.clientHeight) {
      return element;
    }
    return getScrollableParent(element.parentElement);
  };
  return { getScrollableParent };
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-parallax/VaParallax.vue_vue_type_script_setup_true_lang.js
var _hoisted_149 = { class: "va-parallax__image-container" };
var _hoisted_225 = ["src", "alt"];
var _hoisted_316 = { class: "va-parallax__item-container" };
var _sfc_main82 = defineComponent({
  ...{
    name: "VaParallax"
  },
  __name: "VaParallax",
  props: {
    ...useComponentPresetProp,
    target: { type: [Object, String] },
    src: { type: String, default: "", required: true },
    alt: { type: String, default: "parallax" },
    height: { type: Number, default: 400 },
    reversed: { type: Boolean, default: false },
    speed: {
      type: Number,
      default: 0.5,
      validator: (value) => value >= 0 && value <= 1
    }
  },
  setup(__props) {
    const props = __props;
    const rootElement = shallowRef();
    const img = shallowRef();
    const elOffsetTop = ref(0);
    const parallax = ref(0);
    const parallaxDist = ref(0);
    const percentScrolled = ref(0);
    const scrollTop = ref(0);
    const windowHeight = ref(0);
    const windowBottom = ref(0);
    const isLoaded = ref(false);
    const computedWrapperStyles = computed(() => ({ height: props.height + "px" }));
    const computedImgStyles = computed(() => ({
      display: "block",
      transform: `translate(-50%, ${parallax.value}px)`,
      opacity: isLoaded.value ? 1 : 0,
      top: props.reversed ? 0 : "auto"
    }));
    const { getScrollableParent } = useScrollParent();
    const targetElement = computed(() => {
      var _a2;
      if (!props.target) {
        return getScrollableParent((_a2 = rootElement.value) == null ? void 0 : _a2.parentElement);
      }
      if (props.target instanceof HTMLElement) {
        return props.target;
      }
      const element = document.querySelector(props.target);
      if (element) {
        return element;
      }
      warn("VaParallax target prop got wrong selector. Target is null");
      return null;
    });
    const imgHeight = computed(() => {
      var _a2;
      return ((_a2 = img.value) == null ? void 0 : _a2.naturalHeight) || 0;
    });
    const calcDimensions = () => {
      var _a2, _b;
      const offset2 = ((_a2 = rootElement.value) == null ? void 0 : _a2.getBoundingClientRect()) || { top: 0 };
      scrollTop.value = ((_b = targetElement.value) == null ? void 0 : _b.scrollTop) || 0;
      parallaxDist.value = imgHeight.value - props.height;
      elOffsetTop.value = offset2.top + scrollTop.value;
      windowHeight.value = window.innerHeight;
      windowBottom.value = scrollTop.value + windowHeight.value;
    };
    const translate = () => {
      calcDimensions();
      percentScrolled.value = (windowBottom.value - elOffsetTop.value) / (props.height + windowHeight.value);
      parallax.value = Math.round(parallaxDist.value * percentScrolled.value) * props.speed;
      if (props.reversed) {
        parallax.value = -parallax.value;
      }
    };
    const addEventListeners = () => {
      var _a2, _b;
      (_a2 = targetElement.value) == null ? void 0 : _a2.addEventListener("scroll", translate);
      (_b = targetElement.value) == null ? void 0 : _b.addEventListener("resize", translate);
    };
    const removeEventListeners = () => {
      var _a2, _b;
      (_a2 = targetElement.value) == null ? void 0 : _a2.removeEventListener("scroll", translate);
      (_b = targetElement.value) == null ? void 0 : _b.removeEventListener("resize", translate);
    };
    const initImage = () => {
      var _a2, _b;
      if ((_a2 = img.value) == null ? void 0 : _a2.complete) {
        translate();
        addEventListeners();
      } else {
        (_b = img.value) == null ? void 0 : _b.addEventListener("load", () => {
          translate();
          addEventListeners();
        }, false);
      }
      isLoaded.value = true;
    };
    onMounted(initImage);
    onBeforeUnmount(removeEventListeners);
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        ref_key: "rootElement",
        ref: rootElement,
        class: "va-parallax",
        style: normalizeStyle(computedWrapperStyles.value)
      }, [
        createBaseVNode("div", _hoisted_149, [
          createBaseVNode("img", {
            ref_key: "img",
            ref: img,
            class: "va-parallax__image",
            src: _ctx.$props.src,
            alt: _ctx.$props.alt,
            style: normalizeStyle(computedImgStyles.value)
          }, null, 12, _hoisted_225)
        ]),
        createBaseVNode("div", _hoisted_316, [
          renderSlot(_ctx.$slots, "default")
        ])
      ], 4);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-parallax/VaParallax.js
var _style_077 = ":root,\n:host {\n  --va-parallax-display: block;\n  --va-parallax-width: auto;\n  --va-parallax-z-index: 0;\n  /* Image container */\n  --va-parallax-image-container-contain: strict;\n  --va-parallax-image-container-user-select: none;\n  /* Image */\n  --va-parallax-image-will-change: transform;\n  --va-parallax-image-transition: 0.3s opacity linear;\n}\n.va-parallax {\n  display: var(--va-parallax-display);\n  position: relative;\n  overflow: hidden;\n  width: var(--va-parallax-width);\n  z-index: var(--va-parallax-z-index);\n  font-family: var(--va-font-family);\n}\n.va-parallax__image-container {\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  z-index: 1;\n  contain: var(--va-parallax-image-container-contain);\n  -webkit-user-select: var(--va-parallax-image-container-user-select);\n     -moz-user-select: var(--va-parallax-image-container-user-select);\n          user-select: var(--va-parallax-image-container-user-select);\n}\n.va-parallax__image {\n  position: absolute;\n  bottom: 0;\n  left: 50%;\n  min-width: 100%;\n  max-width: unset;\n  min-height: 100%;\n  display: none;\n  transform: translate(-50%, 0);\n  will-change: var(--va-parallax-image-will-change);\n  transition: var(--va-parallax-image-transition);\n  z-index: 1;\n}\n.va-parallax__item-container {\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  z-index: 2;\n  contain: strict;\n}";
var _VaParallax = _export_sfc(_sfc_main82, [["styles", [_style_077]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-parallax/index.js
var VaParallax = withConfigTransport$1(_VaParallax);

// node_modules/vuestic-ui/dist/web-components/src/components/va-popover/VaPopover.vue_vue_type_script_setup_true_lang.js
var _hoisted_150 = {
  key: 0,
  "aria-hidden": "true",
  class: "va-popover__icon"
};
var _hoisted_226 = { key: 1 };
var _hoisted_317 = {
  key: 0,
  class: "va-popover__title"
};
var _hoisted_49 = {
  key: 1,
  class: "va-popover__body"
};
var VaDropdownProps3 = extractComponentProps(VaDropdown, ["closeOnClickOutside"]);
var _sfc_main83 = defineComponent({
  ...{
    name: "VaPopover"
  },
  __name: "VaPopover",
  props: {
    ...VaDropdownProps3,
    ...useComponentPresetProp,
    trigger: { ...VaDropdownProps3.trigger, default: ["hover", "enter", "space", "arrow-down", "arrow-up"] },
    color: { type: String, default: "#1b1a1f" },
    // TODO: Make sure add this color to pallete
    textColor: { type: String },
    icon: { type: String, default: "" },
    title: { type: String, default: "" },
    message: { type: String, default: "" },
    autoHide: { type: Boolean, default: true },
    offset: { type: [Array, Number], default: 4 }
  },
  setup(__props) {
    const props = __props;
    const VaDropdownPropValues = filterComponentProps(VaDropdownProps3);
    const { getColor, getBoxShadowColor: getBoxShadowColor2 } = useColors();
    const slots = useSlots();
    const { textColorComputed } = useTextColor(computed(() => getColor(props.color)));
    const showIconComputed = computed(() => props.icon || slots.icon);
    const showTitleComputed = computed(() => props.title || slots.title);
    const showBodyComputed = computed(() => props.message || slots.body);
    const showPopoverContentComputed = computed(
      () => showTitleComputed.value || showBodyComputed.value
    );
    const computedPopoverStyle = computed(() => ({
      boxShadow: `var(--va-popover-content-box-shadow) ${getBoxShadowColor2(getColor(props.color))}`,
      backgroundColor: getColor(props.color),
      color: textColorComputed.value
    }));
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(VaDropdown), mergeProps(unref(VaDropdownPropValues), {
        "model-value": _ctx.modelValue,
        "close-on-click-outside": __props.autoHide,
        offset: _ctx.$props.offset,
        class: "va-popover"
      }), {
        default: withCtx(() => [
          createBaseVNode("div", {
            style: normalizeStyle(computedPopoverStyle.value),
            class: "va-popover__content",
            role: "tooltip"
          }, [
            showIconComputed.value ? (openBlock(), createElementBlock("div", _hoisted_150, [
              renderSlot(_ctx.$slots, "icon", {}, () => [
                createVNode(unref(VaIcon), {
                  name: _ctx.$props.icon,
                  color: unref(textColorComputed)
                }, null, 8, ["name", "color"])
              ])
            ])) : createCommentVNode("", true),
            showPopoverContentComputed.value ? (openBlock(), createElementBlock("div", _hoisted_226, [
              showTitleComputed.value ? (openBlock(), createElementBlock("div", _hoisted_317, [
                renderSlot(_ctx.$slots, "title", {}, () => [
                  createTextVNode(toDisplayString(_ctx.$props.title), 1)
                ])
              ])) : createCommentVNode("", true),
              showBodyComputed.value ? (openBlock(), createElementBlock("div", _hoisted_49, [
                renderSlot(_ctx.$slots, "body", {}, () => [
                  createTextVNode(toDisplayString(_ctx.$props.message), 1)
                ])
              ])) : createCommentVNode("", true)
            ])) : createCommentVNode("", true)
          ], 4)
        ]),
        anchor: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16, ["model-value", "close-on-click-outside", "offset"]);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-popover/VaPopover.js
var _style_078 = ":root,\n:host {\n  --va-popover-display: inline-block;\n  --va-popover-content-opacity: 1;\n  --va-popover-content-display: flex;\n  --va-popover-content-align-items: center;\n  --va-popover-content-padding: 0.65rem 1rem;\n  --va-popover-content-border-radius: 0.5rem;\n  --va-popover-content-font-size: 1rem;\n  --va-popover-content-box-shadow: 0 2px 3px 0;\n  --va-popover-content-background-color: var(--va-background-primary);\n  --va-popover-title-font-weight: 700;\n  --va-popover-title-margin-bottom: 0.125rem;\n  --va-popover-body-line-height: 1.5;\n}\n.va-popover {\n  display: var(--va-popover-display);\n}\n.va-popover__content {\n  background-color: var(--va-popover-content-background-color);\n  opacity: var(--va-popover-content-opacity);\n  display: var(--va-popover-content-display);\n  align-items: var(--va-popover-content-align-items);\n  padding: var(--va-popover-content-padding);\n  border-radius: var(--va-popover-content-border-radius, var(--va-block-border-radius));\n  font-size: var(--va-popover-content-font-size);\n}\n.va-popover__icon + div {\n  padding-left: 0.75rem;\n  overflow: hidden;\n  width: 100%;\n}\n.va-popover__title {\n  font-weight: var(--va-popover-title-font-weight);\n  margin-bottom: var(--va-popover-title-margin-bottom);\n}\n.va-popover__body {\n  line-height: var(--va-popover-body-line-height);\n}";
var _VaPopover = _export_sfc(_sfc_main83, [["styles", [_style_078]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-popover/index.js
var VaPopover = withConfigTransport$1(_VaPopover);

// node_modules/vuestic-ui/dist/web-components/src/components/va-rating/types.js
var RatingValue = ((RatingValue2) => {
  RatingValue2[RatingValue2["EMPTY"] = 0] = "EMPTY";
  RatingValue2[RatingValue2["HALF"] = 0.5] = "HALF";
  RatingValue2[RatingValue2["FULL"] = 1] = "FULL";
  return RatingValue2;
})(RatingValue || {});

// node_modules/vuestic-ui/dist/web-components/src/components/va-rating/hooks/useRating.js
var getContext = () => {
  const instance = getCurrentInstance();
  if (!instance) {
    throw new Error("useRating hooks must be used on top of setup function");
  }
  return {
    props: instance.props,
    emit: instance.emit
  };
};
var useRatingProps = {
  ...useStatefulProps,
  modelValue: { type: Number, default: 0 },
  clearable: { type: Boolean, default: false },
  hover: { type: Boolean, default: false }
};
var useRating = (props) => {
  const { emit } = getContext();
  const { isHovered, onMouseEnter, onMouseLeave } = useHover();
  const { valueComputed: modelValue } = useStateful(props, emit);
  const hoveredValue = ref(0);
  const visibleValue = computed(() => !props.disabled && !props.readonly && props.hover && isHovered.value ? hoveredValue.value : modelValue.value);
  const onItemValueUpdate = (itemIndex, newValue) => {
    const newModelValue = itemIndex + newValue;
    if (props.clearable) {
      if (modelValue.value === newModelValue) {
        modelValue.value = 0;
        return;
      }
    }
    modelValue.value = newModelValue;
  };
  const onItemHoveredValueUpdate = (itemIndex, newValue) => {
    if (!props.hover) {
      return;
    }
    hoveredValue.value = itemIndex + newValue;
  };
  const getItemValue = (itemIndex) => {
    const itemValue = visibleValue.value - itemIndex;
    return clamp$1(itemValue, RatingValue.EMPTY, RatingValue.FULL);
  };
  return {
    visibleValue,
    modelValue,
    hoveredValue,
    isHovered,
    onMouseEnter,
    onMouseLeave,
    onItemValueUpdate,
    onItemHoveredValueUpdate,
    getItemValue
  };
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-rating/hooks/useVaRatingColors.js
var useVaRatingColorsProps = {
  unselectedColor: { type: String },
  color: { type: String, default: "primary" },
  modelValue: { type: Number }
};
var useVaRatingColors = (props) => {
  const { getColor, getFocusColor: getFocusColor2, getTextColor } = useColors();
  const computedColor = computed(() => getColor(props.color));
  const backgroundColor = computed(() => {
    if (props.unselectedColor) {
      return getColor(props.unselectedColor);
    }
    return getFocusColor2(getColor(props.color));
  });
  const backgroundComputed = computed(() => {
    if (props.modelValue === RatingValue.HALF) {
      return `linear-gradient(90deg, ${computedColor.value} 50%, ${backgroundColor.value} 50%`;
    }
    if (props.modelValue === RatingValue.EMPTY) {
      return backgroundColor.value;
    }
    return computedColor.value;
  });
  const textColorComputed = computed(() => {
    if (props.modelValue === RatingValue.FULL) {
      return getColor(getTextColor(computedColor.value));
    }
    return getColor(getTextColor(backgroundColor.value));
  });
  return {
    computedColor,
    backgroundComputed,
    textColorComputed
  };
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-rating/components/VaRatingItem/VaRatingItem.vue_vue_type_script_setup_true_lang.js
var _hoisted_151 = ["tabindex", "onKeydown"];
var _sfc_main84 = defineComponent({
  ...{
    name: "VaRatingItem"
  },
  __name: "VaRatingItem",
  props: {
    modelValue: { type: Number, default: 0 },
    icon: { type: String, default: "star" },
    halfIcon: { type: String, default: "star_half" },
    emptyIcon: { type: String, default: "star_outline" },
    halves: { type: Boolean, default: false },
    hover: { type: Boolean, default: false },
    tabindex: { type: [String, Number], default: 0 },
    disabled: { type: Boolean, default: false },
    readonly: { type: Boolean, default: false },
    size: { type: [String, Number], default: "medium" },
    unselectedColor: { type: String },
    color: { type: String, default: "primary" }
  },
  emits: ["update:modelValue", "click", "hover"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const rootEl = shallowRef();
    const [modelValue] = useSyncProp("modelValue", props, emit, RatingValue.EMPTY);
    const hoveredValue = ref(null);
    const visibleValue = computed(() => {
      if (props.hover && !props.disabled && !props.readonly) {
        return hoveredValue.value || modelValue.value;
      }
      return modelValue.value;
    });
    const { getColor } = useColors();
    const computedColor = computed(() => getColor(
      props.unselectedColor && visibleValue.value === RatingValue.EMPTY ? props.unselectedColor : props.color
    ));
    const onMouseMove = (ev) => {
      if (!rootEl.value) {
        return;
      }
      const { offsetX } = ev;
      const iconWidth = rootEl.value.clientWidth;
      if (props.halves) {
        hoveredValue.value = offsetX / iconWidth <= RatingValue.HALF ? RatingValue.HALF : RatingValue.FULL;
      } else {
        hoveredValue.value = RatingValue.FULL;
      }
    };
    const onMouseLeave = () => {
      hoveredValue.value = null;
    };
    const onClick = () => {
      modelValue.value = hoveredValue.value || RatingValue.FULL;
      emit("click", hoveredValue.value || RatingValue.FULL);
    };
    watch(hoveredValue, () => emit("hover", hoveredValue.value || RatingValue.EMPTY));
    const computedIconName = computed(() => {
      if (props.halves && visibleValue.value === RatingValue.HALF) {
        return props.halfIcon;
      }
      if (visibleValue.value === RatingValue.EMPTY) {
        return props.emptyIcon;
      }
      return props.icon;
    });
    const tabIndexComputed = computed(() => props.disabled ? -1 : props.tabindex);
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        ref_key: "rootEl",
        ref: rootEl,
        role: "button",
        class: "va-rating-item",
        tabindex: tabIndexComputed.value,
        onKeydown: [
          withKeys(onClick, ["enter"]),
          withKeys(withModifiers(onClick, ["prevent"]), ["space"])
        ],
        onMousemove: onMouseMove,
        onMouseleave: onMouseLeave,
        onClick
      }, [
        renderSlot(_ctx.$slots, "default", normalizeProps(guardReactiveProps({ value: visibleValue.value, onClick })), () => [
          createVNode(unref(VaIcon), {
            class: "va-rating-item__wrapper",
            tabindex: "-1",
            tag: "button",
            name: computedIconName.value,
            size: _ctx.$props.size,
            color: computedColor.value
          }, null, 8, ["name", "size", "color"])
        ])
      ], 40, _hoisted_151);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-rating/components/VaRatingItem/VaRatingItem.js
var _style_079 = ".va-rating-item {\n  display: inline-block;\n}\n.va-rating-item:focus-visible {\n  outline: 2px solid var(--va-focus) !important;\n  border-radius: 2px;\n}\n.va-rating-item__wrapper {\n  font-size: 100%;\n  overflow: visible;\n  text-transform: none;\n  padding: 0;\n  background-color: transparent;\n  border-style: none;\n}";
var _VaRatingItem = _export_sfc(_sfc_main84, [["styles", [_style_079]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-rating/components/VaRatingItemNumberButton.vue_vue_type_script_setup_true_lang.js
var _sfc_main85 = defineComponent({
  ...{
    name: "VaRatingItemNumberButton"
  },
  __name: "VaRatingItemNumberButton",
  props: {
    ...useVaRatingColorsProps,
    ...useSizeProps,
    itemNumber: { type: Number, required: true },
    modelValue: { type: Number, required: true }
  },
  setup(__props) {
    const props = __props;
    const {
      textColorComputed,
      backgroundComputed
    } = useVaRatingColors(props);
    const {
      sizeComputed,
      fontSizeComputed,
      fontSizeInRem
    } = useSize(props, "VaRating");
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("button", {
        class: "va-rating__number-item",
        tabindex: "-1",
        "aria-hidden": "true",
        style: normalizeStyle({
          background: unref(backgroundComputed),
          color: unref(textColorComputed),
          width: unref(sizeComputed),
          height: unref(sizeComputed),
          fontSize: unref(fontSizeComputed),
          borderRadius: `${parseInt(unref(fontSizeComputed)) * 0.125}rem`
        })
      }, toDisplayString(__props.itemNumber), 5);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-rating/VaRating.vue_vue_type_script_setup_true_lang.js
var _hoisted_152 = ["aria-label"];
var VaRatingItemPropsDeclarations = extractComponentProps(_VaRatingItem, ["modelValue", "itemNumber"]);
var VaRatingItemNumberButtonPropsDeclarations = extractComponentProps(_sfc_main85, ["modelValue", "itemNumber"]);
var _sfc_main86 = defineComponent({
  ...{
    name: "VaRating"
  },
  __name: "VaRating",
  props: {
    ...VaRatingItemNumberButtonPropsDeclarations,
    ...useRatingProps,
    ...useVaRatingColorsProps,
    ...useFormFieldProps,
    ...VaRatingItemPropsDeclarations,
    ...useComponentPresetProp,
    modelValue: { type: Number, default: 0 },
    numbers: { type: Boolean, default: false },
    halves: { type: Boolean, default: false },
    max: { type: Number, default: 5 },
    texts: { type: Array, default: () => [] },
    ariaLabel: { type: String, default: "$t:currentRating" },
    ariaItemLabel: { type: String, default: "$t:voteRating" }
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const { computedClasses: rootClass } = useFormField("va-rating", props);
    const {
      visibleValue,
      modelValue: vModel,
      hoveredValue,
      isHovered,
      onMouseEnter,
      onMouseLeave,
      onItemValueUpdate,
      onItemHoveredValueUpdate,
      getItemValue
    } = useRating(props);
    const isInteractionsEnabled = computed(() => !props.disabled && !props.readonly);
    const onArrowKeyPress = (direction) => {
      const step = props.halves ? RatingValue.HALF : RatingValue.FULL;
      const nextStep = visibleValue.value + step * direction;
      const min = props.clearable ? 0 : step;
      if (nextStep >= min && nextStep <= props.max) {
        onItemValueUpdate(visibleValue.value, step * direction);
      } else if (nextStep < min) {
        onItemValueUpdate(min, 0);
      } else {
        onItemValueUpdate(props.max, direction === -1 ? step * direction : 0);
      }
    };
    const { tp, t } = useTranslation();
    const {
      computedColor,
      backgroundComputed,
      textColorComputed
    } = useVaRatingColors(props);
    const tabIndexComputed = computed(() => isInteractionsEnabled.value ? 0 : void 0);
    const VaRatingItemProps = filterComponentProps(VaRatingItemPropsDeclarations);
    const VaRatingItemNumberButtonProps = filterComponentProps(VaRatingItemNumberButtonPropsDeclarations);
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["va-rating", unref(rootClass)]),
        "aria-label": unref(tp)(_ctx.$props.ariaLabel, { max: _ctx.$props.max, value: _ctx.$props.modelValue })
      }, [
        createBaseVNode("div", {
          class: "va-rating__item-wrapper",
          onKeyup: [
            _cache[0] || (_cache[0] = withKeys(($event) => onArrowKeyPress(-1), ["left"])),
            _cache[1] || (_cache[1] = withKeys(($event) => onArrowKeyPress(1), ["right"]))
          ],
          onMouseenter: _cache[2] || (_cache[2] = //@ts-ignore
          (...args) => unref(onMouseEnter) && unref(onMouseEnter)(...args)),
          onMouseleave: _cache[3] || (_cache[3] = //@ts-ignore
          (...args) => unref(onMouseLeave) && unref(onMouseLeave)(...args))
        }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.$props.max, (itemNumber) => {
            return openBlock(), createBlock(_VaRatingItem, mergeProps({
              key: itemNumber,
              class: "va-rating__item"
            }, unref(VaRatingItemProps), {
              "aria-label": unref(tp)(_ctx.$props.ariaItemLabel, { max: _ctx.$props.max, value: itemNumber }),
              "model-value": unref(getItemValue)(itemNumber - 1),
              tabindex: tabIndexComputed.value,
              disabled: _ctx.$props.disabled,
              readonly: _ctx.$props.readonly,
              onHover: ($event) => isInteractionsEnabled.value && unref(onItemHoveredValueUpdate)(itemNumber - 1, $event),
              "onUpdate:modelValue": ($event) => isInteractionsEnabled.value && unref(onItemValueUpdate)(itemNumber - 1, $event)
            }), {
              default: withCtx(({ value, onClick }) => [
                renderSlot(_ctx.$slots, "item", normalizeProps(guardReactiveProps({ value, onClick, index: itemNumber })), () => [
                  _ctx.$props.numbers ? (openBlock(), createBlock(_sfc_main85, mergeProps({ key: 0 }, unref(VaRatingItemNumberButtonProps), {
                    "model-value": value,
                    "item-number": itemNumber
                  }), null, 16, ["model-value", "item-number"])) : createCommentVNode("", true)
                ])
              ]),
              _: 2
            }, 1040, ["aria-label", "model-value", "tabindex", "disabled", "readonly", "onHover", "onUpdate:modelValue"]);
          }), 128))
        ], 32),
        _ctx.$props.texts && _ctx.$props.texts.length === _ctx.$props.max ? (openBlock(), createElementBlock("span", {
          key: 0,
          class: "va-rating__text-wrapper",
          style: normalizeStyle({ color: unref(computedColor) })
        }, toDisplayString(_ctx.$props.texts[Math.round(unref(visibleValue)) - 1]), 5)) : createCommentVNode("", true)
      ], 10, _hoisted_152);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-rating/VaRating.js
var _style_080 = ":root,\n:host {\n  --va-rating-display: flex;\n  /* Number item */\n  --va-rating-number-item-font-size: inherit;\n  --va-rating-number-item-margin: 0.1em;\n  --va-rating-number-item-font-weight: 700;\n  --va-rating-number-item-cursor: pointer;\n  /* Item wrapper */\n  --va-rating-item-wrapper-cursor: pointer;\n}\n.va-rating {\n  display: var(--va-rating-display);\n  font-family: var(--va-font-family);\n}\n.va-rating__number-item {\n  font-size: 100%;\n  overflow: visible;\n  text-transform: none;\n  padding: 0;\n  background-color: transparent;\n  border-style: none;\n  font-size: var(--va-rating-number-item-font-size);\n  margin: var(--va-rating-number-item-margin);\n  font-weight: var(--va-rating-number-item-font-weight);\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  cursor: pointer;\n}\n.va-rating--disabled .va-rating__number-item {\n  cursor: default;\n  opacity: 0.4;\n  pointer-events: none;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n          user-select: none;\n}\n.va-rating--readonly .va-rating__number-item {\n  cursor: default;\n}\n.va-rating__item-wrapper {\n  display: flex;\n  cursor: var(--va-rating-item-wrapper-cursor);\n}\n.va-rating--readonly .va-rating__item-wrapper, .va-rating--disabled .va-rating__item-wrapper {\n  cursor: default;\n}\n.va-rating-item {\n  display: flex;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n}\n.va-rating--disabled .va-rating-item {\n  cursor: default;\n  opacity: 0.4;\n  pointer-events: none;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n          user-select: none;\n}\n.va-rating--disabled .va-rating-item__wrapper {\n  cursor: initial !important;\n}\n.va-rating--readonly .va-rating-item .va-rating-item__wrapper {\n  cursor: initial !important;\n}\n.va-rating__text-wrapper {\n  padding-left: 10px;\n}";
var _VaRating = _export_sfc(_sfc_main86, [["styles", [_style_080]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-rating/index.js
var VaRating = withConfigTransport$1(_VaRating);

// node_modules/vuestic-ui/dist/web-components/src/utils/scroll-to-element.js
var getTopCoordinate = (element) => element.offsetTop;
var getBottomCoordinate = (element) => element.offsetTop + element.offsetHeight;
var getCenterCoordinate = (element) => element.offsetTop + element.offsetHeight / 2;
var getScrollTop = (element, scrollTarget, verticalAlignment) => {
  const viewHeight = scrollTarget.offsetHeight;
  const currentPosition = scrollTarget.scrollTop;
  const top = getTopCoordinate(element) - scrollTarget.offsetTop;
  const center = getCenterCoordinate(element) - scrollTarget.offsetTop;
  const bottom = getBottomCoordinate(element) - scrollTarget.offsetTop;
  if (verticalAlignment === "start") {
    return top;
  }
  if (verticalAlignment === "end") {
    return bottom - viewHeight;
  }
  if (verticalAlignment === "center") {
    return center - viewHeight / 2;
  }
  if (verticalAlignment === "any") {
    if (top - currentPosition < 0) {
      return top;
    }
    if (bottom - currentPosition > viewHeight) {
      return bottom - viewHeight;
    }
  }
};
var scrollToElement = (element, options = {
  scrollTarget: element.parentElement,
  verticalAlignment: "any",
  smooth: false
}) => {
  const scrollTarget = options.scrollTarget || element.parentElement;
  const top = getScrollTop(element, scrollTarget, options.verticalAlignment);
  if (top === void 0) {
    return;
  }
  scrollTarget.scroll({
    top,
    behavior: options.smooth ? "smooth" : "auto"
  });
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-select/components/VaSelectOption/VaSelectOption.vue_vue_type_script_setup_true_lang.js
var _hoisted_153 = ["aria-selected"];
var _hoisted_227 = {
  key: 1,
  class: "va-select-option__highlighted"
};
var _sfc_main87 = defineComponent({
  ...{
    name: "VaSelectOption"
  },
  __name: "VaSelectOption",
  props: {
    ...useColorProps,
    disabled: { type: Boolean, default: false },
    option: { type: [Number, String, Boolean, Object], default: () => ({}) },
    getText: { type: Function, required: true },
    getTrackBy: { type: Function, required: true },
    currentOption: { type: [String, Number, Boolean, Object], default: null },
    getSelectedState: { type: Function, required: true },
    search: { type: String, default: "" },
    highlightMatchedText: { type: Boolean, default: true },
    inputFocused: { type: Boolean, default: false },
    minSearchChars: { type: Number, default: 0 }
  },
  setup(__props, { expose: __expose }) {
    const props = __props;
    const { getColor, getHoverColor: getHoverColor2 } = useColors();
    const optionIcon = computed(() => isObject3(props.option) ? props.option.icon : void 0);
    const optionIconColor = computed(() => getColor(props.color));
    const optionText = computed(() => props.getText(props.option));
    const optionTextSplitted = computed(() => {
      const defaultSplit = { start: optionText.value, searchedSubString: "", end: "" };
      if (!optionText.value || !props.search || !props.highlightMatchedText || props.search.length < props.minSearchChars) {
        return defaultSplit;
      }
      const substringStartIndex = optionText.value.toLowerCase().indexOf(props.search.toLowerCase());
      if (substringStartIndex < 0) {
        return defaultSplit;
      }
      const start = optionText.value.slice(0, substringStartIndex);
      const searchedSubString = optionText.value.slice(substringStartIndex, substringStartIndex + props.search.length);
      const end = optionText.value.slice(substringStartIndex + props.search.length);
      return { start, searchedSubString, end };
    });
    const isSelected = computed(() => props.getSelectedState(props.option));
    const isFocused = computed(() => {
      if (typeof props.option === "string") {
        return props.option === props.currentOption;
      }
      return props.getTrackBy(props.currentOption) === props.getTrackBy(props.option);
    });
    const optionClass = useBem("va-select-option", () => ({
      selected: isSelected.value
    }));
    const optionStyle = computed(() => ({
      color: isSelected.value ? getColor(props.color) : "inherit",
      backgroundColor: isFocused.value ? getHoverColor2(getColor(props.color)) : "transparent",
      cursor: props.disabled ? "default" : void 0,
      opacity: props.disabled ? "var(--va-select-option-list-option-disabled-opacity)" : void 0
    }));
    __expose({
      isFocused,
      isSelected
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        role: "option",
        class: normalizeClass(["va-select-option", unref(optionClass)]),
        style: normalizeStyle(optionStyle.value),
        "aria-selected": isSelected.value
      }, [
        renderSlot(_ctx.$slots, "option-content", {}, () => [
          optionIcon.value ? (openBlock(), createBlock(unref(VaIcon), {
            key: 0,
            size: "small",
            class: "va-select-option__icon",
            name: optionIcon.value
          }, null, 8, ["name"])) : createCommentVNode("", true),
          createTextVNode(" " + toDisplayString(optionTextSplitted.value.start) + " ", 1),
          optionTextSplitted.value.searchedSubString ? (openBlock(), createElementBlock("span", _hoisted_227, toDisplayString(optionTextSplitted.value.searchedSubString), 1)) : createCommentVNode("", true),
          createTextVNode(" " + toDisplayString(optionTextSplitted.value.end), 1)
        ]),
        withDirectives(createVNode(unref(VaIcon), {
          class: "va-select-option__selected-icon",
          size: "small",
          name: "va-check",
          color: optionIconColor.value
        }, null, 8, ["color"]), [
          [vShow, isSelected.value]
        ])
      ], 14, _hoisted_153);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-select/components/VaSelectOption/VaSelectOption.js
var _style_081 = ":root,\n:host {\n  --va-select-option-list-option-cursor: pointer;\n  --va-select-option-list-option-display: flex;\n  --va-select-option-list-option-align-items: center;\n  --va-select-option-list-option-padding: 0.375rem 0.75rem;\n  --va-select-option-list-option-min-height: 2.25rem;\n  --va-select-option-list-option-word-break: break-word;\n  /* Empty options list */\n  --va-select-option-list-empty-block-padding: 0.375rem 0.75rem;\n  /* Icon */\n  --va-select-option-list-option-icon-margin-right: 0.5rem;\n  /* Selected Icon */\n  --va-select-option-list-option-selected-icon-margin-left: auto;\n  --va-select-option-list-option-selected-icon-font-size: 0.8rem;\n  /* Disabled Option */\n  --va-select-option-list-option-disabled-opacity: 0.7;\n  /* Highlighted Chars */\n  --va-select-option-list-option-highlighted-color: var(--va-text-inverted);\n  --va-select-option-list-option-highlighted-background-color: var(--va-primary);\n  --va-select-option-list-option-highlighted-border-radius: 0.1rem;\n  --va-select-option-list-option-highlighted-margin: 0 1px;\n  --va-select-option-list-option-highlighted-padding: 0 1px;\n  /* Autocomplete */\n  --va-select-content-autocomplete-gap: 0.25rem;\n  --va-select-content-autocomplete-color: var(--va-text-primary);\n  --va-select-content-autocomplete-line-height: calc(var(--va-input-font-size) + 2px);\n}\n.va-select-option {\n  min-height: var(--va-select-option-list-option-min-height);\n  padding: var(--va-select-option-list-option-padding);\n  display: var(--va-select-option-list-option-display);\n  align-items: var(--va-select-option-list-option-align-items);\n  word-break: var(--va-select-option-list-option-word-break);\n  cursor: var(--va-select-option-list-option-cursor);\n}\n.va-select-option__icon {\n  margin-right: var(--va-select-option-list-option-icon-margin-right);\n}\n.va-select-option__selected-icon {\n  margin-left: var(--va-select-option-list-option-selected-icon-margin-left);\n  font-size: var(--va-select-option-list-option-selected-icon-font-size);\n}\n.va-select-option__highlighted {\n  color: var(--va-select-option-list-option-highlighted-color);\n  background-color: var(--va-select-option-list-option-highlighted-background-color);\n  border-radius: var(--va-select-option-list-option-highlighted-border-radius);\n  margin: var(--va-select-option-list-option-highlighted-margin);\n  padding: var(--va-select-option-list-option-highlighted-padding);\n}";
var _VaSelectOption = _export_sfc(_sfc_main87, [["styles", [_style_081]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-select/components/VaSelectOption/index.js
var VaSelectOption = withConfigTransport$1(_VaSelectOption);

// node_modules/vuestic-ui/dist/web-components/src/composables/useObjectRefs.js
var useObjectRefs = () => {
  const itemRefs = shallowRef({});
  const setItemRef = (key) => (el) => {
    if (!el) {
      return;
    }
    itemRefs.value[key] = el;
    return String(key);
  };
  onBeforeUpdate(() => {
    itemRefs.value = {};
  });
  return { itemRefs, setItemRef };
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-select/components/VaSelectOptionList/VaSelectOptionList.vue_vue_type_script_setup_true_lang.js
var _hoisted_154 = ["tabindex", "onKeydown", "aria-multiselectable"];
var _hoisted_228 = {
  key: 0,
  class: "va-select-option-list__group-name",
  role: "presentation"
};
var _hoisted_318 = {
  key: 0,
  class: "va-select-option-list--empty"
};
var _sfc_main88 = defineComponent({
  ...{
    name: "VaSelectOptionList"
  },
  __name: "VaSelectOptionList",
  props: {
    ...useColorProps,
    ...useComponentPresetProp,
    ...useSelectableListProps,
    ...useThrottleProps,
    noOptionsText: { type: String, default: "Items not found" },
    getSelectedState: { type: Function, required: true },
    multiple: { type: Boolean, default: false },
    search: { type: String, default: "" },
    tabindex: { type: [String, Number], default: 0 },
    hoveredOption: { type: [String, Number, Boolean, Object], default: null },
    virtualScroller: { type: Boolean, default: true },
    highlightMatchedText: { type: Boolean, default: true },
    minSearchChars: { type: Number, default: 0 },
    autoSelectFirstOption: { type: Boolean, default: false },
    selectedTopShown: { type: Boolean, default: false },
    doShowAllOptions: { type: Boolean, default: false }
  },
  emits: [
    "select-option",
    "update:hoveredOption",
    "no-previous-option-to-hover",
    "scroll-bottom"
  ],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const root2 = shallowRef();
    const focus = () => {
      var _a2;
      (_a2 = root2.value) == null ? void 0 : _a2.focus({ preventScroll: true });
    };
    const rootHeight = computed(() => {
      var _a2;
      return ((_a2 = root2.value) == null ? void 0 : _a2.clientHeight) ?? 200;
    });
    const handleScrollToBottom = () => emit("scroll-bottom");
    const onScroll = (event) => {
      const target = event.target;
      if (!target) {
        return;
      }
      if (target.scrollTop + target.clientHeight === target.scrollHeight) {
        handleScrollToBottom();
      }
    };
    const lastInteractionSource = ref("");
    const currentOptionComputed = computed(() => props.hoveredOption ?? null);
    const updateCurrentOption = (option, source) => {
      emit("update:hoveredOption", option);
      lastInteractionSource.value = source;
    };
    const { getText, getGroupBy, getTrackBy, getDisabled } = useSelectableList(props);
    const currentSelectedOptionText = computed(() => {
      var _a2;
      const getSelectedState = props.getSelectedState;
      const selected = (_a2 = props.options) == null ? void 0 : _a2.find((option) => getSelectedState(option));
      return selected ? getText(selected) : "";
    });
    const isSearchedOptionSelected = computed(() => {
      var _a2;
      return currentSelectedOptionText.value.toLowerCase() === ((_a2 = props.search) == null ? void 0 : _a2.toLowerCase());
    });
    const filteredOptions = computed(() => {
      if (props.doShowAllOptions && isSearchedOptionSelected.value) {
        return props.options;
      }
      if (!props.search || props.search.length < props.minSearchChars) {
        return props.options;
      }
      const search = props.search.toUpperCase().trim();
      return props.options.filter((option) => {
        const optionText = getText(option).toUpperCase();
        return optionText.includes(search);
      });
    });
    const optionGroups = computed(() => {
      if (!props.groupBy) {
        return { _noGroup: filteredOptions.value };
      }
      return filteredOptions.value.reduce((groups, option) => {
        const groupBy = getGroupBy(option);
        if (!groupBy) {
          groups._noGroup.push(option);
        } else {
          if (!groups[groupBy]) {
            groups[groupBy] = [];
          }
          groups[groupBy].push(option);
        }
        return groups;
      }, { _noGroup: [] });
    });
    const optionGroupsThrottled = useThrottleValue(optionGroups, props);
    const isValueExists = (value) => !isNilValue(value);
    const updateHoveredOption = (option) => {
      if (option === currentOptionComputed.value || isValueExists(option) && getDisabled(option)) {
        return;
      }
      updateCurrentOption(option ?? null, "mouse");
    };
    const updateFocusedOption = (option) => {
      updateCurrentOption(option ?? null, "keyboard");
    };
    const selectHoveredOption = () => {
      const previousOption = previousOptionComputed.value && typeof previousOptionComputed.value === "object" ? { ...previousOptionComputed.value } : previousOptionComputed.value;
      emit("select-option");
      if (props.selectedTopShown) {
        updateHoveredOption(previousOption);
      }
    };
    const groupedOptions = computed(() => Object.values(optionGroupsThrottled.value).flat());
    const currentOptions = computed(() => filteredOptions.value.some((el) => getGroupBy(el)) ? groupedOptions.value : filteredOptions.value);
    const currentOptionIndex = computed(() => currentOptions.value.findIndex((option) => {
      return isValueExists(currentOptionComputed.value) && getTrackBy(option) === getTrackBy(currentOptionComputed.value);
    }));
    const selectOptionProps = computed(() => ({
      ...pick$1(props, ["getSelectedState", "color", "search", "highlightMatchedText", "minSearchChars"]),
      getText,
      getTrackBy
    }));
    const findNextActiveOption = (startSearchIndex, reversedSearch = false) => {
      const searchBase = [...currentOptions.value || []];
      const searchBaseOrdered = reversedSearch ? searchBase.reverse() : searchBase;
      const startIndex = reversedSearch ? startSearchIndex * -1 - 1 : startSearchIndex;
      return searchBaseOrdered.slice(startIndex).find((option) => !getDisabled(option));
    };
    const previousOptionComputed = computed(() => {
      const previousOptionIndex = currentOptionIndex.value - 1;
      const previousOption = currentOptions.value[previousOptionIndex];
      const previousOptionCheck = isValueExists(previousOption) && !(previousOptionIndex === 0 && getDisabled(previousOption));
      if (previousOptionCheck) {
        return findNextActiveOption(currentOptionIndex.value - 1, true);
      }
      return void 0;
    });
    const selectOption = (option) => {
      updateHoveredOption(option);
      emit("select-option");
    };
    const handleMouseMove = (option) => {
      if (!props.selectedTopShown) {
        updateHoveredOption(option);
      }
    };
    const handleMouseEnter = (option) => {
      if (props.selectedTopShown) {
        updateHoveredOption(option);
      }
    };
    const focusPreviousOption = () => {
      if (!isValueExists(currentOptionComputed.value)) {
        updateFocusedOption(findNextActiveOption(0, true));
        return;
      }
      if (isValueExists(previousOptionComputed.value)) {
        updateFocusedOption(previousOptionComputed.value);
      } else {
        emit("no-previous-option-to-hover");
      }
    };
    const focusNextOption = () => {
      if (!isValueExists(currentOptionComputed.value)) {
        focusFirstOption();
        return;
      }
      const nextOptionIndex = currentOptionIndex.value + 1;
      const nextOption = currentOptions.value[nextOptionIndex];
      const nextOptionCheck = isValueExists(nextOption) && !(nextOptionIndex === currentOptions.value.length - 1 && getDisabled(nextOption));
      if (nextOptionCheck) {
        updateFocusedOption(findNextActiveOption(currentOptionIndex.value + 1));
      }
    };
    const focusFirstOption = () => updateFocusedOption(findNextActiveOption(0));
    const { itemRefs, setItemRef } = useObjectRefs();
    const virtualScrollerRef = shallowRef();
    const scrollToOption = (option) => {
      var _a2;
      if (!isValueExists(option)) {
        return;
      }
      const element = unwrapEl(itemRefs.value[getTrackBy(option)]);
      if (element) {
        scrollToElement(element);
      }
      const virtualScroller = (_a2 = virtualScrollerRef.value) == null ? void 0 : _a2[0];
      if (props.virtualScroller) {
        virtualScroller.virtualScrollTo(currentOptionIndex.value);
      }
    };
    watch(() => props.hoveredOption, (newOption) => {
      (!lastInteractionSource.value || lastInteractionSource.value === "keyboard") && isValueExists(newOption) && scrollToOption(newOption);
    });
    watch(filteredOptions, () => {
      if (!props.autoSelectFirstOption) {
        return;
      }
      focusFirstOption();
    }, { immediate: true });
    __expose({
      focusPreviousOption,
      focusNextOption,
      focusFirstOption,
      scrollToOption,
      focus
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        ref_key: "root",
        ref: root2,
        class: "va-select-option-list",
        tabindex: __props.tabindex,
        onKeydown: [
          withKeys(withModifiers(focusPreviousOption, ["stop", "prevent"]), ["up"]),
          withKeys(withModifiers(focusPreviousOption, ["stop", "prevent"]), ["left"]),
          withKeys(withModifiers(focusNextOption, ["stop", "prevent"]), ["down"]),
          withKeys(withModifiers(focusNextOption, ["stop", "prevent"]), ["right"]),
          withKeys(withModifiers(selectHoveredOption, ["stop", "prevent"]), ["enter"]),
          withKeys(withModifiers(selectHoveredOption, ["stop", "prevent"]), ["space"])
        ],
        onScrollPassive: onScroll,
        role: "listbox",
        "aria-multiselectable": _ctx.$props.multiple
      }, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(unref(optionGroupsThrottled), (options, groupName) => {
          return openBlock(), createElementBlock(Fragment, { key: groupName }, [
            groupName !== "_noGroup" ? (openBlock(), createElementBlock("span", _hoisted_228, toDisplayString(groupName), 1)) : createCommentVNode("", true),
            _ctx.$props.virtualScroller ? (openBlock(), createBlock(unref(VaVirtualScroller), {
              key: 1,
              ref_for: true,
              ref_key: "virtualScrollerRef",
              ref: virtualScrollerRef,
              items: options,
              "track-by": unref(getTrackBy),
              "wrapper-size": rootHeight.value,
              "onScroll:bottom": handleScrollToBottom
            }, {
              default: withCtx(({ item: option, index }) => [
                renderSlot(_ctx.$slots, "default", normalizeProps(guardReactiveProps({ option, index, selectOption: (o = option) => selectOption(o) })), () => [
                  createVNode(unref(VaSelectOption), mergeProps({
                    option,
                    "current-option": currentOptionComputed.value,
                    disabled: unref(getDisabled)(option)
                  }, selectOptionProps.value, {
                    onClick: withModifiers(selectHoveredOption, ["stop"]),
                    onMouseenter: ($event) => handleMouseEnter(option),
                    onMousemove: ($event) => handleMouseMove(option)
                  }), null, 16, ["option", "current-option", "disabled", "onMouseenter", "onMousemove"])
                ])
              ]),
              _: 2
            }, 1032, ["items", "track-by", "wrapper-size"])) : (openBlock(true), createElementBlock(Fragment, { key: 2 }, renderList(options, (option, index) => {
              return renderSlot(_ctx.$slots, "default", normalizeProps(mergeProps({
                key: unref(getTrackBy)(option)
              }, { option, index, selectOption })), () => [
                createVNode(unref(VaSelectOption), mergeProps({
                  ref_for: true,
                  ref: unref(setItemRef)(unref(getTrackBy)(option)),
                  "current-option": currentOptionComputed.value,
                  option,
                  disabled: unref(getDisabled)(option)
                }, selectOptionProps.value, {
                  onClick: withModifiers(selectHoveredOption, ["stop"]),
                  onMouseenter: ($event) => handleMouseEnter(option),
                  onMousemove: ($event) => handleMouseMove(option)
                }), {
                  "option-content": withCtx(() => [
                    renderSlot(_ctx.$slots, "option-content", normalizeProps(guardReactiveProps({ option, index })))
                  ]),
                  _: 2
                }, 1040, ["current-option", "option", "disabled", "onMouseenter", "onMousemove"])
              ]);
            }), 128))
          ], 64);
        }), 128)),
        !filteredOptions.value.length ? (openBlock(), createElementBlock("div", _hoisted_318, toDisplayString(__props.noOptionsText), 1)) : createCommentVNode("", true)
      ], 40, _hoisted_154);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-select/components/VaSelectOptionList/VaSelectOptionList.js
var _style_082 = ':root,\n:host {\n  --va-select-option-list-width: 100%;\n  --va-select-option-list-max-height: 12.5rem;\n  /* Group name */\n  --va-select-option-list-group-name-padding: 1rem 0.75rem 0.375rem;\n  --va-select-option-list-group-name-font-size: 0.6rem;\n  --va-select-option-list-group-name-color: var(--va-primary);\n  --va-select-option-list-group-name-font-weight: 700;\n  --va-select-option-list-group-name-text-transform: "uppercase";\n  /* Empty block */\n  --va-select-option-list-empty-padding: 0.5rem;\n}\n.va-select-option-list {\n  overflow: auto;\n  width: var(--va-select-option-list-width);\n  max-height: var(--va-select-option-list-max-height);\n  display: flex;\n  flex-direction: column;\n  font-family: var(--va-font-family);\n  scrollbar-color: var(--va-primary) transparent;\n  scrollbar-width: thin;\n  transition: scrollbar-color 0.3s ease-in-out;\n}\n.va-select-option-list--empty {\n  padding: var(--va-select-option-list-empty-block-padding);\n}\n.va-select-option-list::-webkit-scrollbar {\n  width: 4px;\n  height: 4px;\n}\n.va-select-option-list::-webkit-scrollbar-track {\n  box-shadow: none;\n  border-radius: 10px;\n}\n.va-select-option-list::-webkit-scrollbar-thumb {\n  background: var(--va-primary);\n  opacity: 0.3;\n  border-radius: 2px;\n  -webkit-transition: background 0.3s ease-in-out;\n  transition: background 0.3s ease-in-out;\n}\n.va-select-option-list__group-name {\n  padding: var(--va-select-option-list-group-name-padding);\n  font-size: var(--va-select-option-list-group-name-font-size);\n  color: var(--va-select-option-list-group-name-color);\n  font-weight: var(--va-select-option-list-group-name-font-weight);\n  text-transform: var(--va-select-option-list-group-name-text-transform);\n}';
var _VaSelectOptionList = _export_sfc(_sfc_main88, [["styles", [_style_082]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-select/components/VaSelectOptionList/index.js
var VaSelectOptionList = withConfigTransport$1(_VaSelectOptionList);

// node_modules/vuestic-ui/dist/web-components/src/components/va-select/components/VaSelectContent/VaSelectContent.vue_vue_type_script_setup_true_lang.js
var _hoisted_155 = {
  key: 0,
  class: "va-select-content__placeholder"
};
var _hoisted_229 = ["placeholder"];
var _hoisted_319 = { class: "va-select-content__option" };
var _hoisted_410 = {
  key: 0,
  class: "va-select-content__separator"
};
var _hoisted_58 = ["placeholder", "disabled", "readonly"];
var _sfc_main89 = defineComponent({
  ...{
    name: "VaSelectContent"
  },
  __name: "VaSelectContent",
  props: {
    ...useFormFieldProps,
    ariaAttributes: { type: Object },
    value: { type: Array, required: true },
    valueString: { type: String },
    separator: { type: String, default: ", " },
    placeholder: { type: String, default: "" },
    tabindex: { type: [String, Number], default: 0 },
    hiddenSelectedOptionsAmount: { type: Number, default: 0 },
    isAllOptionsShown: { type: Boolean, default: false },
    autocomplete: { type: Boolean, default: false },
    focused: { type: Boolean, default: false },
    multiple: { type: Boolean, default: false },
    getText: { type: Function, required: true },
    autocompleteInputValue: { type: String, default: "" }
  },
  emits: ["toggle-hidden", "autocomplete-input", "focus-prev", "focus-next", "select-option", "delete-last-selected"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const autocompleteInput = ref();
    const isPlaceholder = computed(() => props.placeholder && !props.valueString);
    const toggleHiddenOptionsState = () => emit("toggle-hidden");
    const { value, focused } = toRefs(props);
    const autocompleteInputValueComputed = computed({
      get: () => props.autocompleteInputValue,
      set: (v) => emit("autocomplete-input", v)
    });
    onMounted(() => {
      if (props.multiple) {
        return;
      }
      if (!props.autocomplete) {
        return;
      }
      autocompleteInputValueComputed.value = props.valueString;
    });
    watch(focused, (newValue) => {
      var _a2, _b;
      if (!props.autocomplete || !newValue) {
        return;
      }
      if (autocompleteInputValueComputed.value) {
        (_a2 = autocompleteInput.value) == null ? void 0 : _a2.setSelectionRange(0, autocompleteInputValueComputed.value.length);
      } else {
        (_b = autocompleteInput.value) == null ? void 0 : _b.focus();
      }
    });
    const handleBackspace = (e) => {
      if (props.multiple && value.value.length && e.key === "Backspace" && !autocompleteInputValueComputed.value) {
        emit("delete-last-selected");
      }
    };
    const handleClick = (e) => {
      var _a2;
      if (props.autocomplete) {
        (_a2 = autocompleteInput.value) == null ? void 0 : _a2.focus();
        e.stopPropagation();
      }
    };
    const getIcon = (option) => isObject3(option) ? option.icon : void 0;
    const slotValue = computed(() => {
      if (props.multiple) {
        return value.value;
      }
      return value.value[0];
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: "va-select-content",
        onClick: handleClick
      }, [
        isPlaceholder.value ? (openBlock(), createElementBlock("span", _hoisted_155, [
          createBaseVNode("input", mergeProps(__props.ariaAttributes, {
            placeholder: _ctx.$props.placeholder,
            readonly: ""
          }), null, 16, _hoisted_229)
        ])) : !(props.autocomplete && !props.multiple) ? renderSlot(_ctx.$slots, "content", normalizeProps(mergeProps({ key: 1 }, {
          value: slotValue.value,
          valueString: _ctx.$props.valueString,
          valueArray: _ctx.$props.value,
          tabindex: _ctx.$props.tabindex,
          ariaAttributes: __props.ariaAttributes
        })), () => [
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.$props.value, (option, index) => {
            return openBlock(), createElementBlock(Fragment, { key: index }, [
              createBaseVNode("span", _hoisted_319, [
                renderSlot(_ctx.$slots, "option-content", normalizeProps(guardReactiveProps({ option, index, selectOption: () => void 0 })), () => [
                  getIcon(option) ? (openBlock(), createBlock(unref(VaIcon), {
                    key: 0,
                    size: "small",
                    class: "va-select-option__icon",
                    name: getIcon(option)
                  }, null, 8, ["name"])) : createCommentVNode("", true),
                  createTextVNode(" " + toDisplayString(__props.getText(option)), 1)
                ])
              ]),
              index < _ctx.$props.value.length - 1 ? (openBlock(), createElementBlock("span", _hoisted_410, toDisplayString(_ctx.$props.separator), 1)) : createCommentVNode("", true)
            ], 64);
          }), 128))
        ]) : createCommentVNode("", true),
        _ctx.$props.autocomplete ? withDirectives((openBlock(), createElementBlock("input", mergeProps({
          key: 2,
          class: "va-select-content__autocomplete"
        }, __props.ariaAttributes, {
          ref_key: "autocompleteInput",
          ref: autocompleteInput,
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => autocompleteInputValueComputed.value = $event),
          placeholder: _ctx.$props.placeholder,
          disabled: _ctx.$props.disabled,
          readonly: _ctx.$props.readonly,
          autocomplete: "off",
          "aria-autocomplete": "list",
          onKeydown: [
            _cache[1] || (_cache[1] = withKeys(withModifiers(($event) => _ctx.$emit("focus-prev"), ["stop", "prevent"]), ["up"])),
            _cache[2] || (_cache[2] = withKeys(withModifiers(($event) => _ctx.$emit("focus-next"), ["stop", "prevent"]), ["down"])),
            _cache[3] || (_cache[3] = withKeys(withModifiers(($event) => _ctx.$emit("select-option"), ["stop", "prevent"]), ["enter"])),
            handleBackspace
          ]
        }), null, 16, _hoisted_58)), [
          [vModelDynamic, autocompleteInputValueComputed.value]
        ]) : createCommentVNode("", true),
        renderSlot(_ctx.$slots, "hiddenOptionsBadge", normalizeProps(guardReactiveProps({
          amount: _ctx.$props.hiddenSelectedOptionsAmount,
          isShown: _ctx.$props.isAllOptionsShown,
          toggle: toggleHiddenOptionsState
        })), () => [
          _ctx.$props.hiddenSelectedOptionsAmount && !_ctx.$props.isAllOptionsShown ? (openBlock(), createBlock(unref(VaBadge), {
            key: 0,
            class: "va-select-content__state-icon",
            color: "info",
            text: `+${_ctx.$props.hiddenSelectedOptionsAmount}`,
            tabindex: _ctx.$props.tabindex,
            onClick: withModifiers(toggleHiddenOptionsState, ["stop"])
          }, null, 8, ["text", "tabindex"])) : createCommentVNode("", true)
        ]),
        renderSlot(_ctx.$slots, "hideOptionsButton", normalizeProps(guardReactiveProps({
          isShown: _ctx.$props.isAllOptionsShown,
          toggle: toggleHiddenOptionsState
        })), () => [
          _ctx.$props.isAllOptionsShown ? (openBlock(), createBlock(unref(VaIcon), {
            key: 0,
            role: "button",
            class: "va-select-content__state-icon",
            size: "small",
            name: "reply",
            tabindex: _ctx.$props.tabindex,
            onClick: withModifiers(toggleHiddenOptionsState, ["stop"])
          }, null, 8, ["tabindex"])) : createCommentVNode("", true)
        ])
      ]);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-select/components/VaSelectContent/VaSelectContent.js
var _style_083 = ":root,\n:host {\n  --va-select-cursor: pointer;\n  --va-select-dropdown-background: var(--va-background-secondary);\n  --va-select-state-icon-margin-left: 0.25rem;\n}\n.va-select-content {\n  display: flex;\n  flex-wrap: wrap;\n}\n.va-select-content__autocomplete {\n  flex: 1 1;\n  margin-left: 0.25rem;\n}\n.va-select-content__autocomplete:first-child {\n  margin-left: 0;\n}\n.va-select-content__placeholder {\n  overflow: hidden !important;\n  flex: 1;\n  line-height: normal;\n  color: var(--va-input-placeholder-text-color);\n  text-overflow: ellipsis !important;\n  white-space: nowrap !important;\n}\n.va-select-content__separator {\n  white-space: pre;\n}\n.va-select-content__state-icon {\n  margin-left: var(--va-select-state-icon-margin-left);\n}";
var _VaSelectContent = _export_sfc(_sfc_main89, [["styles", [_style_083]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-select/components/VaSelectContent/index.js
var VaSelectContent = withConfigTransport$1(_VaSelectContent);

// node_modules/vuestic-ui/dist/web-components/src/components/va-select/hooks/useMaxVisibleOptions.js
var useMaxVisibleOptionsProps = {
  maxVisibleOptions: { type: Number || String, default: 0 }
};
var useMaxVisibleOptions = (props, getOptionByValue) => {
  const modelValue = toRef(props, "modelValue");
  const isAllOptionsShown = ref(false);
  const belowLimitSelectedOptions = ref([]);
  const hiddenSelectedOptions = ref([]);
  const hiddenSelectedOptionsAmount = computed(() => hiddenSelectedOptions.value.length);
  const allSelectedOptions = computed(() => [...belowLimitSelectedOptions.value, ...hiddenSelectedOptions.value]);
  const visibleSelectedOptions = computed(() => {
    if (!props.maxVisibleOptions || isAllOptionsShown.value) {
      return allSelectedOptions.value;
    }
    return belowLimitSelectedOptions.value;
  });
  watch(modelValue, () => {
    if (!Array.isArray(modelValue.value)) {
      belowLimitSelectedOptions.value = [getOptionByValue(modelValue.value)];
      hiddenSelectedOptions.value = [];
      return;
    }
    const value = modelValue.value.filter((v) => !isNilValue(v)).map(getOptionByValue);
    if (props.maxVisibleOptions) {
      belowLimitSelectedOptions.value = value.slice(0, props.maxVisibleOptions);
      hiddenSelectedOptions.value = value.slice(props.maxVisibleOptions);
    } else {
      belowLimitSelectedOptions.value = [...value];
      hiddenSelectedOptions.value = [];
    }
  }, { immediate: true });
  const toggleHiddenOptionsState = () => isAllOptionsShown.value = !isAllOptionsShown.value;
  return {
    toggleHiddenOptionsState,
    isAllOptionsShown,
    visibleSelectedOptions,
    hiddenSelectedOptionsAmount,
    allSelectedOptions
  };
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-select/hooks/useToggleIcon.js
var useToggleIconProps = {
  dropdownIcon: {
    type: [String, Object],
    default: () => ({
      open: "va-arrow-down",
      close: "va-arrow-up"
    }),
    validator: (value) => {
      if (typeof value === "string") {
        return true;
      }
      return Object.entries(value).every(([prop, propValue]) => ["open", "close"].includes(prop) && typeof propValue === "string");
    }
  }
};
var useToggleIcon = (props, showDropdownContent) => {
  const toggleIcon = computed(() => {
    if (!props.dropdownIcon) {
      return "";
    }
    if (typeof props.dropdownIcon === "string") {
      return props.dropdownIcon;
    }
    return showDropdownContent.value ? props.dropdownIcon.close : props.dropdownIcon.open;
  });
  const { getHoverColor: getHoverColor2, getColor } = useColors();
  const colorComputed = computed(() => getColor("secondary"));
  const toggleIconColor = computed(() => props.readonly ? getHoverColor2(colorComputed.value) : colorComputed.value);
  return { toggleIcon, toggleIconColor };
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-select/hooks/useStringValue.js
var useStringValueProps = {
  separator: { type: String, default: ", " }
};
var useStringValue = (props, visibleSelectedOptions, getText) => {
  return computed(() => {
    var _a2;
    if (!((_a2 = visibleSelectedOptions.value) == null ? void 0 : _a2.length)) {
      return props.clearValue;
    }
    return visibleSelectedOptions.value.map(getText).join(props.separator) || props.clearValue;
  });
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-select/hooks/useAutocomplete.js
var useAutocompleteProps = {
  autocomplete: { type: Boolean, default: false }
};
var useAutocomplete = (autocompleteValue, props, value, dropdownShown, getText) => {
  const getLastOptionText = (v) => (v == null ? void 0 : v.length) ? getText(v.at(-1)) : "";
  if (props.autocomplete && !props.multiple) {
    autocompleteValue.value = getLastOptionText(value.value);
  }
  watch(value, (newValue, oldValue) => {
    if (!props.autocomplete) {
      return;
    }
    const newValueStringConverted = getLastOptionText(newValue);
    const oldValueStringConverted = getLastOptionText(oldValue);
    if (newValueStringConverted !== oldValueStringConverted) {
      autocompleteValue.value = props.multiple ? "" : newValueStringConverted;
      if (!props.multiple) {
        dropdownShown.value = false;
      }
    }
  });
  watch(autocompleteValue, (newValue) => {
    if (!props.autocomplete) {
      return;
    }
    if (newValue && newValue !== getLastOptionText(value.value)) {
      dropdownShown.value = true;
    }
  });
  const onDropdownClosed = () => {
    autocompleteValue.value = props.multiple ? "" : getLastOptionText(value.value);
  };
  watch(dropdownShown, (newValue, oldValue) => {
    if (!props.autocomplete) {
      return;
    }
    if (!newValue || oldValue) {
      onDropdownClosed();
    }
  });
  return autocompleteValue;
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-select/hooks/useSelectAria.js
var useSelectAria = () => {
  const id = useComponentUuid();
  const popupId = `combobox-controls-${id}`;
  return {
    popupId
  };
};

// node_modules/vuestic-ui/dist/web-components/src/composables/useMaxSelections.js
var useMaxSelectionsProps = {
  maxSelections: {
    type: [Number, String],
    default: void 0
  }
};
function useMaxSelections(selections, maxSelections) {
  const exceedsMaxSelections = () => {
    if (maxSelections.value === void 0 || isNaN(+maxSelections.value)) {
      return false;
    }
    return selections.value.length >= Number(maxSelections.value);
  };
  const addOption = (optionToAdd) => {
    return [...selections.value, optionToAdd];
  };
  return {
    exceedsMaxSelections,
    addOption
  };
}

// node_modules/vuestic-ui/dist/web-components/src/components/va-select/VaSelect.vue_vue_type_script_setup_true_lang.js
var VaInputWrapperProps3 = extractComponentProps(VaInputWrapper);
var _sfc_main90 = defineComponent({
  ...{
    name: "VaSelect"
  },
  __name: "VaSelect",
  props: {
    ...VaInputWrapperProps3,
    ...useComponentPresetProp,
    ...useSelectableListProps,
    ...useValidationProps,
    ...useLoadingProps,
    ...useMaxSelectionsProps,
    ...useClearableProps,
    ...useFormFieldProps,
    ...useMaxVisibleOptionsProps,
    ...useToggleIconProps,
    ...useThrottleProps,
    ...useStringValueProps,
    ...useAutocompleteProps,
    ...useDropdownableProps,
    modelValue: {
      type: [String, Number, Array, Object, Boolean],
      default: void 0
    },
    // Dropdown placement
    placement: { ...useDropdownableProps.placement, default: "bottom" },
    keepAnchorWidth: { ...useDropdownableProps.keepAnchorWidth, default: true },
    offset: { ...useDropdownableProps.offset, default: [1, 0] },
    closeOnContentClick: { ...useDropdownableProps.closeOnContentClick, default: false },
    trigger: { ...useDropdownableProps.trigger, default: () => ["click", "right-click", "space", "enter"] },
    // Select options
    allowCreate: {
      type: [Boolean, String],
      default: false,
      validator: (mode) => [true, false, "unique"].includes(mode)
    },
    color: { type: String, default: "primary" },
    multiple: { type: Boolean, default: false },
    searchable: { type: Boolean, default: false },
    width: { type: String, default: "100%" },
    maxHeight: { type: String, default: "256px" },
    noOptionsText: { type: String, default: "$t:noOptions" },
    hideSelected: { type: Boolean, default: false },
    tabindex: { type: [String, Number], default: 0 },
    virtualScroller: { type: Boolean, default: false },
    selectedTopShown: { type: Boolean, default: false },
    highlightMatchedText: { type: Boolean, default: true },
    minSearchChars: { type: Number, default: 0 },
    autoSelectFirstOption: { type: Boolean, default: false },
    // Input style
    placeholder: { type: String, default: "" },
    searchPlaceholderText: { type: String, default: "$t:search" },
    ariaLabel: { type: String, default: "$t:select" },
    ariaSearchLabel: { type: String, default: "$t:optionsFilter" },
    ariaClearLabel: { type: String, default: "$t:reset" },
    search: { type: String, default: void 0 }
  },
  emits: [
    "update:modelValue",
    "update-search",
    "create-new",
    "scroll-bottom",
    "update:search",
    ...useDropdownableEmits,
    ...useValidationEmits,
    ...useClearableEmits
  ],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const { tp, t } = useTranslation();
    const optionList = shallowRef();
    const input = shallowRef();
    const searchBar = shallowRef();
    const isInputFocused = useFocusDeep(input);
    const { getValue: getValue2, getText, getTrackBy, tryResolveByValue } = useSelectableList(props);
    const getValueText = (option) => getText(tryResolveByValue(option));
    const onScrollBottom = () => emit("scroll-bottom");
    const [searchVModel] = useSyncProp("search", props, emit, "");
    const showSearchInput = computed(() => props.searchable || props.allowCreate && !props.autocomplete);
    watch(searchVModel, (value) => {
      emit("update-search", value);
      if (!props.autocomplete) {
        hoveredOption.value = null;
      }
    });
    const getOptionByValue = (value) => {
      if (isNilValue(value) || typeof value === "object") {
        return value;
      }
      const optionByValue = props.options.find((option) => value === getValue2(option));
      if (optionByValue === void 0) {
        warn(`[VaSelect]: can not find option in options list (${JSON.stringify(props.options)}) by provided value (${JSON.stringify(value)})!`);
        return value;
      }
      return optionByValue;
    };
    const {
      toggleHiddenOptionsState,
      isAllOptionsShown,
      visibleSelectedOptions,
      hiddenSelectedOptionsAmount,
      allSelectedOptions
    } = useMaxVisibleOptions(props, getOptionByValue);
    const valueComputed = computed({
      get() {
        if (props.multiple) {
          return allSelectedOptions.value;
        }
        const value = getOptionByValue(props.modelValue);
        if (Array.isArray(value)) {
          warn("Model value should be a string, number, boolean or an object for a single Select.");
          if (value.length) {
            return value.at(-1);
          }
        }
        return value;
      },
      set(option) {
        if (Array.isArray(option)) {
          emit("update:modelValue", option.map(getValue2));
        } else {
          emit("update:modelValue", getValue2(option));
        }
      }
    });
    const valueString = useStringValue(props, visibleSelectedOptions, getValueText);
    const {
      canBeCleared,
      clearIconProps,
      onFocus,
      onBlur
    } = useClearable(props, valueComputed);
    const showClearIcon = computed(() => {
      if (!canBeCleared.value) {
        return false;
      }
      if (props.multiple && Array.isArray(valueComputed.value)) {
        return !!valueComputed.value.length;
      }
      return true;
    });
    const filteredOptions = computed(() => {
      if (!props.options) {
        return [];
      }
      if (props.selectedTopShown) {
        return props.options.slice().sort((a, b) => {
          const isASelected = checkIsOptionSelected(a);
          const isBSelected = checkIsOptionSelected(b);
          if (isASelected && isBSelected) {
            return 0;
          }
          if (isASelected && !isBSelected) {
            return -1;
          }
          return 1;
        });
      }
      if (props.hideSelected) {
        return props.options.filter((option) => !checkIsOptionSelected(option));
      }
      return props.options;
    });
    const normalizedOptionValue = computed(() => {
      if (Array.isArray(valueComputed.value)) {
        return valueComputed.value.map((value) => tryResolveByValue(value));
      }
      return tryResolveByValue(valueComputed.value);
    });
    const checkIsOptionSelected = (option) => {
      if (Array.isArray(normalizedOptionValue.value)) {
        return !isNilValue(normalizedOptionValue.value.find((valueItem) => compareOptions(valueItem, option)));
      }
      return compareOptions(normalizedOptionValue.value, option);
    };
    const compareOptions = (option1, option2) => {
      const one = getValue2(option1);
      const two = getValue2(option2);
      if (one === two) {
        return true;
      }
      if (typeof one === "string" && typeof two === "string") {
        return one === two;
      }
      if (one === null || two === null) {
        return false;
      }
      if (typeof one === "object" && typeof two === "object") {
        return getTrackBy(one) === getTrackBy(two);
      }
      return false;
    };
    const isValueComputedArray = (v) => Array.isArray(v.value);
    const selectOption = (option) => {
      if (hoveredOption.value === null) {
        hideAndFocus();
        return;
      }
      if (showSearchInput.value) {
        searchVModel.value = "";
      }
      if (props.multiple && isValueComputedArray(valueComputed)) {
        const { exceedsMaxSelections, addOption } = useMaxSelections(valueComputed, ref(props.maxSelections));
        const isSelected = checkIsOptionSelected(option);
        if (isSelected) {
          valueComputed.value = valueComputed.value.filter((optionSelected) => !compareOptions(option, optionSelected));
        } else {
          if (exceedsMaxSelections()) {
            return;
          }
          valueComputed.value = addOption(option);
        }
      } else {
        valueComputed.value = typeof option !== "object" ? option : { ...option };
        hideAndFocus();
      }
      focusAutocompleteInput();
    };
    const addNewOption = () => {
      var _a2;
      const hasAddedOption = (_a2 = props.options) == null ? void 0 : _a2.some((option) => [searchVModel.value, autocompleteValue.value].includes(getText(option)));
      const allowedToCreateCheck = !((props.allowCreate === "unique" || props.autocomplete) && hasAddedOption);
      if (allowedToCreateCheck) {
        emit("create-new", searchVModel.value || autocompleteValue.value);
        searchVModel.value = "";
        autocompleteValue.value = "";
      }
    };
    const hoveredOption = ref(null);
    const selectHoveredOption = () => {
      if (!isOpenSync.value) {
        handleDropdownOpen();
        return;
      }
      selectOption(hoveredOption.value);
    };
    const selectOrAddOption = () => {
      const allowedToCreate = !!props.allowCreate && (searchVModel.value || autocompleteValue.value);
      if (hoveredOption.value !== null) {
        selectHoveredOption();
      } else if (allowedToCreate) {
        addNewOption();
      }
    };
    const focusPreviousOption = () => {
      var _a2;
      return (_a2 = optionList.value) == null ? void 0 : _a2.focusPreviousOption();
    };
    const focusNextOption = () => {
      var _a2;
      return (_a2 = optionList.value) == null ? void 0 : _a2.focusNextOption();
    };
    const { isOpenSync, dropdownProps } = useDropdownable(props, emit, {
      defaultCloseOnValueUpdate: computed(() => !props.multiple)
    });
    const dropdownPropsComputed = computed(() => ({
      ...dropdownProps.value,
      stateful: false,
      innerAnchorSelector: ".va-input-wrapper__field"
    }));
    const showDropdownContentComputed = computed({
      get: () => isOpenSync.value,
      set: (show) => {
        show ? handleDropdownOpen() : handleDropdownClose();
      }
    });
    const handleDropdownOpen = () => {
      if (props.disabled || props.readonly) {
        return;
      }
      isOpenSync.value = true;
      scrollToSelected();
      focusSearchOrOptions();
    };
    const handleDropdownClose = () => {
      isOpenSync.value = false;
      if (!props.autocomplete) {
        searchVModel.value = "";
      }
      nextTick(() => {
        validate();
        isInputFocused.focusIfNothingIfFocused();
      });
    };
    const hideAndFocus = () => {
      handleDropdownClose();
      isInputFocused.value = true;
    };
    const focusSearchBar = () => {
      var _a2;
      (_a2 = searchBar.value) == null ? void 0 : _a2.focus();
    };
    const focusOptionList = () => {
      var _a2, _b;
      (_a2 = optionList.value) == null ? void 0 : _a2.focus();
      !props.modelValue && ((_b = optionList.value) == null ? void 0 : _b.focusFirstOption());
    };
    const focusSearchOrOptions = async () => {
      await nextTick();
      if (showSearchInput.value) {
        focusSearchBar();
      } else {
        focusOptionList();
      }
    };
    const onInputBlur = () => {
      if (showDropdownContentComputed.value) {
        return;
      }
      onBlur();
      isInputFocused.value ? isInputFocused.value = false : validate();
    };
    const tabIndexComputed = computed(() => props.disabled ? -1 : props.tabindex);
    const openSelectButtonTabIndexComputed = computed(() => props.disabled || props.autocomplete ? -1 : 0);
    const scrollToSelected = () => {
      const selected = valueComputed.value;
      const nothingSelected = typeof selected !== "object" && Array.isArray(selected) && !selected.length;
      if (nothingSelected) {
        return;
      }
      const scrollTo = Array.isArray(selected) ? selected[selected.length - 1] : selected;
      hoveredOption.value = scrollTo;
      nextTick(() => {
        var _a2;
        return (_a2 = optionList.value) == null ? void 0 : _a2.scrollToOption(scrollTo);
      });
    };
    let hintedSearchQuery = "";
    let hintedSearchQueryTimeoutIndex;
    const navigationKeys = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", "Enter", " "];
    const onHintedSearch = (event) => {
      if (navigationKeys.some((key) => key === event.key)) {
        return;
      }
      const isLetter = event.key.length === 1;
      const isDeleteKey = event.key === "Backspace" || event.key === "Delete";
      clearTimeout(hintedSearchQueryTimeoutIndex);
      if (isDeleteKey) {
        hintedSearchQuery = hintedSearchQuery ? hintedSearchQuery.slice(0, -1) : "";
      } else if (isLetter) {
        hintedSearchQuery += event.key;
      }
      if (showSearchInput.value) {
        searchVModel.value = hintedSearchQuery;
        return;
      }
      if (hintedSearchQuery) {
        const appropriateOption = props.options.find((option) => getText(option).toLowerCase().startsWith(hintedSearchQuery.toLowerCase()));
        if (appropriateOption) {
          hoveredOption.value = appropriateOption;
        }
      }
      hintedSearchQueryTimeoutIndex = setTimeout(() => {
        hintedSearchQuery = "";
      }, 1e3);
    };
    const optionsListPropsComputed = computed(() => ({
      ...pick$1(props, ["textBy", "trackBy", "groupBy", "valueBy", "disabledBy", "color", "virtualScroller", "highlightMatchedText", "minSearchChars", "delay", "selectedTopShown"]),
      autoSelectFirstOption: props.autoSelectFirstOption || props.autocomplete,
      search: searchVModel.value || autocompleteValue.value,
      tabindex: tabIndexComputed.value,
      selectedValue: valueComputed.value,
      options: filteredOptions.value,
      getSelectedState: checkIsOptionSelected,
      noOptionsText: tp(props.noOptionsText),
      doShowAllOptions: doShowAllOptions.value
    }));
    const { toggleIcon, toggleIconColor } = useToggleIcon(props, isOpenSync);
    const isFocused = computed(() => isInputFocused.value || isOpenSync.value);
    const slots = useSlots();
    const inputWrapperClassComputed = useBem("va-select-anchor", () => ({
      nowrap: !!(props.maxVisibleOptions && !slots.content)
    }));
    const vaInputWrapperProps = filterComponentProps(VaInputWrapperProps3);
    const inputWrapperPropsComputed = computed(() => ({
      ...vaInputWrapperProps.value,
      error: computedError.value,
      errorMessages: computedErrorMessages.value,
      focused: isFocused.value,
      "aria-label": props.ariaLabel || (props.modelValue ? `${t("selectedOption")}: ${props.modelValue}` : t("noSelectedOption"))
    }));
    const selectContentPropsComputed = computed(() => ({
      ...pick$1(props, ["placeholder", "autocomplete", "multiple", "disabled", "readonly"]),
      tabindex: tabIndexComputed.value,
      value: visibleSelectedOptions.value,
      valueString: valueString.value,
      hiddenSelectedOptionsAmount: hiddenSelectedOptionsAmount.value,
      isAllOptionsShown: isAllOptionsShown.value,
      focused: isInputFocused.value,
      autocompleteInputValue: autocompleteValue.value,
      getText: getValueText
    }));
    const autocompleteValue = useAutocomplete(searchVModel, props, visibleSelectedOptions, isOpenSync, getText);
    const setAutocompleteValue = (v) => autocompleteValue.value = v;
    const doShowAllOptions = ref(true);
    watch(showDropdownContentComputed, () => {
      doShowAllOptions.value = true;
    });
    watch(searchVModel, () => {
      doShowAllOptions.value = false;
    });
    const focus = () => {
      if (props.disabled) {
        return;
      }
      focusElement(unwrapEl(input.value));
    };
    const blur = () => {
      if (showDropdownContentComputed.value) {
        showDropdownContentComputed.value = false;
      }
      nextTick(() => {
        if (props.disabled) {
          return;
        }
        blurElement(unwrapEl(input.value));
      });
    };
    const reset = () => withoutValidation(() => {
      if (props.multiple) {
        valueComputed.value = Array.isArray(props.clearValue) ? props.clearValue : [];
      } else {
        valueComputed.value = props.clearValue;
      }
      searchVModel.value = "";
      emit("clear");
      resetValidation();
      nextTick(() => {
        isInputFocused.value = true;
      });
    });
    const focusAutocompleteInput = (e) => {
      if (props.autocomplete && !props.disabled && !props.readonly) {
        e == null ? void 0 : e.stopImmediatePropagation();
        isInputFocused.value = true;
        isOpenSync.value = true;
      }
    };
    const toggleDropdown = (e) => {
      if (props.disabled || props.readonly) {
        return;
      }
      const isInInput = e.target && "tagName" in e.target && e.target.tagName === "INPUT";
      if (e.code === "Space" && isInInput) {
        return;
      }
      e.preventDefault();
      showDropdownContentComputed.value = !showDropdownContentComputed.value;
    };
    const deleteLastSelected = () => {
      if (!Array.isArray(valueComputed.value)) {
        return;
      }
      valueComputed.value = valueComputed.value.slice(0, -1);
    };
    const {
      validate,
      computedError,
      computedErrorMessages,
      withoutValidation,
      resetValidation
    } = useValidation(props, emit, { reset, focus, value: valueComputed });
    const { popupId } = useSelectAria();
    const searchInput = searchVModel;
    const onInputFocus = onFocus;
    __expose({
      focus,
      blur,
      reset
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(VaDropdown), mergeProps({
        ref: "dropdown",
        modelValue: showDropdownContentComputed.value,
        "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => showDropdownContentComputed.value = $event),
        class: "va-select va-select__dropdown va-select-dropdown"
      }, dropdownPropsComputed.value, {
        role: "combobox",
        "inner-anchor-selector": ".va-input-wrapper__field",
        "keyboard-navigation": false
      }), {
        anchor: withCtx(() => [
          createVNode(unref(VaInputWrapper), mergeProps(inputWrapperPropsComputed.value, {
            ref_key: "input",
            ref: input,
            class: ["va-select__anchor va-select-anchor__input", unref(inputWrapperClassComputed)],
            "aria-haspopup": "listbox",
            "model-value": unref(valueString),
            readonly: true,
            "aria-label": _ctx.$props.ariaLabel,
            "aria-controls": unref(popupId),
            "aria-owns": unref(popupId),
            onFocus: unref(onInputFocus),
            onBlur: onInputBlur
          }), createSlots({
            icon: withCtx(() => [
              showClearIcon.value ? (openBlock(), createBlock(unref(VaIcon), mergeProps({
                key: 0,
                role: "button",
                "aria-label": unref(tp)(_ctx.$props.ariaClearLabel)
              }, unref(clearIconProps), {
                onClick: withModifiers(reset, ["stop"]),
                onKeydown: [
                  withKeys(withModifiers(reset, ["stop"]), ["enter"]),
                  withKeys(withModifiers(reset, ["stop"]), ["space"])
                ]
              }), null, 16, ["aria-label", "onKeydown"])) : createCommentVNode("", true)
            ]),
            appendInner: withCtx(() => [
              createVNode(unref(VaIcon), {
                color: unref(toggleIconColor),
                name: unref(toggleIcon),
                class: "va-select__toggle-icon",
                role: "button",
                tabindex: openSelectButtonTabIndexComputed.value,
                "aria-expanded": showDropdownContentComputed.value,
                onKeydown: withKeys(toggleDropdown, ["enter"])
              }, null, 8, ["color", "name", "tabindex", "aria-expanded"])
            ]),
            default: withCtx(({ ariaAttributes }) => [
              createVNode(unref(VaSelectContent), mergeProps(selectContentPropsComputed.value, {
                ariaAttributes,
                separator: _ctx.$props.separator,
                onToggleHidden: unref(toggleHiddenOptionsState),
                onAutocompleteInput: setAutocompleteValue,
                onFocusPrev: focusPreviousOption,
                onFocusNext: focusNextOption,
                onSelectOption: selectOrAddOption,
                onDeleteLastSelected: deleteLastSelected
              }), createSlots({ _: 2 }, [
                renderList(_ctx.$slots, (_, name) => {
                  return {
                    name,
                    fn: withCtx((slotScope) => [
                      renderSlot(_ctx.$slots, name, normalizeProps(guardReactiveProps(slotScope)))
                    ])
                  };
                })
              ]), 1040, ["ariaAttributes", "separator", "onToggleHidden"])
            ]),
            _: 2
          }, [
            renderList(_ctx.$slots, (_, name) => {
              return {
                name,
                fn: withCtx((slotScope) => [
                  renderSlot(_ctx.$slots, name, normalizeProps(guardReactiveProps(slotScope)))
                ])
              };
            })
          ]), 1040, ["class", "model-value", "aria-label", "aria-controls", "aria-owns", "onFocus"])
        ]),
        default: withCtx(() => [
          createVNode(unref(VaDropdownContent), {
            class: "va-select-dropdown__content",
            style: normalizeStyle({ width: _ctx.$props.width }),
            onKeydown: withKeys(hideAndFocus, ["esc"]),
            role: "dialog"
          }, {
            default: withCtx(() => [
              showSearchInput.value ? (openBlock(), createBlock(unref(VaInputWrapper), {
                key: 0,
                ref_key: "searchBar",
                ref: searchBar,
                class: "va-select-dropdown__content-search-input",
                modelValue: unref(searchInput),
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => isRef(searchInput) ? searchInput.value = $event : null),
                "aria-label": unref(tp)(_ctx.$props.ariaSearchLabel),
                tabindex: tabIndexComputed.value,
                placeholder: unref(tp)(_ctx.$props.searchPlaceholderText),
                preset: "bordered",
                onKeydown: [
                  withKeys(withModifiers(focusPreviousOption, ["stop", "prevent"]), ["up"]),
                  withKeys(withModifiers(focusPreviousOption, ["stop", "prevent"]), ["left"]),
                  withKeys(withModifiers(focusNextOption, ["stop", "prevent"]), ["down"]),
                  withKeys(withModifiers(focusNextOption, ["stop", "prevent"]), ["right"]),
                  withKeys(withModifiers(selectOrAddOption, ["prevent"]), ["enter"])
                ],
                onFocus: _cache[1] || (_cache[1] = ($event) => hoveredOption.value = null)
              }, null, 8, ["modelValue", "aria-label", "tabindex", "placeholder", "onKeydown"])) : createCommentVNode("", true),
              createVNode(unref(VaSelectOptionList), mergeProps({
                ref_key: "optionList",
                ref: optionList,
                class: "va-select-dropdown__options-wrapper",
                hoveredOption: hoveredOption.value,
                "onUpdate:hoveredOption": _cache[2] || (_cache[2] = ($event) => hoveredOption.value = $event),
                style: { maxHeight: _ctx.$props.maxHeight },
                id: unref(popupId)
              }, optionsListPropsComputed.value, {
                onSelectOption: selectHoveredOption,
                onNoPreviousOptionToHover: focusSearchBar,
                onKeydown: [
                  _cache[3] || (_cache[3] = withKeys(withModifiers(($event) => searchBar.value && searchBar.value.focus(), ["stop", "prevent"]), ["tab"])),
                  onHintedSearch
                ],
                onScrollBottom
              }), {
                default: withCtx((slotData) => [
                  renderSlot(_ctx.$slots, "option", normalizeProps(guardReactiveProps(slotData)))
                ]),
                "option-content": withCtx((slotData) => [
                  renderSlot(_ctx.$slots, "option-content", normalizeProps(guardReactiveProps(slotData)))
                ]),
                _: 3
              }, 16, ["hoveredOption", "style", "id"])
            ]),
            _: 3
          }, 8, ["style"])
        ]),
        _: 3
      }, 16, ["modelValue"]);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-select/VaSelect.js
var _style_084 = ":root,\n:host {\n  --va-select-cursor: pointer;\n  --va-select-dropdown-background: var(--va-background-secondary);\n  --va-select-state-icon-margin-left: 0.25rem;\n}\n.va-select .va-input-wrapper__text {\n  line-height: normal;\n  flex-wrap: wrap;\n}\n.va-select-anchor__input {\n  cursor: var(--va-select-cursor);\n  flex: 1;\n}\n.va-select-anchor--nowrap .va-input-wrapper__text {\n  flex-wrap: nowrap;\n}\n.va-select-dropdown__content {\n  overflow: hidden;\n  border-top-right-radius: 0;\n  border-top-left-radius: 0;\n  padding: 0;\n}\n.va-select-dropdown__content-search-input {\n  min-width: auto;\n  width: 100%;\n}\n.va-select-dropdown__options-wrapper {\n  background: var(--va-select-dropdown-background);\n  overflow-y: auto;\n  scrollbar-color: var(--va-background-element) transparent;\n  scrollbar-width: thin;\n  transition: scrollbar-color 0.3s ease-in-out;\n}\n.va-select-dropdown__options-wrapper::-webkit-scrollbar {\n  width: 4px;\n  height: 4px;\n}\n.va-select-dropdown__options-wrapper::-webkit-scrollbar-track {\n  box-shadow: none;\n  border-radius: 10px;\n}\n.va-select-dropdown__options-wrapper::-webkit-scrollbar-thumb {\n  background: var(--va-background-element);\n  opacity: 0.3;\n  border-radius: 2px;\n  -webkit-transition: background 0.3s ease-in-out;\n  transition: background 0.3s ease-in-out;\n}";
var _VaSelect = _export_sfc(_sfc_main90, [["styles", [_style_084]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-select/index.js
var VaSelect = withConfigTransport$1(_VaSelect);

// node_modules/vuestic-ui/dist/web-components/src/components/va-separator/VaSeparator.vue_vue_type_script_setup_true_lang.js
var _hoisted_156 = {
  class: "va-separator",
  "aria-hidden": "true"
};
var _sfc_main91 = defineComponent({
  ...{
    name: "VaSeparator"
  },
  __name: "VaSeparator",
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_156);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-separator/VaSeparator.js
var _style_085 = ":root,\n:host {\n  --va-separator-height: 1px;\n  --va-separator-background-color: var(--va-divider);\n  --va-separator-margin-top: 1rem;\n  --va-separator-margin-bottom: 1rem;\n}\n.va-separator {\n  height: var(--va-separator-height);\n  background-color: var(--va-separator-background-color);\n  margin-top: var(--va-separator-margin-top);\n  margin-bottom: var(--va-separator-margin-bottom);\n}\n.va-tabs + .va-separator {\n  margin-top: 0;\n}\n.va-card :is(.va-card__title, .va-card__content, .va-card__actions, .va-card_actions__vertical) > .va-separator {\n  margin-right: calc(-1 * var(--va-card-padding));\n  margin-left: calc(-1 * var(--va-card-padding));\n}";
var VaSeparator = _export_sfc(_sfc_main91, [["styles", [_style_085]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-skeleton/VaSkeleton.vue_vue_type_script_setup_true_lang.js
var _hoisted_157 = {
  key: 0,
  class: "va-skeleton__wave"
};
var _sfc_main92 = defineComponent({
  ...{
    name: "VaSkeleton"
  },
  __name: "VaSkeleton",
  props: {
    color: { type: String, default: "backgroundElement" },
    delay: { type: Number, default: 100 },
    tag: { type: String, default: "div" },
    animation: { type: String, default: "pulse" },
    lines: { type: [String, Number], default: 1 },
    height: { type: [String], default: "5em" },
    width: { type: [String], default: "100%" },
    lineGap: { type: String, default: "8px" },
    lastLineWidth: { type: [String], default: "75%" },
    variant: { type: String, default: "squared" },
    ariaLabel: { type: String, default: "$t:loading" }
  },
  setup(__props) {
    useCssVars((_ctx) => ({
      "12edfaa0": colorComputed.value,
      "d6fa8398": heightComputed.value,
      "838e23da": widthComputed.value,
      "672814be": borderRadius.value,
      "370c653c": __props.lineGap,
      "2b230148": __props.lastLineWidth
    }));
    const props = __props;
    const doShow = ref(false);
    let timeoutId;
    onMounted(() => {
      clearTimeout(timeoutId);
      setTimeout(() => {
        doShow.value = true;
      }, props.delay);
    });
    onBeforeUnmount(() => {
      clearTimeout(timeoutId);
    });
    const heightComputed = computed(() => {
      if (props.variant === "text") {
        return `${props.lines}em`;
      }
      return props.height;
    });
    const widthComputed = computed(() => {
      if (props.variant === "circle") {
        return heightComputed.value;
      }
      return props.width;
    });
    const { getColor } = useColors();
    const colorComputed = computed(() => getColor(props.color));
    computed(() => `-${props.lineGap}`);
    const bem = useBem("va-skeleton", () => ({
      lines: Number(props.lines) > 1,
      text: props.variant === "text",
      circle: props.variant === "circle",
      hidden: !doShow.value,
      pulse: props.animation === "pulse",
      wave: props.animation === "wave"
    }));
    const borderRadius = computed(() => {
      if (props.variant === "circle") {
        return "50%";
      }
      if (props.variant === "rounded") {
        return `var(--va-skeleton-border-radius, calc(${heightComputed.value} / 5))`;
      }
      return "0px";
    });
    const { tp } = useTranslation();
    const attrs = useAttrs();
    const classes = computed(() => [
      ...Object.keys(bem),
      attrs.class
    ]);
    return (_ctx, _cache) => {
      return openBlock(), createBlock(resolveDynamicComponent(__props.tag), {
        class: normalizeClass(["va-skeleton", classes.value]),
        role: "status",
        "aria-live": "polite",
        "aria-label": unref(tp)(_ctx.$props.ariaLabel),
        "aria-atomic": "true"
      }, {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default"),
          __props.animation === "wave" ? (openBlock(), createElementBlock("div", _hoisted_157)) : createCommentVNode("", true)
        ]),
        _: 3
      }, 8, ["aria-label", "class"]);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-skeleton/VaSkeleton.js
var _style_086 = ':root,\n:host {\n  --va-skeleton-wave-color: rgb(100, 100, 100);\n  --va-skeleton-wave-opacity: 0.2;\n  --va-skeleton-border-radius: unset;\n  --va-skeleton-animation-duration: 2.5s;\n}\n@keyframes pulse {\n0% {\n    filter: brightness(1);\n}\n50% {\n    filter: brightness(1);\n}\n75% {\n    filter: brightness(0.9);\n}\n100% {\n    filter: brightness(1);\n}\n}\n@keyframes wave {\n0% {\n    left: -100%;\n}\n100% {\n    left: 100%;\n}\n}\n.va-skeleton {\n  background: var(--12edfaa0);\n  height: var(--d6fa8398);\n  width: var(--838e23da);\n  border-radius: var(--672814be);\n  cursor: wait;\n}\n.va-skeleton--pulse {\n  animation: var(--va-skeleton-animation-duration) ease-in-out 0s infinite normal none running pulse;\n}\n.va-skeleton--wave {\n  -webkit-mask-image: -webkit-radial-gradient(white, black);\n          mask-image: -webkit-radial-gradient(white, black);\n}\n.va-skeleton--wave .va-skeleton__wave {\n  position: absolute;\n  overflow: hidden;\n  left: 0;\n  height: 100%;\n  width: 100%;\n}\n.va-skeleton--wave .va-skeleton__wave::after {\n  display: block;\n  position: relative;\n  content: "";\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 100%;\n  opacity: var(--va-skeleton-wave-opacity, 0.5);\n  background: linear-gradient(90deg, transparent, var(--va-skeleton-wave-color), transparent);\n  animation: var(--va-skeleton-animation-duration) linear 0s infinite normal none running wave;\n}\n.va-skeleton--hidden {\n  position: absolute;\n  overflow: hidden;\n  clip: rect(0 0 0 0);\n  height: 1px;\n  width: 1px;\n  margin: -1px;\n  padding: 0;\n  border: 0;\n}\n.va-skeleton--lines {\n  background: repeating-linear-gradient(180deg, var(--12edfaa0), var(--12edfaa0) calc(1em - var(--370c653c) / 2), transparent calc(1em - var(--370c653c) / 2), transparent 1em);\n}\n.va-skeleton--lines .va-skeleton__wave::after {\n  -webkit-mask-image: repeating-linear-gradient(180deg, black, black calc(1em - var(--370c653c) / 2), transparent calc(1em - var(--370c653c) / 2), transparent 1em);\n          mask-image: repeating-linear-gradient(180deg, black, black calc(1em - var(--370c653c) / 2), transparent calc(1em - var(--370c653c) / 2), transparent 1em);\n}\n.va-skeleton--text {\n  width: 100%;\n  -webkit-clip-path: polygon(0% 0%, 0% 100%, var(--2b230148) 100%, var(--2b230148) calc(100% - 1em), 100% calc(100% - 1em), 100% 100%, 1em 100%, var(--2b230148) 100%, 100% 100%, 100% 0%);\n          clip-path: polygon(0% 0%, 0% 100%, var(--2b230148) 100%, var(--2b230148) calc(100% - 1em), 100% calc(100% - 1em), 100% 100%, 1em 100%, var(--2b230148) 100%, 100% 100%, 100% 0%);\n}\n.va-skeleton--circle {\n  min-width: var(--838e23da);\n  min-height: var(--d6fa8398);\n}';
var _VaSkeleton = _export_sfc(_sfc_main92, [["styles", [_style_086]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-skeleton/components/VaSkeletonGroup.vue_vue_type_script_setup_true_lang.js
var _sfc_main93 = defineComponent({
  ...{
    name: "VaSkeletonGroup"
  },
  __name: "VaSkeletonGroup",
  props: {
    color: { type: String, default: "backgroundElement" },
    delay: { type: Number, default: 100 },
    animation: { type: String, default: "pulse" },
    lines: { type: Number, default: 1 },
    lineGap: { type: String, default: "8px" },
    lastLineWidth: { type: [String], default: "75%" }
  },
  setup(__props) {
    const props = __props;
    const doShow = ref(false);
    let timeoutId;
    onMounted(() => {
      timeoutId = setTimeout(() => {
        doShow.value = true;
      }, props.delay);
    });
    onBeforeMount(() => {
      clearTimeout(timeoutId);
    });
    const bem = useBem("va-skeleton-group", () => ({
      hidden: doShow.value === false
    }));
    const config = computed(() => ({ ...props, delay: 0 }));
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(_sfc_main), {
        components: { VaSkeleton: config.value }
      }, {
        default: withCtx(() => [
          createBaseVNode("div", mergeProps({
            class: ["va-skeleton-group", unref(bem)]
          }, _ctx.$attrs), [
            renderSlot(_ctx.$slots, "default", {}, void 0, true)
          ], 16)
        ]),
        _: 3
      }, 8, ["components"]);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-skeleton/components/VaSkeletonGroup.js
var _style_087 = ".va-skeleton-group[data-v-c27755d1] {\n  position: relative;\n  cursor: progress;\n}\n.va-skeleton-group--hidden[data-v-c27755d1] {\n  display: none;\n}";
var _VaSkeletonGroup = _export_sfc(_sfc_main93, [["styles", [_style_087]], ["__scopeId", "data-v-c27755d1"]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-skeleton/index.js
var VaSkeleton = withConfigTransport$1(_VaSkeleton);
var VaSkeletonGroup = withConfigTransport$1(_VaSkeletonGroup);

// node_modules/vuestic-ui/dist/web-components/src/components/va-sidebar/hooks/useSidebar.js
var VaSidebarKey = Symbol("VaSidebar");
var useSidebar = (props) => {
  provide(VaSidebarKey, props);
};
var useSidebarItem = () => {
  return inject(VaSidebarKey, {
    color: "background-element"
    // activeColor: 'primary',
  });
};

// node_modules/vuestic-ui/dist/web-components/src/composables/useElementWidth.js
var useElementWidth = (el) => {
  const width = ref(null);
  useResizeObserver([el], () => {
    var _a2;
    width.value = ((_a2 = el.value) == null ? void 0 : _a2.clientWidth) ?? null;
  });
  watchEffect(() => {
    var _a2;
    width.value = ((_a2 = el.value) == null ? void 0 : _a2.clientWidth) ?? null;
  });
  return width;
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-sidebar/VaSidebar.vue_vue_type_script_setup_true_lang.js
var _sfc_main94 = defineComponent({
  ...{
    name: "VaSidebar"
  },
  __name: "VaSidebar",
  props: {
    ...useComponentPresetProp,
    activeColor: { type: String, default: "primary" },
    hoverColor: { type: String, default: void 0 },
    hoverOpacity: {
      type: Number,
      default: 0.2,
      validator: (v) => v >= 0 && v <= 1
    },
    borderColor: { type: String, default: void 0 },
    color: { type: String, default: "background-element" },
    textColor: { type: String },
    gradient: { type: Boolean, default: false },
    minimized: { type: Boolean, default: false },
    hoverable: { type: Boolean, default: false },
    width: { type: String, default: "16rem" },
    minimizedWidth: { type: String, default: "4rem" },
    modelValue: { type: Boolean, default: true },
    animated: { type: [Boolean, String], default: true },
    closeOnClickOutside: { type: Boolean, default: false }
  },
  emits: ["update:modelValue"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const { getColor } = useColors();
    useSidebar(props);
    const isHovered = ref(false);
    const isMinimized = computed(() => props.minimized || props.hoverable && !isHovered.value);
    const menu = ref();
    const currentMenuWidth = useElementWidth(menu);
    const doShowMenu = computed(() => {
      if (props.modelValue === true) {
        return true;
      }
      if (currentMenuWidth.value === null) {
        return true;
      }
      return currentMenuWidth.value > 0;
    });
    const sidebarWidth = ref();
    const getSidebarWidth = () => {
      if (!props.modelValue) {
        return 0;
      }
      return isMinimized.value ? props.minimizedWidth : props.width;
    };
    const menuWidth = computed(() => isMinimized.value ? props.minimizedWidth : props.width);
    watchEffect(() => {
      const width = getSidebarWidth();
      setTimeout(() => {
        sidebarWidth.value = width;
      });
    });
    const backgroundColorComputed = computed(() => getColor(props.color));
    const { textColorComputed } = useTextColor(backgroundColorComputed);
    const computedStyle = computed(() => {
      const backgroundColor = getColor(backgroundColorComputed.value);
      const color = textColorComputed.value;
      return {
        color,
        backgroundColor,
        backgroundImage: props.gradient ? getGradientBackground(backgroundColor) : void 0,
        overflowX: currentMenuWidth.value === sidebarWidth.value ? void 0 : "hidden",
        width: sidebarWidth.value,
        minWidth: sidebarWidth.value
      };
    });
    const computedClass = useBem("va-sidebar", () => ({
      minimized: isMinimized.value,
      animated: Boolean(props.animated),
      "animated-right": props.animated === "right",
      "animated-left": props.animated === "left" || props.animated === true
    }));
    const updateHoverState = (newHoverState) => {
      isHovered.value = props.hoverable && newHoverState;
    };
    const rootElement = shallowRef();
    useClickOutside([rootElement], () => {
      if (props.closeOnClickOutside && props.modelValue) {
        setTimeout(() => {
          emit("update:modelValue", false);
        }, 0);
      }
    });
    const vaSidebarItemProps = computed(() => ({
      textColor: props.textColor,
      activeColor: props.activeColor,
      hoverColor: props.hoverColor,
      borderColor: props.borderColor,
      hoverOpacity: props.hoverOpacity
    }));
    __expose({
      isMinimized,
      isHovered,
      updateHoverState,
      rootElement,
      menu,
      doShowMenu,
      menuWidth,
      sidebarWidth
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("aside", {
        ref_key: "rootElement",
        ref: rootElement,
        class: normalizeClass(["va-sidebar", unref(computedClass)]),
        style: normalizeStyle(computedStyle.value),
        onMouseenter: _cache[0] || (_cache[0] = ($event) => updateHoverState(true)),
        onMouseleave: _cache[1] || (_cache[1] = ($event) => updateHoverState(false))
      }, [
        withDirectives(createBaseVNode("div", {
          class: "va-sidebar__menu",
          ref_key: "menu",
          ref: menu,
          style: normalizeStyle({
            width: menuWidth.value,
            minWidth: menuWidth.value
          })
        }, [
          createVNode(unref(_sfc_main), {
            components: { VaSidebarItem: vaSidebarItemProps.value }
          }, {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "default")
            ]),
            _: 3
          }, 8, ["components"])
        ], 4), [
          [vShow, doShowMenu.value]
        ])
      ], 38);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-sidebar/VaSidebar.js
var _style_088 = ":root,\n:host {\n  --va-sidebar-min-height: 100%;\n  --va-sidebar-height: 100%;\n  --va-sidebar-position: relative;\n  --va-sidebar-top: 0;\n  --va-sidebar-left: 0;\n  --va-sidebar-transition: var(--va-transition);\n  --va-sidebar-z-index: 1;\n  /* Menu */\n  --va-sidebar-menu-max-height: 100%;\n  --va-sidebar-menu-margin-bottom: 0;\n  --va-sidebar-menu-list-style: none;\n  --va-sidebar-menu-padding-left: 0;\n  --va-sidebar-menu-overflow-y: auto;\n  --va-sidebar-menu-overflow-x: visible;\n  /* SidebarItem */\n  --va-sidebar-item-active-border-size: 4px;\n  --va-sidebar-item-transition: var(--va-transition);\n  /* SidebarItemContent */\n  --va-sidebar-item-content-padding: 1rem;\n  --va-sidebar-item-content-gap: 0.5rem;\n  /* SidebarItemTitle */\n  --va-sidebar-item-title-white-space: nowrap;\n}\n.va-sidebar {\n  min-height: var(--va-sidebar-min-height);\n  height: var(--va-sidebar-height);\n  z-index: var(--va-sidebar-z-index);\n  font-family: var(--va-font-family);\n  display: inline-flex;\n  box-sizing: border-box;\n  position: relative;\n  top: 0;\n}\n.va-sidebar__menu {\n  display: flex;\n  flex-direction: column;\n  min-width: 100%;\n  flex: 1;\n  height: 100%;\n  right: 0;\n  max-height: var(--va-sidebar-menu-max-height);\n  overflow-y: var(--va-sidebar-menu-overflow-y);\n  overflow-x: var(--va-sidebar-menu-overflow-x);\n  margin-left: auto;\n  scrollbar-color: var(--va-secondary) transparent;\n  scrollbar-width: thin;\n  transition: scrollbar-color 0.3s ease-in-out;\n}\n.va-sidebar__menu::-webkit-scrollbar {\n  width: 4px;\n  height: 4px;\n}\n.va-sidebar__menu::-webkit-scrollbar-track {\n  box-shadow: none;\n  border-radius: 10px;\n}\n.va-sidebar__menu::-webkit-scrollbar-thumb {\n  background: var(--va-secondary);\n  opacity: 0.3;\n  border-radius: 2px;\n  -webkit-transition: background 0.3s ease-in-out;\n  transition: background 0.3s ease-in-out;\n}\n.va-sidebar--animated {\n  transition: var(--va-sidebar-transition);\n}\n.va-sidebar--animated .va-sidebar__menu {\n  transition: var(--va-sidebar-transition);\n}\n.va-sidebar--animated-right {\n  justify-content: flex-end;\n}\n.va-sidebar--animated-left {\n  justify-content: flex-start;\n}\n.va-sidebar--minimized {\n  left: 0;\n}\n.va-sidebar--minimized .va-sidebar__title {\n  display: none;\n}";
var _VaSidebar = _export_sfc(_sfc_main94, [["styles", [_style_088]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-sidebar/index.js
var VaSidebar = withConfigTransport$1(_VaSidebar);

// node_modules/vuestic-ui/dist/web-components/src/components/va-sidebar/VaSidebarItem/VaSidebarItem.vue_vue_type_script_setup_true_lang.js
var _sfc_main95 = defineComponent({
  ...{
    name: "VaSidebarItem"
  },
  __name: "VaSidebarItem",
  props: {
    ...useRouterLinkProps,
    ...useComponentPresetProp,
    active: { type: Boolean, default: false },
    textColor: { type: String, default: void 0 },
    activeColor: { type: String, default: "primary" },
    hoverColor: { type: String, default: void 0 },
    hoverOpacity: { type: [Number, String], default: 0.2 },
    borderColor: { type: String, default: void 0 }
  },
  setup(__props) {
    const props = __props;
    const rootElement = useElementRef();
    const sidebar = useSidebarItem();
    const { isHovered } = useHover(rootElement);
    const { getColor, getHoverColor: getHoverColor2, getFocusColor: getFocusColor2 } = useColors();
    const { hasKeyboardFocus, keyboardFocusListeners } = useKeyboardOnlyFocus();
    const backgroundColorComputed = computed(() => {
      if (props.active && !isHovered.value && !hasKeyboardFocus.value) {
        return getColor(props.activeColor);
      }
      if (hasKeyboardFocus.value) {
        return getFocusColor2(getColor(props.hoverColor || props.activeColor));
      }
      return "#ffffff00";
    });
    const textBackground = computed(() => applyColors(getColor(sidebar == null ? void 0 : sidebar.color), backgroundColorComputed.value));
    const { textColorComputed } = useTextColor(textBackground);
    const computedStyle = computed(() => {
      const style = { color: textColorComputed.value };
      if (isHovered.value || props.active || hasKeyboardFocus.value) {
        style.backgroundColor = backgroundColorComputed.value;
      }
      if (props.active) {
        const mergedProps = { ...sidebar, ...props };
        style.borderColor = getColor(mergedProps.borderColor || mergedProps.activeColor);
      }
      if (hasKeyboardFocus.value) {
        style.backgroundColor = getFocusColor2(getColor(props.hoverColor || props.activeColor));
      }
      if (isHovered.value) {
        style.backgroundColor = getHoverColor2(
          getColor(props.hoverColor || props.activeColor),
          Number(props.hoverOpacity)
        );
      }
      return style;
    });
    const { tagComputed, hrefComputed, linkAttributesComputed } = useRouterLink(props);
    getColor(sidebar == null ? void 0 : sidebar.color);
    return (_ctx, _cache) => {
      return openBlock(), createBlock(resolveDynamicComponent(unref(tagComputed)), mergeProps({
        ref_key: "rootElement",
        ref: rootElement,
        class: ["va-sidebar__item va-sidebar-item", { "va-sidebar-item--active": _ctx.$props.active }],
        tabindex: "0",
        style: computedStyle.value
      }, unref(linkAttributesComputed), toHandlers(unref(keyboardFocusListeners))), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16, ["class", "style"]);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-sidebar/VaSidebarItem/VaSidebarItem.js
var _style_089 = ':root,\n:host {\n  --va-sidebar-min-height: 100%;\n  --va-sidebar-height: 100%;\n  --va-sidebar-position: relative;\n  --va-sidebar-top: 0;\n  --va-sidebar-left: 0;\n  --va-sidebar-transition: var(--va-transition);\n  --va-sidebar-z-index: 1;\n  /* Menu */\n  --va-sidebar-menu-max-height: 100%;\n  --va-sidebar-menu-margin-bottom: 0;\n  --va-sidebar-menu-list-style: none;\n  --va-sidebar-menu-padding-left: 0;\n  --va-sidebar-menu-overflow-y: auto;\n  --va-sidebar-menu-overflow-x: visible;\n  /* SidebarItem */\n  --va-sidebar-item-active-border-size: 4px;\n  --va-sidebar-item-transition: var(--va-transition);\n  /* SidebarItemContent */\n  --va-sidebar-item-content-padding: 1rem;\n  --va-sidebar-item-content-gap: 0.5rem;\n  /* SidebarItemTitle */\n  --va-sidebar-item-title-white-space: nowrap;\n}\n.va-sidebar-item {\n  border-left: var(--va-sidebar-item-active-border-size) solid transparent;\n  padding-right: var(--va-sidebar-item-active-border-size);\n  display: inline-block;\n  width: 100%;\n  font-family: var(--va-font-family);\n  transition: var(--va-sidebar-item-transition);\n  box-sizing: border-box;\n  color: currentColor;\n  cursor: pointer;\n}\n.va-sidebar-item:focus-visible {\n  outline: 2px solid var(--va-focus) !important;\n  border-radius: "inherit";\n  outline-offset: -2px;\n}';
var _VaSidebarItem = _export_sfc(_sfc_main95, [["styles", [_style_089]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-sidebar/VaSidebarItem/VaSidebarItemContent.vue_vue_type_script_setup_true_lang.js
var _hoisted_158 = { class: "va-sidebar__item__content va-sidebar-item-content" };
var _sfc_main96 = defineComponent({
  ...{
    name: "VaSidebarItemContent"
  },
  __name: "VaSidebarItemContent",
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_158, [
        renderSlot(_ctx.$slots, "default")
      ]);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-sidebar/VaSidebarItem/VaSidebarItemContent.js
var _style_090 = ":root,\n:host {\n  --va-sidebar-min-height: 100%;\n  --va-sidebar-height: 100%;\n  --va-sidebar-position: relative;\n  --va-sidebar-top: 0;\n  --va-sidebar-left: 0;\n  --va-sidebar-transition: var(--va-transition);\n  --va-sidebar-z-index: 1;\n  /* Menu */\n  --va-sidebar-menu-max-height: 100%;\n  --va-sidebar-menu-margin-bottom: 0;\n  --va-sidebar-menu-list-style: none;\n  --va-sidebar-menu-padding-left: 0;\n  --va-sidebar-menu-overflow-y: auto;\n  --va-sidebar-menu-overflow-x: visible;\n  /* SidebarItem */\n  --va-sidebar-item-active-border-size: 4px;\n  --va-sidebar-item-transition: var(--va-transition);\n  /* SidebarItemContent */\n  --va-sidebar-item-content-padding: 1rem;\n  --va-sidebar-item-content-gap: 0.5rem;\n  /* SidebarItemTitle */\n  --va-sidebar-item-title-white-space: nowrap;\n}\n.va-sidebar__item__content {\n  display: flex;\n  align-items: center;\n  padding: var(--va-sidebar-item-content-padding);\n  min-height: 58px;\n  box-sizing: border-box;\n}\n.va-sidebar__item__content > * {\n  margin-right: var(--va-sidebar-item-content-gap);\n}\n.va-sidebar__item__content > *:last-child {\n  margin-right: 0;\n}";
var _VaSidebarItemContent = _export_sfc(_sfc_main96, [["styles", [_style_090]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-sidebar/VaSidebarItem/VaSidebarItemTitle.vue_vue_type_script_setup_true_lang.js
var _hoisted_159 = { class: "va-sidebar__title va-sidebar-item-title" };
var _sfc_main97 = defineComponent({
  ...{
    name: "VaSidebarItemTitle"
  },
  __name: "VaSidebarItemTitle",
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_159, [
        renderSlot(_ctx.$slots, "default")
      ]);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-sidebar/VaSidebarItem/VaSidebarItemTitle.js
var _style_091 = ":root,\n:host {\n  --va-sidebar-min-height: 100%;\n  --va-sidebar-height: 100%;\n  --va-sidebar-position: relative;\n  --va-sidebar-top: 0;\n  --va-sidebar-left: 0;\n  --va-sidebar-transition: var(--va-transition);\n  --va-sidebar-z-index: 1;\n  /* Menu */\n  --va-sidebar-menu-max-height: 100%;\n  --va-sidebar-menu-margin-bottom: 0;\n  --va-sidebar-menu-list-style: none;\n  --va-sidebar-menu-padding-left: 0;\n  --va-sidebar-menu-overflow-y: auto;\n  --va-sidebar-menu-overflow-x: visible;\n  /* SidebarItem */\n  --va-sidebar-item-active-border-size: 4px;\n  --va-sidebar-item-transition: var(--va-transition);\n  /* SidebarItemContent */\n  --va-sidebar-item-content-padding: 1rem;\n  --va-sidebar-item-content-gap: 0.5rem;\n  /* SidebarItemTitle */\n  --va-sidebar-item-title-white-space: nowrap;\n}\n.va-sidebar__title {\n  flex-grow: 1;\n  white-space: var(--va-sidebar-item-title-white-space);\n  transition: opacity 0.2s ease-in-out;\n}";
var _VaSidebarItemTitle = _export_sfc(_sfc_main97, [["styles", [_style_091]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-sidebar/VaSidebarItem/index.js
var VaSidebarItemContent = withConfigTransport$1(_VaSidebarItemContent);
var VaSidebarItemTitle = withConfigTransport$1(_VaSidebarItemTitle);
var VaSidebarItem = withConfigTransport$1(_VaSidebarItem);

// node_modules/vuestic-ui/dist/web-components/src/components/va-slider/validateSlider.js
var validateSlider = (value, step, min, max, range) => {
  if (Array.isArray(value) && !range || !Array.isArray(value) && range) {
    warn(`The type "${Array.isArray(value) ? "array" : typeof value}" of prop "model-value" does not match prop "range = ${range}".`);
  }
  if (max < min) {
    warn(`The maximum value (${max}) can not be less than the minimum value (${min}).`);
  }
  if ((max - min) % step !== 0) {
    warn(`Step ${step} is illegal. Slider is non-divisible (Min:Max-${min}:${max}).`);
  }
  const inRange = (v) => {
    if (v < min) {
      warn(`The value of the slider is ${v}, the minimum value is ${min}, the value of this slider can not be less than the minimum value`);
    } else if (v > max) {
      warn(`The value of the slider is ${v}, the maximum value is ${max}, the value of this slider can not be greater than the maximum value`);
    }
  };
  if (Array.isArray(value)) {
    value.map(inRange);
  } else {
    inRange(value);
  }
  return true;
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-slider/VaSlider.vue_vue_type_script_setup_true_lang.js
var _hoisted_160 = {
  key: 0,
  class: "va-slider__input-wrapper",
  "aria-hidden": "true"
};
var _hoisted_230 = ["id"];
var _hoisted_320 = {
  key: 2,
  class: "va-input__label",
  "aria-hidden": "true"
};
var _hoisted_411 = ["tabindex", "onFocus"];
var _hoisted_59 = ["tabindex"];
var _hoisted_66 = {
  key: 3,
  class: "va-input__label--inverse",
  "aria-hidden": "true"
};
var _hoisted_74 = ["id"];
var _hoisted_82 = {
  key: 5,
  class: "va-slider__input-wrapper"
};
var _sfc_main98 = defineComponent({
  ...{
    name: "VaSlider"
  },
  __name: "VaSlider",
  props: {
    ...useStatefulProps,
    ...useComponentPresetProp,
    range: { type: Boolean, default: false },
    modelValue: { type: [Number, Array], default: 0 },
    trackLabel: { type: [Function, String] },
    color: { type: String, default: "primary" },
    trackColor: { type: String, default: "" },
    labelColor: { type: String, default: "" },
    trackLabelVisible: { type: Boolean, default: false },
    min: { type: Number, default: 0 },
    max: { type: Number, default: 100 },
    step: { type: Number, default: 1 },
    label: { type: String, default: "" },
    invertLabel: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false },
    readonly: { type: Boolean, default: false },
    pins: { type: Boolean, default: false },
    iconPrepend: { type: String, default: "" },
    iconAppend: { type: String, default: "" },
    vertical: { type: Boolean, default: false },
    showTrack: { type: Boolean, default: true },
    ariaLabel: { type: String, default: "$t:sliderValue" }
  },
  emits: ["drag-start", "drag-end", "change", "update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const { getColor, getHoverColor: getHoverColor2 } = useColors();
    const sliderContainer = shallowRef();
    const dot = shallowRef();
    const { setItemRefByIndex, itemRefs: dots } = useArrayRefs();
    const isFocused = ref(false);
    const flag = ref(false);
    const offset2 = ref(0);
    const size2 = ref(0);
    const defaultValue = props.range ? [0, 100] : 0;
    const { valueComputed } = useStateful(props, emit, "modelValue", { defaultValue });
    const currentSliderDotIndex = ref(0);
    const hasMouseDown = ref(false);
    const orders = computed(() => props.vertical ? [1, 0] : [0, 1]);
    const pinPositionStyle = computed(() => props.vertical ? "bottom" : "left");
    const trackSizeStyle = computed(() => props.vertical ? "height" : "width");
    const moreToLess = computed(() => Array.isArray(val.value) && val.value[1] - props.step < val.value[0]);
    const lessToMore = computed(() => Array.isArray(val.value) && val.value[0] + props.step > val.value[1]);
    const sliderClass = useBem("va-slider", () => ({
      ...pick$1(props, ["disabled", "readonly", "vertical"]),
      active: isFocused.value,
      horizontal: !props.vertical,
      grabbing: hasMouseDown.value
    }));
    const dotClass = useBem("va-slider__handler", () => ({
      onFocus: !props.range && (flag.value || isFocused.value),
      inactive: !isFocused.value
    }));
    const labelStyles = computed(() => ({
      color: props.labelColor ? getColor(props.labelColor) : getColor(props.color)
    }));
    const trackStyles = computed(() => ({
      backgroundColor: props.trackColor ? getColor(props.trackColor) : getHoverColor2(getColor(props.color))
    }));
    const processedStyles = computed(() => {
      if (Array.isArray(val.value)) {
        const val0 = (val.value[0] - props.min) / (props.max - props.min) * 100;
        const val1 = (val.value[1] - props.min) / (props.max - props.min) * 100;
        return {
          [pinPositionStyle.value]: `${val0}%`,
          [trackSizeStyle.value]: `${val1 - val0}%`,
          backgroundColor: getColor(props.color),
          visibility: props.showTrack ? "visible" : "hidden"
        };
      } else {
        const val0 = (val.value - props.min) / (props.max - props.min) * 100;
        return {
          [trackSizeStyle.value]: `${val0}%`,
          backgroundColor: getColor(props.color),
          visibility: props.showTrack ? "visible" : "hidden"
        };
      }
    });
    const dottedStyles = computed(() => {
      if (Array.isArray(val.value)) {
        const val0 = (val.value[0] - props.min) / (props.max - props.min) * 100;
        const val1 = (val.value[1] - props.min) / (props.max - props.min) * 100;
        return [
          {
            [pinPositionStyle.value]: `${val0}%`,
            backgroundColor: isActiveDot(0) ? getColor(props.color) : "#ffffff",
            borderColor: getColor(props.color)
          },
          {
            [pinPositionStyle.value]: `${val1}%`,
            backgroundColor: isActiveDot(1) ? getColor(props.color) : "#ffffff",
            borderColor: getColor(props.color)
          }
        ];
      } else {
        const val0 = (val.value - props.min) / (props.max - props.min) * 100;
        return {
          [pinPositionStyle.value]: `${val0}%`,
          backgroundColor: isActiveDot(0) ? getColor(props.color) : "#ffffff",
          borderColor: getColor(props.color)
        };
      }
    });
    const getDottedStyles = (index) => props.range ? dottedStyles.value[index] : dottedStyles.value;
    const val = computed({
      get: () => valueComputed.value,
      set: (val2) => {
        if (!flag.value) {
          emit("change", val2);
        }
        valueComputed.value = val2;
      }
    });
    const getValueByOrder = (order) => props.range && order !== void 0 ? val.value[order] : val.value;
    const gap = computed(() => {
      const total = (props.max - props.min) / props.step;
      return size2.value / total;
    });
    const multiple = computed(() => {
      const decimals = `${props.step}`.split(".")[1];
      return decimals ? Math.pow(10, decimals.length) : 1;
    });
    const pinsCol = computed(() => (props.max - props.min) / props.step - 1);
    const position = computed(() => {
      return Array.isArray(val.value) ? [(val.value[0] - props.min) / props.step * gap.value, (val.value[1] - props.min) / props.step * gap.value] : (val.value - props.min) / props.step * gap.value;
    });
    const limit = computed(() => [0, size2.value]);
    const valueLimit = computed(() => [props.min, props.max]);
    const isActiveDot = (index) => {
      if (!isFocused.value && !flag.value || props.disabled || props.readonly) {
        return false;
      }
      return props.range ? currentSliderDotIndex.value === index : currentSliderDotIndex.value === 0;
    };
    const moveStart = (e, index = currentSliderDotIndex.value) => {
      var _a2, _b;
      e.preventDefault();
      if (!index) {
        if (!props.range) {
          index = 0;
        } else if (Array.isArray(position.value)) {
          const touch = "touches" in e ? e.touches[0] : e;
          const pos = getPos(touch);
          index = pos > (position.value[1] - position.value[0]) / 2 + position.value[0] ? 1 : 0;
        }
      }
      if (Array.isArray(val.value)) {
        currentSliderDotIndex.value = index;
      }
      Array.isArray(val.value) ? (_a2 = dots.value[index]) == null ? void 0 : _a2.focus() : (_b = dot.value) == null ? void 0 : _b.focus();
      flag.value = true;
      emit("drag-start");
    };
    const moving = (e) => {
      if (!hasMouseDown.value || !flag.value || props.disabled || props.readonly) {
        return;
      }
      e.preventDefault();
      if ("touches" in e) {
        setValueOnPos(getPos(e.touches[0]));
      } else {
        setValueOnPos(getPos(e));
      }
    };
    const moveEnd = () => {
      if (!props.disabled && !props.readonly) {
        if (flag.value) {
          emit("drag-end");
          emit("change", val.value);
        }
        flag.value = false;
        hasMouseDown.value = false;
      }
    };
    const clamp2 = (min, v, max) => Math.max(Math.min(v, max), min);
    const moveWithKeys = (event) => {
      var _a2, _b;
      if (![dots.value[0], dots.value[1], dot.value].includes(document.activeElement)) {
        return;
      }
      if (props.disabled || props.readonly) {
        return;
      }
      const moveDot = (where, which) => {
        if (Array.isArray(val.value)) {
          const value = val.value[which] + (where ? props.step : -props.step);
          const limitedValue = clamp2(props.min, value, props.max);
          val.value = [
            which === 0 ? limitedValue : val.value[0],
            which === 1 ? limitedValue : val.value[1]
          ];
        } else {
          const value = val.value + (where ? props.step : -props.step);
          const limitedValue = clamp2(props.min, value, props.max);
          val.value = limitedValue;
        }
      };
      if (["ArrowLeft", "ArrowUp", "ArrowRight", "ArrowDown"].includes(event.key)) {
        event.preventDefault();
      }
      const isActive = (el) => el === document.activeElement;
      if (props.range && Array.isArray(val.value)) {
        const isVerticalDot0More = (event2) => props.vertical && isActive(dots.value[0]) && event2.key === "ArrowUp";
        const isVerticalDot0Less = (event2) => props.vertical && isActive(dots.value[0]) && event2.key === "ArrowDown";
        const isVerticalDot1More = (event2) => props.vertical && isActive(dots.value[1]) && event2.key === "ArrowUp";
        const isVerticalDot1Less = (event2) => props.vertical && isActive(dots.value[1]) && event2.key === "ArrowDown";
        const isHorizontalDot0Less = (event2) => !props.vertical && isActive(dots.value[0]) && event2.key === "ArrowLeft";
        const isHorizontalDot0More = (event2) => !props.vertical && isActive(dots.value[0]) && event2.key === "ArrowRight";
        const isHorizontalDot1Less = (event2) => !props.vertical && isActive(dots.value[1]) && event2.key === "ArrowLeft";
        const isHorizontalDot1More = (event2) => !props.vertical && isActive(dots.value[1]) && event2.key === "ArrowRight";
        switch (true) {
          case ((isVerticalDot1Less(event) || isHorizontalDot1Less(event)) && moreToLess.value && val.value[0] !== props.min):
            (_a2 = dots.value[0]) == null ? void 0 : _a2.focus();
            moveDot(0, 0);
            break;
          case ((isVerticalDot0More(event) || isHorizontalDot0More(event)) && lessToMore.value && val.value[1] !== props.max):
            (_b = dots.value[1]) == null ? void 0 : _b.focus();
            moveDot(1, 1);
            break;
          case ((isVerticalDot0Less(event) || isHorizontalDot0Less(event)) && val.value[0] !== props.min):
            moveDot(0, 0);
            break;
          case ((isVerticalDot1More(event) || isHorizontalDot1More(event)) && val.value[1] !== props.max):
            moveDot(1, 1);
            break;
          case ((isVerticalDot1Less(event) || isHorizontalDot1Less(event)) && val.value[1] !== props.min):
            moveDot(0, 1);
            break;
          case ((isVerticalDot0More(event) || isHorizontalDot0More(event)) && val.value[0] !== props.max):
            moveDot(1, 0);
            break;
        }
      } else {
        if (props.vertical) {
          if (event.key === "ArrowDown") {
            moveDot(0, 0);
          }
          if (event.key === "ArrowUp") {
            moveDot(1, 0);
          }
        } else {
          if (event.key === "ArrowLeft") {
            moveDot(0, 0);
          }
          if (event.key === "ArrowRight") {
            moveDot(1, 0);
          }
        }
      }
    };
    const checkActivePin = (pin) => {
      if (Array.isArray(val.value)) {
        return pin * props.step > val.value[0] && pin * props.step < val.value[1];
      } else {
        return pin * props.step < val.value;
      }
    };
    const pinPositionStep = computed(() => props.step / (props.max - props.min) * 100);
    const getPinStyles = (pin) => ({
      backgroundColor: checkActivePin(pin) ? getColor(props.color) : getHoverColor2(getColor(props.color)),
      [pinPositionStyle.value]: `${pin * pinPositionStep.value}%`,
      transition: hasMouseDown.value ? "none" : "var(--va-slider-pin-transition)"
    });
    const getPos = (e) => {
      getStaticData();
      return props.vertical ? offset2.value - e.clientY : e.clientX - offset2.value;
    };
    const getStaticData = () => {
      if (sliderContainer.value) {
        size2.value = sliderContainer.value[props.vertical ? "offsetHeight" : "offsetWidth"];
        offset2.value = sliderContainer.value.getBoundingClientRect()[pinPositionStyle.value];
      }
    };
    const getValueByIndex = (index) => {
      return (props.step * multiple.value * index + props.min * multiple.value) / multiple.value;
    };
    const getTrackLabel = (val2, order) => {
      if (!props.trackLabel) {
        return val2;
      }
      return typeof props.trackLabel === "function" ? props.trackLabel(val2, order) : props.trackLabel;
    };
    const setCurrentValue = (newValue) => {
      const slider = currentSliderDotIndex.value;
      if (Array.isArray(val.value)) {
        if (isDiff(val.value[slider], newValue)) {
          if (slider === 0) {
            val.value = [newValue, val.value[1]];
          } else {
            val.value = [val.value[0], newValue];
          }
        }
      } else {
        if (newValue < props.min) {
          val.value = props.min;
        } else if (newValue > props.max) {
          val.value = props.max;
        } else if (isDiff(val.value, newValue)) {
          val.value = newValue;
        }
      }
    };
    const setValueOnPos = (pixelPosition) => {
      const range = limit.value;
      const valueRange = valueLimit.value;
      const dotToFocus = Array.isArray(val.value) ? dots.value[currentSliderDotIndex.value] : dot.value;
      dotToFocus == null ? void 0 : dotToFocus.focus();
      if (pixelPosition >= range[0] && pixelPosition <= range[1]) {
        const v = getValueByIndex(Math.round(pixelPosition / gap.value));
        if (currentSliderDotIndex.value) {
          if (Array.isArray(position.value) && Array.isArray(val.value) && pixelPosition <= position.value[0]) {
            val.value = [v, val.value[0]];
            currentSliderDotIndex.value = 0;
          } else {
            setCurrentValue(v);
          }
        } else {
          if (Array.isArray(position.value) && Array.isArray(val.value) && pixelPosition >= position.value[1]) {
            val.value = [val.value[1], v];
            currentSliderDotIndex.value = 1;
          } else {
            setCurrentValue(v);
          }
        }
      } else if (pixelPosition < range[0]) {
        setCurrentValue(valueRange[0]);
      } else {
        setCurrentValue(valueRange[1]);
      }
    };
    const isDiff = (a, b) => JSON.stringify(a) !== JSON.stringify(b);
    const clickOnContainer = (e) => {
      if (props.disabled || props.readonly) {
        return;
      }
      const pos = "touches" in e ? getPos(e.touches[0]) : getPos(e);
      if (Array.isArray(position.value)) {
        currentSliderDotIndex.value = pos > (position.value[1] - position.value[0]) / 2 + position.value[0] ? 1 : 0;
      }
      hasMouseDown.value = true;
      setValueOnPos(pos);
      moveStart(e, currentSliderDotIndex.value);
    };
    const bindEvents = () => {
      document.addEventListener("mousemove", moving);
      document.addEventListener("touchmove", moving, { passive: false });
      document.addEventListener("mouseup", moveEnd);
      document.addEventListener("mouseleave", moveEnd);
      document.addEventListener("touchcancel", moveEnd);
      document.addEventListener("touchend", moveEnd);
      document.addEventListener("keydown", moveWithKeys);
    };
    const unbindEvents = () => {
      document.removeEventListener("mousemove", moving);
      document.removeEventListener("touchmove", moving);
      document.removeEventListener("mouseup", moveEnd);
      document.removeEventListener("mouseleave", moveEnd);
      document.removeEventListener("touchcancel", moveEnd);
      document.removeEventListener("touchend", moveEnd);
      document.removeEventListener("keydown", moveWithKeys);
    };
    const ariaLabelIdComputed = computed(() => `aria-label-id-${generateUniqueId()}`);
    const { tp } = useTranslation();
    const slots = useSlots();
    const ariaAttributesComputed = computed(() => ({
      role: "slider",
      "aria-valuemin": props.min,
      "aria-valuemax": props.max,
      "aria-label": !slots.label && !props.label ? tp(props.ariaLabel, { value: String(val.value) }) : void 0,
      "aria-labelledby": slots.label || props.label ? ariaLabelIdComputed.value : void 0,
      "aria-orientation": props.vertical ? "vertical" : "horizontal",
      "aria-disabled": props.disabled,
      "aria-readonly": props.readonly,
      "aria-valuenow": !Array.isArray(val.value) ? val.value : void 0,
      "aria-valuetext": Array.isArray(val.value) ? String(val.value) : void 0
    }));
    onMounted(() => {
      if (validateSlider(val.value, props.step, props.min, props.max, props.range)) {
        getStaticData();
        bindEvents();
      }
    });
    onBeforeUnmount(unbindEvents);
    watch([
      val,
      () => props.step,
      () => props.min,
      () => props.max,
      () => props.range
    ], ([value, step, min, max, range]) => {
      validateSlider(value, step, min, max, range);
    });
    watch(hasMouseDown, (hasMouseDown2) => {
      document.documentElement.style.cursor = hasMouseDown2 ? "grabbing" : "";
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", mergeProps({
        class: ["va-slider", unref(sliderClass)]
      }, ariaAttributesComputed.value), [
        (__props.vertical ? _ctx.$slots.append : _ctx.$slots.prepend) ? (openBlock(), createElementBlock("div", _hoisted_160, [
          renderSlot(_ctx.$slots, __props.vertical ? "append" : "prepend")
        ])) : createCommentVNode("", true),
        (_ctx.$slots.label || __props.label) && !__props.invertLabel ? (openBlock(), createElementBlock("span", {
          key: 1,
          class: "va-input__label",
          id: ariaLabelIdComputed.value,
          style: normalizeStyle(labelStyles.value)
        }, [
          renderSlot(_ctx.$slots, "label", {}, () => [
            createTextVNode(toDisplayString(__props.label), 1)
          ])
        ], 12, _hoisted_230)) : createCommentVNode("", true),
        (__props.vertical ? __props.iconAppend : __props.iconPrepend) ? (openBlock(), createElementBlock("span", _hoisted_320, [
          createVNode(unref(VaIcon), {
            name: __props.vertical ? __props.iconAppend : __props.iconPrepend,
            color: unref(getColor)(_ctx.$props.color),
            size: 16
          }, null, 8, ["name", "color"])
        ])) : createCommentVNode("", true),
        createBaseVNode("div", {
          ref_key: "sliderContainer",
          ref: sliderContainer,
          class: "va-slider__container",
          onMousedown: clickOnContainer,
          onTouchstart: clickOnContainer
        }, [
          createBaseVNode("div", {
            class: "va-slider__track",
            "aria-hidden": "true",
            style: normalizeStyle(trackStyles.value)
          }, null, 4),
          __props.pins ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(pinsCol.value, (pin, i) => {
            return openBlock(), createElementBlock("div", {
              key: i,
              class: normalizeClass(["va-slider__mark", { "va-slider__mark--active": checkActivePin(pin) }]),
              style: normalizeStyle(getPinStyles(pin))
            }, null, 6);
          }), 128)) : createCommentVNode("", true),
          _ctx.$props.range ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
            createBaseVNode("div", {
              ref: "process",
              class: normalizeClass(["va-slider__track va-slider__track--selected", { "va-slider__track--active": isFocused.value }]),
              "aria-hidden": "true",
              style: normalizeStyle(processedStyles.value)
            }, null, 6),
            (openBlock(true), createElementBlock(Fragment, null, renderList(orders.value, (order) => {
              return openBlock(), createElementBlock("div", {
                key: "dot" + order,
                ref_for: true,
                ref: unref(setItemRefByIndex)(order),
                class: normalizeClass(["va-slider__handler", unref(dotClass)]),
                style: normalizeStyle(getDottedStyles(order)),
                tabindex: __props.disabled || __props.readonly ? void 0 : 0,
                onFocus: ($event) => (isFocused.value = true, currentSliderDotIndex.value = order),
                onBlur: _cache[0] || (_cache[0] = ($event) => isFocused.value = false)
              }, [
                isActiveDot(order) ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  style: normalizeStyle({ backgroundColor: unref(getColor)(_ctx.$props.color) }),
                  class: "va-slider__handler__dot--focus"
                }, null, 4)) : createCommentVNode("", true),
                __props.trackLabelVisible ? (openBlock(), createElementBlock("div", {
                  key: 1,
                  style: normalizeStyle(labelStyles.value),
                  class: "va-slider__handler__dot--value"
                }, [
                  renderSlot(_ctx.$slots, "trackLabel", normalizeProps(guardReactiveProps({ value: getValueByOrder(order), order })), () => [
                    createTextVNode(toDisplayString(getTrackLabel(getValueByOrder(order), order)), 1)
                  ])
                ], 4)) : createCommentVNode("", true)
              ], 46, _hoisted_411);
            }), 128))
          ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 2 }, [
            createBaseVNode("div", {
              ref: "process",
              "aria-hidden": "true",
              class: normalizeClass(["va-slider__track va-slider__track--selected", { "va-slider__track--active": isFocused.value }]),
              style: normalizeStyle(processedStyles.value)
            }, null, 6),
            createBaseVNode("div", {
              ref_key: "dot",
              ref: dot,
              class: normalizeClass(["va-slider__handler", unref(dotClass)]),
              style: normalizeStyle(dottedStyles.value),
              tabindex: _ctx.$props.disabled || _ctx.$props.readonly ? void 0 : 0,
              onFocus: _cache[1] || (_cache[1] = ($event) => isFocused.value = true),
              onBlur: _cache[2] || (_cache[2] = ($event) => isFocused.value = false)
            }, [
              isActiveDot(0) ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: "va-slider__handler__dot--focus",
                style: normalizeStyle({ backgroundColor: unref(getColor)(_ctx.$props.color) })
              }, null, 4)) : createCommentVNode("", true),
              __props.trackLabelVisible ? (openBlock(), createElementBlock("div", {
                key: 1,
                class: "va-slider__handler__dot--value",
                style: normalizeStyle(labelStyles.value)
              }, [
                renderSlot(_ctx.$slots, "trackLabel", normalizeProps(guardReactiveProps({ value: getValueByOrder() })), () => [
                  createTextVNode(toDisplayString(getTrackLabel(getValueByOrder())), 1)
                ])
              ], 4)) : createCommentVNode("", true)
            ], 46, _hoisted_59)
          ], 64))
        ], 544),
        (__props.vertical ? __props.iconPrepend : __props.iconAppend) ? (openBlock(), createElementBlock("span", _hoisted_66, [
          createVNode(unref(VaIcon), {
            name: __props.vertical ? __props.iconPrepend : __props.iconAppend,
            color: unref(getColor)(_ctx.$props.color),
            size: 16
          }, null, 8, ["name", "color"])
        ])) : createCommentVNode("", true),
        (_ctx.$slots.label || __props.label) && __props.invertLabel ? (openBlock(), createElementBlock("span", {
          key: 4,
          class: "va-input__label va-input__label--inverse",
          style: normalizeStyle(labelStyles.value),
          id: ariaLabelIdComputed.value
        }, [
          renderSlot(_ctx.$slots, "label", {}, () => [
            createTextVNode(toDisplayString(__props.label), 1)
          ])
        ], 12, _hoisted_74)) : createCommentVNode("", true),
        (__props.vertical ? _ctx.$slots.prepend : _ctx.$slots.append) ? (openBlock(), createElementBlock("div", _hoisted_82, [
          renderSlot(_ctx.$slots, __props.vertical ? "prepend" : "append")
        ])) : createCommentVNode("", true)
      ], 16);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-slider/VaSlider.js
var _style_092 = ":root,\n:host {\n  /* Track */\n  --va-slider-track-border-radius: 0.25rem;\n  --va-slider-track-transition: 0.5s ease-out;\n  --va-slider-track-opacity: 1;\n  /* Pin */\n  --va-slider-pin-transition: background-color 0.3s ease-out 0.1s;\n  /* Handler */\n  --va-slider-handler-width: 1.25rem;\n  --va-slider-handler-height: 1.25rem;\n  --va-slider-handler-background: var(--va-background-primary);\n  --va-slider-handler-border: 0.375rem solid;\n  --va-slider-handler-border-radius: 50%;\n  --va-slider-handler-outline: none !important;\n  --va-slider-handler-left: -0.375rem;\n  --va-slider-handler-transition: 0s;\n  /* Dot */\n  --va-slider-dot-transform: translate(-0.625rem, -0.625rem);\n  --va-slider-dot-display: block;\n  --va-slider-dot-width: 1.75rem;\n  --va-slider-dot-height: 1.75rem;\n  --va-slider-dot-border-radius: 50%;\n  --va-slider-dot-opacity: 0.2;\n  --va-slider-dot-pointer-events: none;\n  /* Dot Value */\n  --va-slider-dot-value-transform: translate(-50%, -100%);\n  --va-slider-dot-value-user-select: none;\n  --va-slider-dot-value-font-size: 0.625rem;\n  --va-slider-dot-value-letter-spacing: 0.6px;\n  --va-slider-dot-value-line-height: 1.2;\n  --va-slider-dot-value-font-weight: 700;\n  --va-slider-dot-value-text-transform: none;\n  --va-slider-dot-value-white-space: nowrap;\n  /* Input Label */\n  --va-slider-input-label-user-select: none;\n  --va-slider-input-label-font-size: 0.625rem;\n  --va-slider-input-label-letter-spacing: 0.6px;\n  --va-slider-input-label-line-height: 1.2;\n  --va-slider-input-label-font-weight: 700;\n  --va-slider-input-label-text-transform: uppercase;\n  --va-slider-input-label-inverse-user-select: none;\n  --va-slider-input-label-inverse-font-size: 0.625rem;\n  --va-slider-input-label-inverse-letter-spacing: 0.6px;\n  --va-slider-input-label-inverse-line-height: 1.2;\n  --va-slider-input-label-inverse-font-weight: 700;\n  --va-slider-input-label-inverse-text-transform: uppercase;\n  /* Horizontal */\n  --va-slider-horizontal-input-wrapper-margin-right: 1rem;\n  /* Horizontal Track */\n  --va-slider-horizontal-track-height: 0.5rem;\n  --va-slider-horizontal-track-width: 100%;\n  /* Horizontal Track */\n  --va-slider-horizontal-handler-transform: translateX(-50%);\n  /* Horizontal Dot */\n  --va-slider-horizontal-dot-value-top: -8px;\n  --va-slider-horizontal-dot-value-left: 50%;\n  /* Vertical */\n  --va-slider-vertical-height: 100%;\n  --va-slider-vertical-padding: 12px 0 12px 0;\n  --va-slider-vertical-flex-direction: column;\n  --va-slider-vertical-align-items: center;\n  /* Vertical Label */\n  --va-slider-vertical-label-margin-bottom: 0.625rem;\n  --va-slider-vertical-label-inverse-left: -0.375rem;\n  --va-slider-vertical-label-inverse-margin-top: 0.625rem;\n  /* Vertical Input Wrapper */\n  --va-slider-vertical-input-wrapper-max-width: 1rem;\n  --va-slider-vertical-input-wrapper-min-width: 2.5rem;\n  /* Vertical Track */\n  --va-slider-vertical-track-height: 100%;\n  --va-slider-vertical-track-width: 0.5rem;\n  --va-slider-vertical-track-bottom: 0;\n  /* Vertical Handler */\n  --va-slider-vertical-handler-transform: translateY(50%);\n  /* Vertical Dot Value */\n  --va-slider-vertical-dot-value-top: 0.625rem;\n  --va-slider-vertical-dot-value-left: 1.25rem;\n}\n.va-slider {\n  display: flex;\n  align-items: center;\n  font-family: var(--va-font-family);\n}\n.va-slider__input-wrapper {\n  position: relative;\n  display: flex;\n}\n.va-slider__container {\n  position: relative;\n  display: flex;\n  align-items: center;\n  cursor: grab;\n}\n.va-slider__track {\n  position: absolute;\n  border-radius: var(--va-slider-track-border-radius);\n  transition: var(--va-slider-track-transition);\n  opacity: var(--va-slider-track-opacity);\n}\n.va-slider__track--active {\n  transition: 0s;\n}\n.va-slider__track--selected {\n  opacity: 1;\n}\n.va-slider__handler {\n  position: absolute;\n  width: var(--va-slider-handler-width);\n  height: var(--va-slider-handler-height);\n  background: var(--va-slider-handler-background);\n  border: var(--va-slider-handler-border);\n  border-radius: var(--va-slider-handler-border-radius);\n  outline: var(--va-slider-handler-outline);\n  left: var(--va-slider-handler-left);\n  transition: var(--va-slider-handler-transition);\n  box-sizing: border-box;\n}\n.va-slider__handler__dot--focus {\n  transform: var(--va-slider-dot-transform);\n  display: block;\n  width: var(--va-slider-dot-width);\n  height: var(--va-slider-dot-height);\n  position: absolute;\n  border-radius: var(--va-slider-dot-border-radius);\n  opacity: var(--va-slider-dot-opacity);\n  pointer-events: var(--va-slider-dot-pointer-events);\n}\n.va-slider__handler__dot--value {\n  transform: var(--va-slider-dot-value-transform);\n  -webkit-user-select: var(--va-slider-dot-value-user-select);\n     -moz-user-select: var(--va-slider-dot-value-user-select);\n          user-select: var(--va-slider-dot-value-user-select);\n  font-size: var(--va-slider-dot-value-font-size);\n  letter-spacing: var(--va-slider-dot-value-letter-spacing);\n  line-height: var(--va-slider-dot-value-line-height);\n  font-weight: var(--va-slider-dot-value-font-weight);\n  text-transform: var(--va-slider-dot-value-text-transform);\n  white-space: var(--va-slider-dot-value-white-space);\n}\n.va-slider .va-input__label {\n  -webkit-user-select: var(--va-slider-input-label-user-select);\n     -moz-user-select: var(--va-slider-input-label-user-select);\n          user-select: var(--va-slider-input-label-user-select);\n  font-size: var(--va-slider-input-label-font-size);\n  letter-spacing: var(--va-slider-input-label-letter-spacing);\n  line-height: var(--va-slider-input-label-line-height);\n  font-weight: var(--va-slider-input-label-font-weight);\n  text-transform: var(--va-slider-input-label-text-transform);\n}\n.va-slider .va-input__label--inverse {\n  -webkit-user-select: var(--va-slider-input-label-inverse-user-select);\n     -moz-user-select: var(--va-slider-input-label-inverse-user-select);\n          user-select: var(--va-slider-input-label-inverse-user-select);\n  font-size: var(--va-slider-input-label-inverse-font-size);\n  letter-spacing: var(--va-slider-input-label-inverse-letter-spacing);\n  line-height: var(--va-slider-input-label-inverse-line-height);\n  font-weight: var(--va-slider-input-label-inverse-font-weight);\n  text-transform: var(--va-slider-input-label-inverse-text-transform);\n}\n.va-slider--grabbing .va-slider__container {\n  cursor: grabbing;\n}\n.va-slider--disabled {\n  cursor: default;\n  opacity: 0.4;\n  pointer-events: none;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n          user-select: none;\n}\n.va-slider--disabled .va-slider__container {\n  cursor: default;\n}\n.va-slider--readonly .va-slider__container {\n  cursor: default;\n}\n.va-slider--horizontal .va-slider__input-wrapper {\n  flex-basis: fit-content;\n  flex-grow: 0;\n  margin-right: var(--va-slider-horizontal-input-wrapper-margin-right);\n}\n.va-slider--horizontal .va-slider__input-wrapper:last-of-type {\n  margin-left: 1rem;\n}\n.va-slider--horizontal .va-slider__container {\n  width: 100%;\n  height: 1.5rem;\n}\n.va-slider--horizontal .va-slider__track {\n  height: var(--va-slider-horizontal-track-height);\n  width: var(--va-slider-horizontal-track-width);\n}\n.va-slider--horizontal .va-slider__mark {\n  position: absolute;\n  width: 0.125rem;\n  height: 0.75rem;\n}\n.va-slider--horizontal .va-slider__handler {\n  transform: var(--va-slider-horizontal-handler-transform);\n}\n.va-slider--horizontal .va-slider__handler--inactive {\n  transition: left 0.5s ease-out;\n}\n.va-slider--horizontal .va-slider__handler__dot--value {\n  position: absolute;\n  top: var(--va-slider-horizontal-dot-value-top);\n  left: var(--va-slider-horizontal-dot-value-left);\n}\n.va-slider--horizontal .va-input__label {\n  margin-right: 1rem;\n}\n.va-slider--horizontal .va-input__label--inverse {\n  margin-left: 1rem;\n}\n.va-slider--vertical {\n  height: var(--va-slider-vertical-height);\n  padding: var(--va-slider-vertical-padding);\n  flex-direction: var(--va-slider-vertical-flex-direction);\n  align-items: var(--va-slider-vertical-align-items);\n}\n.va-slider--vertical .va-input__label {\n  margin-bottom: var(--va-slider-vertical-label-margin-bottom);\n}\n.va-slider--vertical .va-input__label--inverse {\n  left: var(--va-slider-vertical-label-inverse-left);\n  margin-top: var(--va-slider-vertical-label-inverse-margin-top);\n}\n.va-slider--vertical .va-slider__input-wrapper {\n  flex-basis: fit-content;\n  flex-grow: 0;\n  max-width: var(--va-slider-vertical-input-wrapper-max-width);\n  min-width: var(--va-slider-vertical-input-wrapper-min-width);\n  position: relative;\n  display: flex;\n}\n.va-slider--vertical .va-slider__input-wrapper:last-of-type {\n  margin-top: 1rem;\n}\n.va-slider--vertical .va-slider__container {\n  height: 100%;\n  width: 0.5rem;\n}\n.va-slider--vertical .va-slider__track {\n  height: var(--va-slider-vertical-track-height);\n  width: var(--va-slider-vertical-track-width);\n  bottom: var(--va-slider-vertical-track-bottom);\n}\n.va-slider--vertical .va-slider__mark {\n  position: absolute;\n  width: 0.75rem;\n  height: 0.125rem;\n  left: -2px;\n}\n.va-slider--vertical .va-slider__handler {\n  transform: var(--va-slider-vertical-handler-transform);\n}\n.va-slider--vertical .va-slider__handler--inactive {\n  transition: bottom 0.5s ease-out;\n}\n.va-slider--vertical .va-slider__handler__dot--value {\n  position: relative;\n  top: var(--va-slider-vertical-dot-value-top);\n  left: var(--va-slider-vertical-dot-value-left);\n}";
var _VaSlider = _export_sfc(_sfc_main98, [["styles", [_style_092]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-slider/index.js
var VaSlider = withConfigTransport$1(_VaSlider);

// node_modules/vuestic-ui/dist/web-components/src/components/va-spacer/VaSpacer.vue_vue_type_script_setup_true_lang.js
var _hoisted_161 = {
  class: "va-spacer",
  "aria-hidden": "true"
};
var _sfc_main99 = defineComponent({
  ...{
    name: "VaSpacer"
  },
  __name: "VaSpacer",
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_161);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-spacer/VaSpacer.js
var _style_093 = ":root,\n:host {\n  --va-spacer-flex-grow: 1 !important;\n}\n.va-spacer {\n  flex-grow: var(--va-spacer-flex-grow);\n}";
var VaSpacer = _export_sfc(_sfc_main99, [["styles", [_style_093]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-split/useSplitDragger.js
var useSplitDraggerProps = {
  vertical: { type: Boolean, default: false },
  disabled: { type: Boolean, default: false }
};
var useSplitDragger = (containerSizeComputed, splitterPositionComputed, props) => {
  const isDragging = ref(false);
  const dragStartPosition = ref(0);
  const dragStartSplitterPosition = ref(0);
  const currentSplitterPosition = ref(0);
  const getEventPosition = (e, eventName) => {
    const event = e.type === eventName ? e : e.changedTouches[0];
    return props.vertical ? event.pageY : event.pageX;
  };
  const startDragging = (e) => {
    if (props.disabled || !containerSizeComputed.value) {
      return;
    }
    isDragging.value = true;
    dragStartPosition.value = getEventPosition(e, "mousedown");
    dragStartSplitterPosition.value = splitterPositionComputed.value;
  };
  const processDragging = (e) => {
    if (!isDragging.value) {
      return;
    }
    const currentPosition = getEventPosition(e, "mousemove");
    const distance = currentPosition - dragStartPosition.value;
    currentSplitterPosition.value = dragStartSplitterPosition.value + Math.floor(distance / containerSizeComputed.value * 100);
  };
  const stopDragging = () => {
    isDragging.value = false;
  };
  useEvent(["mousemove", "touchmove"], processDragging);
  useEvent(["mouseup", "touchcancel"], stopDragging);
  return { isDragging, startDragging, currentSplitterPosition };
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-split/VaSplit.vue_vue_type_script_setup_true_lang.js
var _hoisted_162 = ["aria-label"];
var _hoisted_231 = { class: "va-split__dragger" };
var _sfc_main100 = defineComponent({
  ...{
    name: "VaSplit"
  },
  __name: "VaSplit",
  props: {
    ...useComponentPresetProp,
    ...useSplitDraggerProps,
    ...useStatefulProps,
    modelValue: {
      type: Number,
      default: 50,
      validator: (v) => v <= 100
    },
    maximization: { type: Boolean, default: false },
    maximizeStart: { type: Boolean, default: false },
    limits: {
      type: Array,
      default: () => [0, 0]
    },
    snapping: {
      type: Array,
      default: void 0
    },
    snappingRange: { type: [Number, String], default: 4 },
    ariaLabel: { type: String, default: "$t:splitPanels" }
  },
  emits: [...useStatefulEmits],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const splitPanelsContainer = shallowRef();
    const { valueComputed } = useStateful(props, emit);
    const containerSize = ref();
    const bodyFontSize = ref(16);
    const handleContainerResize = () => {
      var _a2;
      const { width, height } = ((_a2 = splitPanelsContainer.value) == null ? void 0 : _a2.getBoundingClientRect()) || { width: 0, height: 0 };
      containerSize.value = props.vertical ? height : width;
      bodyFontSize.value = parseFloat(getComputedStyle(document.documentElement).fontSize);
    };
    onMounted(handleContainerResize);
    useResizeObserver([splitPanelsContainer], handleContainerResize);
    const convertToPercents = (v, type) => {
      let numberValue = "";
      let measureValue = "";
      if (isNumber$1(v)) {
        return v;
      }
      v.split("").filter((char) => char && char !== " ").forEach((char) => {
        !isNaN(+char) ? numberValue += char : measureValue += char;
      });
      switch (measureValue) {
        case "%":
          return +numberValue;
        case "px":
          return +numberValue / containerSize.value * 100;
        case "rem":
          return +numberValue * bodyFontSize.value / containerSize.value * 100;
        case "any":
          return ["min", "snapping"].includes(type) ? 0 : 100;
        case "":
          return 100;
        default:
          warn("Invalid limits measure!");
          return 0;
      }
    };
    const getPanelMinMax = (v) => {
      if (v === "undefined" || !containerSize.value) {
        return;
      }
      let minPercents = 0;
      let maxPercents = 100;
      if (isString$1(v) || isNumber$1(v)) {
        minPercents = convertToPercents(v, "min");
      }
      if (Array.isArray(v)) {
        minPercents = convertToPercents(v[0], "min");
        maxPercents = convertToPercents(v[1], "max");
      }
      if (minPercents > maxPercents) {
        warn(`Min panels size can not be larger than max one! Passed limit: ${v}.`);
        maxPercents = minPercents;
      }
      return { min: minPercents ?? 0, max: maxPercents ?? 100 };
    };
    const startPanelMinMax = computed(() => getPanelMinMax(props.limits[0]) ?? { min: 0, max: 100 });
    const endPanelMinMax = computed(() => getPanelMinMax(props.limits[1]) ?? { min: 0, max: 100 });
    const endPanelMinChecked = computed(() => {
      const passedCheck = !(startPanelMinMax.value.min + endPanelMinMax.value.min > 100);
      if (!passedCheck) {
        warn("The sum of different panels min sizes should be lesser or equal to 100% of the container size!");
      }
      return !passedCheck ? 100 - startPanelMinMax.value.min : endPanelMinMax.value.min;
    });
    const panelsMinMax = computed(() => {
      if (Math.ceil(endPanelMinMax.value.max + startPanelMinMax.value.max) < 100) {
        warn("The sum of different panels max sizes should be equal to 100% of the container size!");
      }
      return {
        start: {
          min: startPanelMinMax.value.min,
          max: Math.min(startPanelMinMax.value.max, 100 - endPanelMinChecked.value)
        },
        end: {
          min: endPanelMinChecked.value,
          max: Math.min(endPanelMinMax.value.max, 100 - startPanelMinMax.value.min)
        }
      };
    });
    const checkSnappingLimitsCondition = (el) => el >= panelsMinMax.value.start.min && el >= panelsMinMax.value.end.min && el <= panelsMinMax.value.start.max && el <= panelsMinMax.value.end.max;
    const snappingMarksPosition = computed(() => {
      if (!Array.isArray(props.snapping) || !containerSize.value) {
        return;
      }
      let result = props.snapping.map((el) => convertToPercents(el, "snapping"));
      if (!result.every(checkSnappingLimitsCondition)) {
        const filteredMarks = result.filter(checkSnappingLimitsCondition);
        warn(`Some of the snapping marks (${result}) are not in allowed range (${Object.values(panelsMinMax.value.start).join("-")} / ${Object.values(panelsMinMax.value.end).join("-")}) and will be removed (${filteredMarks})!`);
        result = filteredMarks;
      }
      const checkSnappingRange = () => {
        return result.every((el, index, array) => {
          if (!array[index + 1]) {
            return true;
          }
          return Math.abs(el - array[index + 1]) > Number(props.snappingRange);
        });
      };
      if (!checkSnappingRange()) {
        warn("Distance between some snapping marks is lesser than snapping range!");
      }
      return result;
    });
    const snappingRangeParsed = computed(() => convertToPercents(props.snappingRange, "snapping"));
    const splitterPosition = ref(valueComputed.value);
    const splitterPositionComputed = computed(() => {
      if (snappingMarksPosition.value) {
        const nearestSnappingMark = snappingMarksPosition.value.find((el) => {
          return splitterPosition.value + snappingRangeParsed.value > el && splitterPosition.value - snappingRangeParsed.value < el;
        });
        if (nearestSnappingMark) {
          return nearestSnappingMark;
        }
      }
      return clamp$1(
        splitterPosition.value,
        Math.max(panelsMinMax.value.start.min, 100 - panelsMinMax.value.end.max),
        Math.min(panelsMinMax.value.start.max, 100 - panelsMinMax.value.end.min)
      );
    });
    const {
      isDragging,
      startDragging,
      currentSplitterPosition
    } = useSplitDragger(containerSize, splitterPositionComputed, props);
    const maximizePanel = () => {
      if (!props.maximization || props.disabled) {
        return;
      }
      splitterPosition.value = props.maximizeStart ? panelsMinMax.value.start.max : 100 - panelsMinMax.value.end.max;
    };
    watch(valueComputed, (v) => {
      if (v < panelsMinMax.value.start.min || v > 100 - panelsMinMax.value.end.min) {
        warn("Incorrect `modelValue`. Check current `limits` prop value.");
      }
      splitterPosition.value = v;
    }, { immediate: true });
    watch(currentSplitterPosition, (v) => {
      splitterPosition.value = v;
    });
    watch(isDragging, (v) => {
      if (!v) {
        valueComputed.value = splitterPositionComputed.value;
      }
      document.documentElement.style.cursor = v ? "var(--va-split-dragging-cursor)" : "";
    });
    const sizePropertyComputed = computed(() => props.vertical ? "height" : "width");
    const getPanelStyle = (position) => {
      let sizeValue = position === "start" ? splitterPositionComputed.value : 100 - splitterPositionComputed.value;
      if (sizeValue < 0) {
        sizeValue = 0;
      }
      if (sizeValue > 100) {
        sizeValue = 100;
      }
      return { [sizePropertyComputed.value]: `${sizeValue}%` };
    };
    const draggerStyleComputed = computed(() => {
      if (props.disabled) {
        return {};
      }
      if (isDragging.value) {
        return { cursor: "var(--va-split-dragging-cursor)" };
      }
      return { cursor: props.vertical ? "var(--va-split-vertical-dragger-cursor)" : "var(--va-split-horizontal-dragger-cursor)" };
    });
    const classComputed = useBem("va-split", () => ({
      horizontal: !props.vertical,
      vertical: props.vertical,
      dragging: isDragging.value
    }));
    const { t, tp } = useTranslation();
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("section", {
        ref_key: "splitPanelsContainer",
        ref: splitPanelsContainer,
        class: normalizeClass(["va-split", unref(classComputed)]),
        "aria-label": unref(tp)(_ctx.$props.ariaLabel)
      }, [
        createBaseVNode("div", {
          class: "va-split__panel",
          style: normalizeStyle(getPanelStyle("start"))
        }, [
          renderSlot(_ctx.$slots, "start", normalizeProps(guardReactiveProps({ containerSize: containerSize.value })))
        ], 4),
        createBaseVNode("div", _hoisted_231, [
          createBaseVNode("div", {
            class: "va-split__dragger__overlay",
            style: normalizeStyle(draggerStyleComputed.value),
            onMousedown: _cache[0] || (_cache[0] = withModifiers(
              //@ts-ignore
              (...args) => unref(startDragging) && unref(startDragging)(...args),
              ["prevent"]
            )),
            onTouchstart: _cache[1] || (_cache[1] = withModifiers(
              //@ts-ignore
              (...args) => unref(startDragging) && unref(startDragging)(...args),
              ["prevent"]
            )),
            onDblclick: withModifiers(maximizePanel, ["prevent"]),
            onContextmenu: _cache[2] || (_cache[2] = withModifiers(() => {
            }, ["prevent"])),
            onDragstart: _cache[3] || (_cache[3] = withModifiers(() => {
            }, ["prevent"]))
          }, [
            renderSlot(_ctx.$slots, "grabber", {}, () => [
              createVNode(unref(VaDivider), {
                class: "va-split__dragger__default",
                vertical: !_ctx.$props.vertical
              }, null, 8, ["vertical"])
            ])
          ], 36)
        ]),
        createBaseVNode("div", {
          class: "va-split__panel",
          style: normalizeStyle(getPanelStyle("end"))
        }, [
          renderSlot(_ctx.$slots, "end", normalizeProps(guardReactiveProps({ containerSize: containerSize.value })))
        ], 4)
      ], 10, _hoisted_162);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-split/VaSplit.js
var _style_094 = ":root,\n:host {\n  --va-split-panel-overflow: auto;\n  --va-split-dragger-display: flex;\n  --va-split-dragger-justify-content: center;\n  --va-split-dragger-align-items: center;\n  --va-split-dragger-overlay-size: 1rem;\n  --va-split-dragging-cursor: grabbing;\n  --va-split-horizontal-dragger-cursor: col-resize;\n  --va-split-vertical-dragger-cursor: row-resize;\n}\n.va-split {\n  position: relative;\n  display: flex;\n}\n.va-split__dragger {\n  position: relative;\n}\n.va-split__dragger__overlay {\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  right: 0;\n  left: 0;\n  display: var(--va-split-dragger-display);\n  z-index: 1;\n}\n.va-split__panel {\n  overflow: var(--va-split-panel-overflow);\n  scrollbar-color: var(--va-background-element) transparent;\n  scrollbar-width: thin;\n  transition: scrollbar-color 0.3s ease-in-out;\n}\n.va-split__panel::-webkit-scrollbar {\n  width: 4px;\n  height: 4px;\n}\n.va-split__panel::-webkit-scrollbar-track {\n  box-shadow: none;\n  border-radius: 10px;\n}\n.va-split__panel::-webkit-scrollbar-thumb {\n  background: var(--va-background-element);\n  opacity: 0.3;\n  border-radius: 2px;\n  -webkit-transition: background 0.3s ease-in-out;\n  transition: background 0.3s ease-in-out;\n}\n.va-split--dragging .va-split__panel {\n  -webkit-user-select: none;\n     -moz-user-select: none;\n          user-select: none;\n  cursor: var(--va-split-dragging-cursor);\n}\n.va-split__dragger__default {\n  opacity: 0.7;\n}\n.va-split:focus .va-split__dragger__default, .va-split:hover .va-split__dragger__default {\n  opacity: 1;\n}\n.va-split--vertical {\n  flex-direction: column;\n}\n.va-split--vertical > .va-split__dragger {\n  height: 0;\n}\n.va-split--vertical > .va-split__dragger .va-split__dragger__overlay {\n  top: calc(var(--va-split-dragger-overlay-size) / -2);\n  height: var(--va-split-dragger-overlay-size);\n  align-items: var(--va-split-dragger-align-items);\n}\n.va-split--vertical > .va-split__dragger .va-split__dragger__default {\n  width: 100%;\n}\n.va-split--horizontal {\n  flex-direction: row;\n}\n.va-split--horizontal > .va-split__dragger {\n  width: 0;\n}\n.va-split--horizontal > .va-split__dragger .va-split__dragger__overlay {\n  left: calc(var(--va-split-dragger-overlay-size) / -2);\n  width: var(--va-split-dragger-overlay-size);\n  justify-content: var(--va-split-dragger-justify-content);\n}\n.va-split--horizontal > .va-split__dragger .va-split__dragger__default {\n  height: 100%;\n}";
var _VaSplit = _export_sfc(_sfc_main100, [["styles", [_style_094]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-split/index.js
var VaSplit = withConfigTransport$1(_VaSplit);

// node_modules/vuestic-ui/dist/web-components/src/components/va-tabs/types.js
var TabsViewKey = Symbol("TabsView");

// node_modules/vuestic-ui/dist/web-components/src/components/va-tabs/VaTabs.vue_vue_type_script_setup_true_lang.js
var _hoisted_163 = ["aria-disabled"];
var _hoisted_232 = createBaseVNode("div", { class: "va-tabs__slider" }, null, -1);
var _hoisted_321 = [
  _hoisted_232
];
var _hoisted_412 = { class: "va-tabs__tabs-items" };
var _hoisted_510 = { class: "va-tabs__content" };
var getClientWidth = (element) => (element == null ? void 0 : element.clientWidth) || 0;
var _sfc_main101 = defineComponent({
  ...{
    name: "VaTabs"
  },
  __name: "VaTabs",
  props: {
    ...useStatefulProps,
    ...useComponentPresetProp,
    modelValue: { type: [String, Number], default: null },
    left: { type: Boolean, default: true },
    right: { type: Boolean, default: false },
    center: { type: Boolean, default: false },
    grow: { type: Boolean, default: false },
    hidePagination: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false },
    hideSlider: { type: Boolean, default: false },
    vertical: { type: Boolean, default: false },
    color: { type: String, default: "primary" },
    prevIcon: { type: String, default: "va-arrow-left" },
    nextIcon: { type: String, default: "va-arrow-right" },
    ariaMoveRightLabel: { type: String, default: "$t:movePaginationLeft" },
    ariaMoveLeftLabel: { type: String, default: "$t:movePaginationRight" }
  },
  emits: ["update:modelValue", "click:next", "click:prev"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const { tp } = useTranslation();
    const props = __props;
    const emit = __emit;
    const wrapper = shallowRef();
    const container = shallowRef();
    const tabs = shallowRef();
    const tabsList = ref([]);
    const sliderHeight = ref(null);
    const sliderWidth = ref(null);
    const sliderOffsetX = ref(0);
    const sliderOffsetY = ref(0);
    const showPagination = ref(false);
    const tabsContentOffset = ref(0);
    const startingXPoint = ref(0);
    const animationIncluded = ref(false);
    const { valueComputed: tabSelected } = useStateful(props, emit);
    const tabConfig = reactive({
      VaTab: {
        color: props.color
      }
    });
    const computedClass = computed(() => {
      const { left, right, center, grow, disabled } = props;
      return {
        "va-tabs__container--left": left && !right && !center && !grow,
        "va-tabs__container--right": right,
        "va-tabs__container--center": center,
        "va-tabs__container--grow": grow,
        "va-tabs__container--disabled": disabled
      };
    });
    const computedTabsClass = computed(() => ({ "va-tabs--vertical": props.vertical }));
    const { getColor } = useColors();
    const colorComputed = computed(() => getColor(props.color));
    const sliderStyles = computed(() => {
      if (props.hideSlider) {
        return { display: "none" };
      }
      return {
        backgroundColor: colorComputed.value,
        height: props.vertical ? `${sliderHeight.value}px` : "",
        width: props.vertical ? "" : `${sliderWidth.value}px`,
        transform: `translateY(-${sliderOffsetY.value}px) translateX(${sliderOffsetX.value}px)`,
        transition: animationIncluded.value ? "var(--va-tabs-slider-wrapper-transition)" : ""
      };
    });
    const paginationControlledStyles = computed(() => {
      if (props.vertical) {
        return {
          transform: "translateX(0px)"
        };
      }
      return {
        transform: `translateX(${startingXPoint.value - tabsContentOffset.value}px)`,
        transition: animationIncluded.value ? "var(--va-tabs-slider-transition)" : "",
        position: props.hidePagination ? "unset" : "absolute"
      };
    });
    const disablePaginationLeft = computed(() => tabsContentOffset.value === 0);
    const disablePaginationRight = computed(() => {
      const lastTab = tabsList.value[tabsList.value.length - 1];
      const leftSidePosition = unref(lastTab.leftSidePosition);
      const rightSidePosition = unref(lastTab.rightSidePosition);
      const containerClientWidth = getClientWidth(container.value);
      return rightSidePosition <= tabsContentOffset.value + containerClientWidth || leftSidePosition <= tabsContentOffset.value;
    });
    const resetSliderSizes = () => {
      sliderWidth.value = 0;
      sliderHeight.value = 0;
    };
    const moveToTab = (tab) => {
      const containerClientWidth = getClientWidth(container.value);
      const leftSidePosition = unref(tab.leftSidePosition);
      const rightSidePosition = unref(tab.rightSidePosition);
      if (!showPagination.value) {
        tabsContentOffset.value = 0;
        return;
      }
      if (leftSidePosition - tabsContentOffset.value >= 0 && rightSidePosition - tabsContentOffset.value <= containerClientWidth) {
        return;
      }
      if (leftSidePosition - tabsContentOffset.value < 0) {
        tabsContentOffset.value = leftSidePosition;
        return;
      }
      if (rightSidePosition - tabsContentOffset.value > containerClientWidth) {
        tabsContentOffset.value = rightSidePosition - containerClientWidth;
        return;
      }
      tabsContentOffset.value = 0;
    };
    const updateStartingXPoint = () => {
      startingXPoint.value = 0;
      if (!showPagination.value) {
        return;
      }
      const containerClientWidth = getClientWidth(container.value);
      const tabsClientWidth = getClientWidth(tabs.value);
      if (props.right) {
        startingXPoint.value = tabsClientWidth - containerClientWidth;
      } else if (props.center) {
        startingXPoint.value = Math.floor((tabsClientWidth - containerClientWidth) / 2);
      }
    };
    const updateTabsState = () => {
      resetSliderSizes();
      tabsList.value.forEach((tab) => {
        var _a2;
        tab.updateSidePositions();
        const isTabSelected = (((_a2 = tab.name) == null ? void 0 : _a2.value) || tab.id) === tabSelected.value;
        tab.isActive = tab.isActiveRouterLink || isTabSelected;
        if (tab.isActive) {
          moveToTab(tab);
          updateSlider(tab);
        }
      });
      updateStartingXPoint();
    };
    const updatePagination = () => {
      const tabsClientWidth = getClientWidth(tabs.value);
      const wrapperClientWidth = getClientWidth(wrapper.value);
      requestAnimationFrame(() => {
        showPagination.value = !!(tabs.value && wrapper.value && tabsClientWidth > wrapperClientWidth);
      });
    };
    const movePaginationLeft = () => {
      var _a2, _b;
      const containerClientWidth = getClientWidth(container.value);
      let offsetToSet = tabsContentOffset.value - containerClientWidth;
      for (let i = 0; i < tabsList.value.length - 1; i++) {
        const currentTabLeftSidePosition = unref((_a2 = tabsList.value[i]) == null ? void 0 : _a2.leftSidePosition);
        const nextTabLeftSidePosition = unref((_b = tabsList.value[i + 1]) == null ? void 0 : _b.leftSidePosition);
        if (currentTabLeftSidePosition > offsetToSet && currentTabLeftSidePosition < tabsContentOffset.value || nextTabLeftSidePosition >= tabsContentOffset.value) {
          offsetToSet = currentTabLeftSidePosition;
          break;
        }
      }
      tabsContentOffset.value = Math.max(0, offsetToSet);
      emit("click:prev");
    };
    const movePaginationRight = () => {
      var _a2;
      const containerClientWidth = getClientWidth(container.value);
      const containerRightSide = tabsContentOffset.value + containerClientWidth;
      let offsetToSet = containerRightSide;
      for (let i = 0; i < tabsList.value.length - 1; i++) {
        const rightSidePosition2 = unref(tabsList.value[i].rightSidePosition);
        if (rightSidePosition2 > containerRightSide) {
          offsetToSet = unref(tabsList.value[i].leftSidePosition);
          if (tabsContentOffset.value < offsetToSet) {
            break;
          }
        }
      }
      const rightSidePosition = unref((_a2 = tabsList.value[tabsList.value.length - 1]) == null ? void 0 : _a2.rightSidePosition);
      const maxOffset = rightSidePosition - containerClientWidth;
      offsetToSet = Math.min(maxOffset, offsetToSet);
      tabsContentOffset.value = Math.max(0, offsetToSet);
      emit("click:next");
    };
    const updateSlider = (tab) => {
      var _a2;
      const tabElement = unref(tab.tabElement);
      const tabOffsetTop = (tabElement == null ? void 0 : tabElement.offsetTop) || 0;
      const tabOffsetLeft = (tabElement == null ? void 0 : tabElement.offsetLeft) || 0;
      const tabClientHeight = (tabElement == null ? void 0 : tabElement.clientHeight) || 0;
      const tabClientWidth = (tabElement == null ? void 0 : tabElement.clientWidth) || 0;
      if (props.vertical) {
        const containerClientHeight = ((_a2 = container.value) == null ? void 0 : _a2.clientHeight) || 0;
        const calculatedSliderOffsetY = containerClientHeight - tabOffsetTop - tabClientHeight;
        sliderOffsetY.value = Math.max(calculatedSliderOffsetY, 0);
        sliderHeight.value = tabClientHeight;
        sliderOffsetX.value = 0;
        sliderWidth.value = 0;
      } else {
        sliderOffsetX.value = tabOffsetLeft;
        sliderWidth.value = tabClientWidth;
        sliderOffsetY.value = 0;
        sliderHeight.value = 0;
      }
    };
    const includeAnimation = () => {
      if (!animationIncluded.value) {
        requestAnimationFrame(() => {
          animationIncluded.value = true;
        });
      }
    };
    const selectTab = (tab) => {
      var _a2;
      if (!tab) {
        return;
      }
      tabSelected.value = ((_a2 = tab.name) == null ? void 0 : _a2.value) || tab.id;
      if (props.stateful) {
        updateTabsState();
      }
    };
    const registerTab = (tab) => {
      var _a2;
      const idx = tabsList.value.push(tab) - 1;
      tab.id = ((_a2 = tab.name) == null ? void 0 : _a2.value) || idx;
    };
    const unregisterTab = (tab) => {
      tabsList.value = tabsList.value.filter((filteredTab) => filteredTab.id !== tab.id);
      tabsList.value.forEach((tabListItem, idx) => {
        var _a2;
        tabListItem.id = ((_a2 = tabListItem.name) == null ? void 0 : _a2.value) || idx;
      });
    };
    provide(TabsViewKey, {
      parentDisabled: props.disabled,
      selectTab,
      moveToTab,
      registerTab,
      unregisterTab
    });
    watch(() => props.modelValue, updateTabsState);
    useResizeObserver([wrapper], updatePagination);
    useResizeObserver([container], updateTabsState);
    onMounted(() => {
      requestAnimationFrame(() => {
        includeAnimation();
      });
    });
    __expose({
      selectTab,
      moveToTab,
      movePaginationLeft,
      movePaginationRight
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["va-tabs", computedTabsClass.value])
      }, [
        createBaseVNode("div", {
          ref_key: "wrapper",
          ref: wrapper,
          class: "va-tabs__wrapper",
          role: "tablist",
          "aria-disabled": _ctx.$props.disabled
        }, [
          showPagination.value && !_ctx.$props.hidePagination ? (openBlock(), createBlock(unref(VaButton), {
            key: 0,
            class: "va-tabs__pagination",
            "aria-label": unref(tp)(_ctx.$props.ariaMoveLeftLabel),
            size: "medium",
            disabled: disablePaginationLeft.value,
            color: __props.color,
            preset: "secondary",
            icon: _ctx.$props.prevIcon,
            onClick: movePaginationLeft
          }, null, 8, ["aria-label", "disabled", "color", "icon"])) : createCommentVNode("", true),
          createBaseVNode("div", {
            ref_key: "container",
            ref: container,
            class: normalizeClass(["va-tabs__container", computedClass.value])
          }, [
            createBaseVNode("div", {
              ref_key: "tabs",
              ref: tabs,
              class: "va-tabs__tabs",
              style: normalizeStyle(paginationControlledStyles.value)
            }, [
              createBaseVNode("div", {
                class: "va-tabs__slider-wrapper",
                "aria-hidden": "true",
                style: normalizeStyle(sliderStyles.value)
              }, _hoisted_321, 4),
              createVNode(unref(_sfc_main), { components: tabConfig }, {
                default: withCtx(() => [
                  createBaseVNode("div", _hoisted_412, [
                    renderSlot(_ctx.$slots, "tabs")
                  ])
                ]),
                _: 3
              }, 8, ["components"])
            ], 4)
          ], 2),
          showPagination.value && !_ctx.$props.hidePagination ? (openBlock(), createBlock(unref(VaButton), {
            key: 1,
            class: "va-tabs__pagination",
            "aria-label": unref(tp)(_ctx.$props.ariaMoveRightLabel),
            size: "medium",
            color: __props.color,
            disabled: disablePaginationRight.value,
            preset: "secondary",
            icon: _ctx.$props.nextIcon,
            onClick: movePaginationRight
          }, null, 8, ["aria-label", "color", "disabled", "icon"])) : createCommentVNode("", true)
        ], 8, _hoisted_163),
        createBaseVNode("div", _hoisted_510, [
          renderSlot(_ctx.$slots, "default")
        ])
      ], 2);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-tabs/VaTabs.js
var _style_095 = ':root,\n:host {\n  --va-tabs-display: flex;\n  --va-tabs-align-items-horizontal: center;\n  --va-tabs-align-items-vertical: stretch;\n  /* Container */\n  --va-tabs-container-height: 2rem;\n  --va-tabs-container-margin: 0 3px;\n  /* Slider */\n  --va-tabs-slider-width: 0.125rem;\n  --va-tabs-slider-height: 0.125rem;\n  --va-tabs-slider-transition: transform ease 0.3s;\n  /* Slider Wrapper */\n  --va-tabs-slider-wrapper-bottom: 0;\n  --va-tabs-slider-wrapper-margin: 0;\n  --va-tabs-slider-wrapper-z-index: 4000;\n  --va-tabs-slider-wrapper-transition: 0.3s cubic-bezier(0.25, 0.8, 0.5, 1);\n}\n.va-tabs {\n  display: var(--va-tabs-display);\n  align-items: var(--va-tabs-align-items-horizontal);\n  flex-direction: column;\n  position: relative;\n  font-family: var(--va-font-family);\n}\n.va-tabs__wrapper {\n  overflow: hidden;\n  contain: content;\n  display: flex;\n  flex: 1 1 auto;\n  width: 100%;\n}\n.va-tabs .va-tabs__pagination {\n  flex: 0 0 auto;\n}\n.va-tabs .va-tabs__container {\n  overflow: hidden;\n  flex: 1 1 auto;\n  display: flex;\n  height: var(--va-tabs-container-height);\n  margin: var(--va-tabs-container-margin);\n  white-space: nowrap;\n  position: relative;\n}\n.va-tabs .va-tabs__container .va-tabs__tabs {\n  height: 100%;\n}\n.va-tabs .va-tabs__container .va-tabs__tabs-items {\n  display: flex;\n}\n.va-tabs .va-tabs__container--right {\n  justify-content: flex-end;\n}\n.va-tabs .va-tabs__container--grow .va-tabs__tabs {\n  display: flex;\n  min-width: 100%;\n}\n.va-tabs .va-tabs__container--grow .va-tabs__tabs-items {\n  width: 100%;\n}\n.va-tabs .va-tabs__container--grow .va-tab {\n  flex: 1 0 auto;\n  max-width: none;\n}\n.va-tabs .va-tabs__container--center {\n  justify-content: center;\n}\n.va-tabs .va-tabs__container--disabled {\n  cursor: default;\n  opacity: 0.4;\n  pointer-events: none;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n          user-select: none;\n  pointer-events: none;\n}\n.va-tabs--vertical {\n  align-items: var(--va-tabs-align-items-vertical);\n  flex-direction: row;\n}\n.va-tabs--vertical .va-tabs__wrapper {\n  flex: 0 0 auto;\n  width: unset;\n}\n.va-tabs--vertical .va-tabs__container {\n  height: auto;\n}\n.va-tabs--vertical .va-tabs__container .va-tabs__tabs-items {\n  flex-direction: column;\n}\n.va-tabs--vertical .va-tabs__container .va-tabs__tabs {\n  position: relative;\n}\n.va-tabs--vertical .va-tab {\n  display: flex;\n}\n.va-tabs--vertical .va-tab__content {\n  flex: 0 0 auto;\n}\n.va-tabs--vertical .va-tabs__content {\n  flex: 1 0 auto;\n}\n.va-tabs .va-tabs__slider-wrapper {\n  bottom: var(--va-tabs-slider-wrapper-bottom);\n  margin: var(--va-tabs-slider-wrapper-margin);\n  position: absolute;\n  z-index: var(--va-tabs-slider-wrapper-z-index);\n}\n.va-tabs .va-tabs__slider-wrapper .va-tabs__slider {\n  width: var(--va-tabs-slider-width);\n  height: var(--va-tabs-slider-height);\n}\n.va-tabs .va-button:focus-visible {\n  outline: 2px solid var(--va-focus) !important;\n  border-radius: "inherit";\n  outline-offset: -2px;\n}';
var _VaTabs = _export_sfc(_sfc_main101, [["styles", [_style_095]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-tabs/index.js
var VaTabs = withConfigTransport$1(_VaTabs);

// node_modules/vuestic-ui/dist/web-components/src/components/va-tabs/components/VaTab/VaTab.vue_vue_type_script_setup_true_lang.js
var _hoisted_164 = ["tabindex"];
var _hoisted_233 = ["textContent"];
var _sfc_main102 = defineComponent({
  ...{
    name: "VaTab"
  },
  __name: "VaTab",
  props: {
    ...useRouterLinkProps,
    ...useComponentPresetProp,
    selected: { type: Boolean, default: false },
    color: { type: String, default: "" },
    icon: { type: String, default: "" },
    label: { type: String, default: "" },
    disabled: { type: Boolean },
    name: { type: [String, Number] },
    tag: { type: String, default: "div" }
  },
  emits: ["click", "keydown-enter", "focus"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const tabElement = shallowRef();
    const isActive = ref(false);
    const hoverState = ref(false);
    const rightSidePosition = ref(0);
    const leftSidePosition = ref(0);
    const { keyboardFocusListeners, hasKeyboardFocus } = useKeyboardOnlyFocus();
    const { tagComputed, hrefComputed, isActiveRouterLink } = useRouterLink(props);
    const classComputed = computed(() => ({ "va-tab--disabled": props.disabled }));
    const {
      parentDisabled,
      selectTab,
      moveToTab,
      registerTab,
      unregisterTab
    } = inject(TabsViewKey, {
      parentDisabled: false,
      tabsList: [],
      selectTab: (tab) => tab,
      moveToTab: (tab) => tab,
      registerTab: (tab) => tab,
      unregisterTab: (tab) => tab
    });
    const tabIndexComputed = computed(() => props.disabled || parentDisabled ? -1 : 0);
    const { getColor } = useColors();
    const colorComputed = computed(() => getColor(props.color));
    const computedStyle = computed(() => ({
      color: hoverState.value || isActive.value ? colorComputed.value : "inherit"
    }));
    const updateHoverState = (isHover) => {
      hoverState.value = isHover;
    };
    const updateSidePositions = () => {
      var _a2, _b;
      const componentOffsetLeft = ((_a2 = tabElement.value) == null ? void 0 : _a2.offsetLeft) || 0;
      const componentOffsetWidth = ((_b = tabElement.value) == null ? void 0 : _b.offsetWidth) || 0;
      rightSidePosition.value = componentOffsetLeft + componentOffsetWidth;
      leftSidePosition.value = componentOffsetLeft;
    };
    const onTabClick = () => {
      selectTab(tabComponent);
      emit("click");
    };
    const onTabKeydown = () => {
      selectTab(tabComponent);
      emit("keydown-enter");
    };
    const onFocus = () => {
      if (hasKeyboardFocus.value) {
        moveToTab(tabComponent);
      }
      emit("focus");
    };
    const tabComponent = {
      name: computed(() => props.name),
      id: null,
      tabElement,
      isActive,
      tabIndexComputed,
      isActiveRouterLink,
      rightSidePosition,
      leftSidePosition,
      onTabClick,
      onTabKeydown,
      onFocus,
      updateSidePositions
    };
    onMounted(() => {
      registerTab(tabComponent);
    });
    onBeforeUnmount(() => {
      unregisterTab(tabComponent);
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(resolveDynamicComponent(unref(tagComputed)), {
        ref_key: "tabElement",
        ref: tabElement,
        class: normalizeClass(["va-tab", classComputed.value]),
        role: "tab",
        "aria-selected": isActive.value,
        "aria-disabled": _ctx.$props.disabled || unref(parentDisabled),
        href: unref(hrefComputed),
        target: _ctx.target,
        to: _ctx.to,
        replace: _ctx.replace,
        exact: _ctx.exact,
        "active-class": _ctx.activeClass,
        "exact-active-class": _ctx.exactActiveClass,
        style: normalizeStyle(computedStyle.value),
        onMouseenter: _cache[0] || (_cache[0] = ($event) => updateHoverState(true)),
        onMouseleave: _cache[1] || (_cache[1] = ($event) => updateHoverState(false))
      }, {
        default: withCtx(() => [
          createBaseVNode("div", mergeProps({
            class: "va-tab__content",
            tabindex: tabIndexComputed.value,
            onFocus,
            onClick: onTabClick,
            onKeydown: withKeys(onTabKeydown, ["enter"])
          }, toHandlers(unref(keyboardFocusListeners), true)), [
            renderSlot(_ctx.$slots, "default", {}, () => [
              __props.icon ? (openBlock(), createBlock(unref(VaIcon), {
                key: 0,
                class: "va-tab__icon",
                size: "small",
                name: __props.icon
              }, null, 8, ["name"])) : createCommentVNode("", true),
              createBaseVNode("span", {
                class: "va-tab__label",
                textContent: toDisplayString(__props.label)
              }, null, 8, _hoisted_233)
            ])
          ], 16, _hoisted_164)
        ]),
        _: 3
      }, 40, ["aria-selected", "aria-disabled", "href", "target", "to", "replace", "exact", "active-class", "exact-active-class", "class", "style"]);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-tabs/components/VaTab/VaTab.js
var _style_096 = ":root,\n:host {\n  --va-tab-align-items: center;\n  --va-tab-display: inline-flex;\n  --va-tab-flex: 0 1 auto;\n  --va-tab-font-weight: 600;\n  --va-tab-line-height: normal;\n  --va-tab-height: inherit;\n  --va-tab-max-width: 264px;\n  --va-tab-text-align: center;\n  --va-tab-vertical-align: middle;\n  --va-tab-color: inherit;\n  /* Content */\n  --va-tab-content-align-items: center;\n  --va-tab-content-color: inherit;\n  --va-tab-content-display: flex;\n  --va-tab-content-flex: 1 1 auto;\n  --va-tab-content-height: 100%;\n  --va-tab-content-justify-content: center;\n  --va-tab-content-max-width: inherit;\n  --va-tab-content-text-decoration: none;\n  --va-tab-content-transition: $transition-primary;\n  --va-tab-content-user-select: none;\n  --va-tab-content-white-space: nowrap;\n  --va-tab-content-padding: 0.275rem 0.75rem;\n  --va-tab-content-cursor: pointer;\n  /* Icon */\n  --va-tab-icon-margin-right: 0.5rem;\n}\n.va-tab {\n  align-items: var(--va-tab-align-items);\n  display: var(--va-tab-display);\n  flex: var(--va-tab-flex);\n  font-weight: var(--va-tab-font-weight);\n  line-height: var(--va-tab-line-height);\n  height: var(--va-tab-height);\n  max-width: var(--va-tab-max-width);\n  text-align: var(--va-tab-text-align);\n  vertical-align: var(--va-tab-vertical-align);\n  color: var(--va-tab-color);\n}\n.va-tab__content {\n  align-items: var(--va-tab-content-align-items);\n  color: var(--va-tab-content-color);\n  display: var(--va-tab-content-display);\n  flex: var(--va-tab-content-flex);\n  height: var(--va-tab-content-height);\n  justify-content: var(--va-tab-content-justify-content);\n  max-width: var(--va-tab-content-max-width);\n  -webkit-text-decoration: var(--va-tab-content-text-decoration);\n          text-decoration: var(--va-tab-content-text-decoration);\n  transition: var(--va-tab-content-transition);\n  -webkit-user-select: var(--va-tab-content-user-select);\n     -moz-user-select: var(--va-tab-content-user-select);\n          user-select: var(--va-tab-content-user-select);\n  white-space: var(--va-tab-content-white-space);\n  padding: var(--va-tab-content-padding);\n  cursor: var(--va-tab-content-cursor);\n}\n.va-tab__content:focus-visible {\n  outline: 2px solid var(--va-focus) !important;\n  border-radius: 2px;\n  outline-offset: -2px;\n}\n.va-tab__icon {\n  margin-right: var(--va-tab-icon-margin-right);\n}\n.va-tab.va-tab--disabled {\n  cursor: default;\n  opacity: 0.4;\n  pointer-events: none;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n          user-select: none;\n  pointer-events: none;\n}";
var _VaTab = _export_sfc(_sfc_main102, [["styles", [_style_096]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-tabs/components/VaTab/index.js
var VaTab = withConfigTransport$1(_VaTab);

// node_modules/vuestic-ui/dist/web-components/src/components/va-stepper/VaStepperControls.vue_vue_type_script_setup_true_lang.js
var _hoisted_165 = { class: "va-stepper__default-controls" };
var _sfc_main103 = defineComponent({
  ...{
    name: "VaStepperControls"
  },
  __name: "VaStepperControls",
  props: {
    modelValue: { type: Number, required: true },
    steps: {
      type: Array,
      required: true
    },
    nextDisabled: { type: Boolean, required: true },
    stepControls: { type: Object, required: true },
    finishButtonHidden: { type: Boolean, default: false }
  },
  setup(__props) {
    const props = __props;
    const { t } = useTranslation();
    const isLastStep = computed(() => {
      const lastEnabledStepIndex = props.steps.length - 1;
      return props.modelValue >= lastEnabledStepIndex;
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_165, [
        createVNode(unref(VaButton), {
          preset: "primary",
          disabled: _ctx.$props.modelValue <= 0,
          onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$props.stepControls.prevStep())
        }, {
          default: withCtx(() => [
            createTextVNode(toDisplayString(unref(t)("back")), 1)
          ]),
          _: 1
        }, 8, ["disabled"]),
        !isLastStep.value ? (openBlock(), createBlock(unref(VaButton), {
          key: 0,
          onClick: _cache[1] || (_cache[1] = ($event) => _ctx.$props.stepControls.nextStep()),
          disabled: _ctx.$props.nextDisabled
        }, {
          default: withCtx(() => [
            createTextVNode(toDisplayString(unref(t)("next")), 1)
          ]),
          _: 1
        }, 8, ["disabled"])) : !_ctx.$props.finishButtonHidden ? (openBlock(), createBlock(unref(VaButton), {
          key: 1,
          onClick: _cache[2] || (_cache[2] = ($event) => _ctx.$emit("finish"))
        }, {
          default: withCtx(() => [
            createTextVNode(toDisplayString(unref(t)("finish")), 1)
          ]),
          _: 1
        })) : createCommentVNode("", true)
      ]);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-stepper/VaStepperControls.js
var _style_097 = ":root {\n  --va-stepper-step-button-inactive-color: var(--va-secondary);\n  --va-stepper-step-button-hover-highlight-opacity: 0.1;\n  --va-stepper-step-button-disabled-opacity: 0.5;\n  --va-stepper-step-button-padding: 1rem;\n  --va-stepper-step-button-number-size: 1.2rem;\n  --va-stepper-step-button-icon-size: 2rem;\n  --va-stepper-step-button-gap: 0.5rem;\n  --va-stepper-step-button-icon-border-radius: 100%;\n  --va-stepper-step-border-radius: var(--va-square-border-radius);\n  --va-stepper-divider-color: var(--va-secondary);\n  --va-stepper-divider-length: auto;\n  --va-stepper-divider-min-length: 2rem;\n  --va-stepper-divider-thickness: 1px;\n  --va-stepper-divider-spacing: 0.5rem;\n  --va-stepper-divider-vertical-margin-left: 2rem;\n  --va-stepper-step-content-wrapper-padding: 0.5rem 1rem;\n  --va-stepper-step-content-margin: 0.8rem 0 2rem;\n  --va-stepper-controls-gap: 1rem;\n}\n.va-stepper__default-controls {\n  display: flex;\n  gap: var(--va-stepper-controls-gap);\n}";
var VaStepperControls = _export_sfc(_sfc_main103, [["styles", [_style_097]]]);

// node_modules/vuestic-ui/dist/web-components/src/utils/un-function.js
var unFunction = (fn, ...args) => {
  if (typeof fn === "function") {
    return fn(...args);
  }
  return fn;
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-stepper/VaStepperStepButton.vue_vue_type_script_setup_true_lang.js
var _hoisted_166 = { class: "va-stepper__step-button__icon" };
var _sfc_main104 = defineComponent({
  ...{
    name: "VaStepperStepButton"
  },
  __name: "VaStepperStepButton",
  props: {
    modelValue: { type: Number, required: true },
    step: {
      type: Object,
      required: true
    },
    color: { type: String, required: true },
    stepIndex: { type: Number, required: true },
    navigationDisabled: { type: Boolean, required: true },
    nextDisabled: { type: Boolean, required: true },
    focus: { type: Object, required: true },
    stepControls: { type: Object, required: true }
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: __emit }) {
    useCssVars((_ctx) => ({
      "74e91d2a": stepperColor.value
    }));
    const props = __props;
    const stepElement = shallowRef();
    const hasError = computed(() => props.step.hasError);
    const { getColor } = useColors();
    const stepperColor = computed(() => getColor(hasError.value ? "danger" : props.color));
    const isNextStepDisabled = (index) => props.nextDisabled && index > props.modelValue;
    const { t } = useTranslation();
    const computedClass = useBem("va-stepper__step-button", () => ({
      active: props.modelValue >= props.stepIndex,
      disabled: props.step.disabled || isNextStepDisabled(props.stepIndex),
      "navigation-disabled": props.navigationDisabled,
      error: unFunction(hasError.value, props.step) || false
    }));
    watch(() => props.focus, () => {
      if (props.focus.trigger) {
        nextTick(() => {
          var _a2;
          return (_a2 = stepElement.value) == null ? void 0 : _a2.focus();
        });
      }
    }, { deep: true });
    const ariaAttributesComputed = computed(() => ({
      tabindex: props.focus.stepIndex === props.stepIndex && !props.navigationDisabled ? 0 : void 0,
      "aria-disabled": props.step.disabled || isNextStepDisabled(props.stepIndex) ? true : void 0,
      "aria-current": props.modelValue === props.stepIndex ? t("step") : void 0
    }));
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("li", mergeProps({
        ref_key: "stepElement",
        ref: stepElement,
        class: ["va-stepper__step-button", unref(computedClass)],
        onClick: _cache[0] || (_cache[0] = ($event) => !_ctx.$props.navigationDisabled && _ctx.$props.stepControls.setStep(_ctx.$props.stepIndex)),
        onKeyup: [
          _cache[1] || (_cache[1] = withKeys(($event) => !_ctx.$props.navigationDisabled && _ctx.$props.stepControls.setStep(_ctx.$props.stepIndex), ["enter"])),
          _cache[2] || (_cache[2] = withKeys(($event) => !_ctx.$props.navigationDisabled && _ctx.$props.stepControls.setStep(_ctx.$props.stepIndex), ["space"]))
        ]
      }, ariaAttributesComputed.value), [
        createBaseVNode("div", _hoisted_166, [
          __props.step.icon ? (openBlock(), createBlock(unref(VaIcon), {
            key: 0,
            name: __props.step.icon,
            size: "1.3rem"
          }, null, 8, ["name"])) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
            createTextVNode(toDisplayString(_ctx.$props.stepIndex + 1), 1)
          ], 64))
        ]),
        createTextVNode(" " + toDisplayString(__props.step.label), 1)
      ], 16);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-stepper/VaStepperStepButton.js
var _style_098 = ':root {\n  --va-stepper-step-button-inactive-color: var(--va-secondary);\n  --va-stepper-step-button-hover-highlight-opacity: 0.1;\n  --va-stepper-step-button-disabled-opacity: 0.5;\n  --va-stepper-step-button-padding: 1rem;\n  --va-stepper-step-button-number-size: 1.2rem;\n  --va-stepper-step-button-icon-size: 2rem;\n  --va-stepper-step-button-gap: 0.5rem;\n  --va-stepper-step-button-icon-border-radius: 100%;\n  --va-stepper-step-border-radius: var(--va-square-border-radius);\n  --va-stepper-divider-color: var(--va-secondary);\n  --va-stepper-divider-length: auto;\n  --va-stepper-divider-min-length: 2rem;\n  --va-stepper-divider-thickness: 1px;\n  --va-stepper-divider-spacing: 0.5rem;\n  --va-stepper-divider-vertical-margin-left: 2rem;\n  --va-stepper-step-content-wrapper-padding: 0.5rem 1rem;\n  --va-stepper-step-content-margin: 0.8rem 0 2rem;\n  --va-stepper-controls-gap: 1rem;\n}\n.va-stepper__step-button {\n  position: relative;\n  display: flex;\n  flex-wrap: wrap;\n  align-items: center;\n  gap: var(--va-stepper-step-button-gap);\n  flex-shrink: 0;\n  padding: var(--va-stepper-step-button-padding);\n}\n.va-stepper__step-button:focus-visible {\n  outline: 2px solid var(--va-focus) !important;\n  border-radius: var(--va-stepper-step-border-radius);\n}\n.va-stepper__step-button::after {\n  content: "";\n  position: absolute;\n  cursor: pointer;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  background: var(--74e91d2a);\n  transition: opacity 0.3s;\n  opacity: 0;\n  border-radius: var(--va-stepper-step-border-radius);\n}\n.va-stepper__step-button__icon {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  height: var(--va-stepper-step-button-icon-size);\n  width: var(--va-stepper-step-button-icon-size);\n  font-size: var(--va-stepper-step-button-number-size);\n  color: white;\n  background: var(--va-stepper-step-button-inactive-color);\n  border-radius: var(--va-stepper-step-button-icon-border-radius);\n}\n.va-stepper__step-button--active {\n  color: var(--74e91d2a);\n}\n.va-stepper__step-button--active .va-stepper__step-button__icon {\n  background: var(--74e91d2a);\n}\n.va-stepper__step-button--disabled {\n  opacity: var(--va-stepper-step-button-disabled-opacity);\n  pointer-events: none;\n}\n.va-stepper__step-button:hover::after {\n  opacity: var(--va-stepper-step-button-hover-highlight-opacity);\n}\n.va-stepper__step-button--navigation-disabled::after {\n  display: none;\n}\n.va-stepper__step-button--error {\n  color: var(--va-danger);\n}\n.va-stepper__step-button--error .va-stepper__step-button__icon {\n  background: var(--va-danger);\n}';
var VaStepperStepButton = _export_sfc(_sfc_main104, [["styles", [_style_098]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-stepper/VaStepper.vue_vue_type_script_setup_true_lang.js
var _hoisted_167 = {
  key: 0,
  class: "va-stepper__step-content"
};
var _hoisted_234 = { class: "va-stepper__controls" };
var _sfc_main105 = defineComponent({
  ...{
    name: "VaStepper"
  },
  __name: "VaStepper",
  props: {
    ...useStatefulProps,
    modelValue: { type: Number, default: 0 },
    steps: {
      type: Array,
      default: () => [],
      required: true
    },
    color: { type: String, default: "primary" },
    vertical: { type: Boolean, default: false },
    navigationDisabled: { type: Boolean, default: false },
    controlsHidden: { type: Boolean, default: false },
    nextDisabled: { type: Boolean, default: false },
    finishButtonHidden: { type: Boolean, default: false },
    ariaLabel: { type: String, default: "$t:progress" },
    linear: { type: Boolean, default: false }
  },
  emits: ["update:modelValue", "finish", "update:steps"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const stepperNavigation = shallowRef();
    const { valueComputed: modelValue } = useStateful(props, emit, "modelValue");
    const focusedStep = ref({ trigger: false, stepIndex: props.navigationDisabled ? -1 : props.modelValue });
    const { getColor } = useColors();
    const isNextStepDisabled = (index) => props.nextDisabled && index > modelValue.value;
    const findFirstNonDisabled = (from, direction) => {
      while (from >= 0 && from < props.steps.length) {
        from += direction;
        const step = props.steps[from];
        if (!step) {
          return;
        }
        if (!step.disabled) {
          return step;
        }
      }
    };
    const findFirstWithErrorIndex = (from, direction) => {
      while (from >= 0 && from < props.steps.length) {
        from += direction;
        const step = props.steps[from];
        if (!step) {
          return;
        }
        if (step.hasError === true) {
          return from;
        }
      }
    };
    const validateMovingToStep = (stepIndex) => {
      var _a2;
      const newStep = props.steps[stepIndex];
      const currentStep = props.steps[modelValue.value];
      const beforeNewStep = findFirstNonDisabled(stepIndex, -1);
      if (newStep.disabled) {
        return false;
      }
      if (props.linear && stepIndex < modelValue.value) {
        return true;
      }
      const nextNonError = findFirstWithErrorIndex(modelValue.value, 1);
      if (props.linear && nextNonError !== void 0 && nextNonError < stepIndex) {
        return false;
      }
      if (((_a2 = currentStep.beforeLeave) == null ? void 0 : _a2.call(currentStep, currentStep, newStep)) === false) {
        return false;
      }
      if (currentStep.completed === void 0) {
        currentStep.completed = true;
      }
      if (props.linear && beforeNewStep && !beforeNewStep.completed) {
        return false;
      }
      if (props.linear && unFunction(currentStep.hasError, currentStep)) {
        return false;
      }
      return true;
    };
    const setStep = (index) => {
      if (!validateMovingToStep(index)) {
        return;
      }
      emit("update:modelValue", index);
    };
    const setFocus = (direction) => {
      if (props.navigationDisabled) {
        return;
      }
      if (direction === "next") {
        setFocusNextStep(1);
      } else {
        setFocusPrevStep(1);
      }
    };
    const setFocusNextStep = (idx) => {
      const newValue = focusedStep.value.stepIndex + idx;
      if (isNextStepDisabled(newValue)) {
        return;
      }
      if (newValue < props.steps.length) {
        if (props.steps[newValue].disabled) {
          setFocusNextStep(idx + 1);
          return;
        }
        focusedStep.value.stepIndex = newValue;
        focusedStep.value.trigger = true;
      } else {
        for (let availableIdx = 0; availableIdx < props.steps.length; availableIdx++) {
          if (!props.steps[availableIdx].disabled) {
            focusedStep.value.stepIndex = availableIdx;
            focusedStep.value.trigger = true;
            break;
          }
        }
      }
    };
    const setFocusPrevStep = (idx) => {
      const newValue = focusedStep.value.stepIndex - idx;
      if (newValue >= 0) {
        if (props.steps[newValue].disabled) {
          setFocusPrevStep(idx + 1);
          return;
        }
        focusedStep.value.stepIndex = newValue;
        focusedStep.value.trigger = true;
      } else {
        for (let availableIdx = props.steps.length - 1; availableIdx >= 0; availableIdx--) {
          if (!props.steps[availableIdx].disabled && !isNextStepDisabled(availableIdx)) {
            focusedStep.value.stepIndex = availableIdx;
            focusedStep.value.trigger = true;
            break;
          }
        }
      }
    };
    const resetFocus = () => {
      requestAnimationFrame(() => {
        var _a2;
        if (!((_a2 = stepperNavigation.value) == null ? void 0 : _a2.contains(document.activeElement))) {
          focusedStep.value.stepIndex = props.modelValue;
          focusedStep.value.trigger = false;
        }
      });
    };
    watch(() => props.modelValue, () => {
      focusedStep.value.stepIndex = props.modelValue;
      focusedStep.value.trigger = false;
    });
    const nextStep = (stepsToSkip = 0) => {
      const targetIndex = modelValue.value + 1 + stepsToSkip;
      if (!props.steps[targetIndex]) {
        return;
      }
      if (props.steps[targetIndex].disabled) {
        nextStep(stepsToSkip + 1);
      }
      setStep(targetIndex);
    };
    const prevStep = (stepsToSkip = 0) => {
      const targetIndex = modelValue.value - 1 - stepsToSkip;
      if (!props.steps[targetIndex]) {
        return;
      }
      if (props.steps[targetIndex].disabled) {
        prevStep(stepsToSkip + 1);
      }
      setStep(targetIndex);
    };
    const stepControls = { setStep, nextStep, prevStep };
    const getIterableSlotData = (step, index) => ({
      ...stepControls,
      focus: focusedStep,
      isActive: props.modelValue === index,
      isCompleted: props.modelValue > index,
      isLastStep: props.steps.length - 1 === index,
      isNextStepDisabled: isNextStepDisabled(index),
      index,
      step
    });
    const { tp } = useTranslation();
    const onArrowKeyPress = (direction) => {
      setFocus(direction);
    };
    const onValueChange = () => {
      focusedStep.value.stepIndex = props.modelValue;
      focusedStep.value.trigger = true;
    };
    const ariaAttributesComputed = computed(() => ({
      role: "group",
      "aria-label": tp(props.ariaLabel),
      "aria-orientation": props.vertical ? "vertical" : "horizontal"
    }));
    function getStepperButtonColor(index) {
      var _a2;
      return ((_a2 = props.steps[index]) == null ? void 0 : _a2.hasError) ? "danger" : getColor(props.color);
    }
    const completeStep = (shouldCompleteStep) => {
      const steps = { ...props.steps };
      if (shouldCompleteStep === true) {
        steps[props.modelValue].hasError = false;
      }
      steps[props.modelValue].completed = shouldCompleteStep ?? true;
      emit("update:steps", steps);
    };
    const setError = (shouldSetError) => {
      const steps = { ...props.steps };
      steps[props.modelValue].hasError = shouldSetError ?? true;
      steps[props.modelValue].completed = !shouldSetError;
      emit("update:steps", steps);
    };
    __expose({
      modelValue,
      focusedStep,
      getIterableSlotData,
      stepControls,
      nextStep,
      prevStep,
      setStep,
      setFocus,
      completeStep,
      setError
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", mergeProps({
        class: ["va-stepper", { "va-stepper--vertical": _ctx.$props.vertical }]
      }, ariaAttributesComputed.value), [
        createBaseVNode("ol", {
          class: normalizeClass(["va-stepper__navigation", { "va-stepper__navigation--vertical": _ctx.$props.vertical }]),
          ref_key: "stepperNavigation",
          ref: stepperNavigation,
          onClick: onValueChange,
          onKeyup: [
            withKeys(onValueChange, ["enter"]),
            withKeys(onValueChange, ["space"]),
            _cache[0] || (_cache[0] = withKeys(($event) => onArrowKeyPress("prev"), ["left"])),
            _cache[1] || (_cache[1] = withKeys(($event) => onArrowKeyPress("next"), ["right"]))
          ],
          onFocusout: resetFocus
        }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.$props.steps, (step, i) => {
            return openBlock(), createElementBlock(Fragment, {
              key: i + step.label
            }, [
              i > 0 ? renderSlot(_ctx.$slots, "divider", normalizeProps(mergeProps({ key: 0 }, getIterableSlotData(step, i))), () => [
                createBaseVNode("span", {
                  class: normalizeClass(["va-stepper__divider", { "va-stepper__divider--vertical": _ctx.$props.vertical }]),
                  "aria-hidden": "true"
                }, null, 2)
              ]) : createCommentVNode("", true),
              renderSlot(_ctx.$slots, `step-button-${i}`, normalizeProps(guardReactiveProps(getIterableSlotData(step, i))), () => [
                createVNode(VaStepperStepButton, {
                  stepIndex: i,
                  color: getStepperButtonColor(i),
                  modelValue: unref(modelValue),
                  nextDisabled: __props.nextDisabled,
                  step,
                  stepControls,
                  navigationDisabled: __props.navigationDisabled,
                  focus: focusedStep.value
                }, null, 8, ["stepIndex", "color", "modelValue", "nextDisabled", "step", "navigationDisabled", "focus"])
              ])
            ], 64);
          }), 128))
        ], 34),
        createBaseVNode("div", {
          class: normalizeClass(["va-stepper__step-content-wrapper", { "va-stepper__step-content-wrapper--vertical": _ctx.$props.vertical }])
        }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.$props.steps, (step, i) => {
            return openBlock(), createElementBlock(Fragment, { key: i }, [
              _ctx.$slots[`step-content-${i}`] && unref(modelValue) === i ? (openBlock(), createElementBlock("div", _hoisted_167, [
                renderSlot(_ctx.$slots, `step-content-${i}`, normalizeProps(guardReactiveProps(getIterableSlotData(step, i))))
              ])) : createCommentVNode("", true)
            ], 64);
          }), 128)),
          createBaseVNode("div", _hoisted_234, [
            !__props.controlsHidden ? (openBlock(), createBlock(VaStepperControls, {
              key: 0,
              modelValue: unref(modelValue),
              nextDisabled: __props.nextDisabled,
              steps: __props.steps,
              stepControls,
              finishButtonHidden: __props.finishButtonHidden,
              onFinish: _cache[2] || (_cache[2] = ($event) => _ctx.$emit("finish"))
            }, null, 8, ["modelValue", "nextDisabled", "steps", "finishButtonHidden"])) : createCommentVNode("", true),
            renderSlot(_ctx.$slots, "controls", normalizeProps(guardReactiveProps(getIterableSlotData(__props.steps[unref(modelValue)], unref(modelValue)))))
          ])
        ], 2)
      ], 16);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-stepper/VaStepper.js
var _style_099 = ":root {\n  --va-stepper-step-button-inactive-color: var(--va-secondary);\n  --va-stepper-step-button-hover-highlight-opacity: 0.1;\n  --va-stepper-step-button-disabled-opacity: 0.5;\n  --va-stepper-step-button-padding: 1rem;\n  --va-stepper-step-button-number-size: 1.2rem;\n  --va-stepper-step-button-icon-size: 2rem;\n  --va-stepper-step-button-gap: 0.5rem;\n  --va-stepper-step-button-icon-border-radius: 100%;\n  --va-stepper-step-border-radius: var(--va-square-border-radius);\n  --va-stepper-divider-color: var(--va-secondary);\n  --va-stepper-divider-length: auto;\n  --va-stepper-divider-min-length: 2rem;\n  --va-stepper-divider-thickness: 1px;\n  --va-stepper-divider-spacing: 0.5rem;\n  --va-stepper-divider-vertical-margin-left: 2rem;\n  --va-stepper-step-content-wrapper-padding: 0.5rem 1rem;\n  --va-stepper-step-content-margin: 0.8rem 0 2rem;\n  --va-stepper-controls-gap: 1rem;\n}\n.va-stepper {\n  display: flex;\n  flex-direction: column;\n}\n.va-stepper--vertical {\n  flex-direction: row;\n}\n.va-stepper__navigation {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  flex-wrap: wrap;\n}\n.va-stepper__navigation--vertical {\n  flex-direction: column;\n  align-items: flex-start;\n  flex-wrap: nowrap;\n}\n.va-stepper__divider {\n  flex-grow: 1;\n  height: var(--va-stepper-divider-thickness);\n  width: var(--va-stepper-divider-length);\n  min-width: var(--va-stepper-divider-min-length);\n  margin: 0 var(--va-stepper-divider-spacing);\n  background: var(--va-stepper-divider-color);\n}\n.va-stepper__divider--vertical {\n  min-height: var(--va-stepper-divider-min-length);\n  height: var(--va-stepper-divider-length);\n  width: var(--va-stepper-divider-thickness);\n  min-width: var(--va-stepper-divider-thickness);\n  margin: var(--va-stepper-divider-spacing) 0;\n  margin-left: var(--va-stepper-divider-vertical-margin-left);\n}\n.va-stepper__step-content-wrapper {\n  padding: var(--va-stepper-step-content-wrapper-padding);\n}\n.va-stepper__step-content {\n  margin: var(--va-stepper-step-content-margin);\n}\n.va-stepper__controls {\n  display: flex;\n  gap: var(--va-stepper-controls-gap);\n}";
var _VaStepper = _export_sfc(_sfc_main105, [["styles", [_style_099]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-stepper/index.js
var VaStepper = withConfigTransport$1(_VaStepper);
var defineVaStepperSteps = (steps) => steps;

// node_modules/vuestic-ui/dist/web-components/src/components/va-time-input/hooks/time-text-parser.js
var parse = (text) => {
  const m = text.match(/[0-9]{1,2}/g);
  if (!m) {
    return [];
  }
  return m.map((s) => Number(s));
};
var parsePeriod = (text) => {
  const m = text.match(/pm|am/i);
  if (!m) {
    return null;
  }
  return Number(m[0].toLowerCase() === "pm");
};
var defaultParseDateFunction2 = (text) => {
  const d = /* @__PURE__ */ new Date();
  const [h2, m, s] = parse(text);
  const period = parsePeriod(text);
  if (!h2) {
    return null;
  }
  const is12format = period !== null && h2 <= 12;
  const isPM = is12format && !!period;
  const fh = is12format ? h2 === 12 ? 0 : h2 : h2;
  d.setHours(Math.min(fh || 0, is12format ? 12 : 24) + (isPM ? 12 : 0));
  d.setMinutes(Math.min(m || 0, 60));
  d.setSeconds(Math.min(s || 0, 60));
  return d;
};
var useTimeParser = (props) => {
  const getParseDateFn = () => props.parse || defaultParseDateFunction2;
  const isValid = ref(true);
  const parseDate = (text) => {
    const parse3 = getParseDateFn();
    const result = parse3(text);
    if (!result) {
      isValid.value = false;
    }
    return result;
  };
  const parse2 = (text) => {
    isValid.value = true;
    return parseDate(text);
  };
  return {
    parse: parse2,
    isValid
  };
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-time-input/hooks/time-text-formatter.js
var useTimeFormatter = (props) => {
  const formatDate = (date) => {
    if (!date) {
      return "";
    }
    if (props.ampm) {
      return date.toLocaleTimeString("en-US");
    }
    return date.toLocaleTimeString("en-GB");
  };
  const sliceTime = (time, start, end) => time.split(":").slice(start, end).join(":");
  const formatWithView = (date) => {
    if (props.view === "seconds") {
      return formatDate(date);
    }
    const [time, period] = formatDate(date).split(" ");
    if (props.view === "minutes") {
      if (!period) {
        return sliceTime(time, 0, 2);
      }
      return [sliceTime(time, 0, 2), period].join(" ");
    }
    if (props.view === "hours") {
      if (!period) {
        return sliceTime(time, 0, 1);
      }
      return [sliceTime(time, 0, 1), period].join(" ");
    }
    return "";
  };
  return {
    format: (date) => props.format ? props.format(date) : formatWithView(date)
  };
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-time-picker/hooks/useTimePicker.js
var safeModelValue = (m) => m.value ? m.value : new Date((/* @__PURE__ */ new Date()).setHours(0, 0, 0, 0));
var createNumbersArray = (length) => Array.from(Array(length).keys());
var from24to12 = (h2) => (h2 === 0 ? 12 : h2) - Number(h2 > 12) * 12;
var from12to24 = (h2, isAM = false) => (h2 === 12 ? 0 : h2) + Number(isAM) * 12;
var createHoursColumn = (props, modelValue, isPM) => {
  const computedSize = computed(() => props.ampm ? 12 : 24);
  const items2 = computed(() => {
    let array = createNumbersArray(computedSize.value);
    if (props.hoursFilter) {
      array = array.filter((i) => props.hoursFilter(props.ampm ? i + 12 * Number(isPM.value) : i));
    }
    return array.map((n) => {
      return props.ampm ? from24to12(n) : n;
    });
  });
  const activeItem = computed({
    get: () => {
      if (!modelValue.value) {
        return -1;
      }
      if (props.ampm) {
        const h22 = from24to12(modelValue.value.getHours() - 12 * Number(isPM.value));
        return items2.value.findIndex((i) => i === h22);
      }
      const h2 = modelValue.value.getHours();
      return items2.value.findIndex((i) => i === h2);
    },
    set: (newIndex) => {
      if (props.readonly) {
        return;
      }
      const hours = props.ampm ? from12to24(items2.value[newIndex], isPM.value) : items2.value[newIndex];
      modelValue.value = new Date(safeModelValue(modelValue).setHours(hours));
    }
  });
  return computed(() => ({
    items: items2.value,
    activeItem
  }));
};
var createMinutesColumn = (props, modelValue) => {
  const items2 = computed(() => {
    const array = createNumbersArray(60);
    if (!props.minutesFilter) {
      return array;
    }
    return array.filter(props.minutesFilter);
  });
  const activeItem = computed({
    get: () => {
      if (!modelValue.value) {
        return -1;
      }
      const m = modelValue.value.getMinutes();
      return items2.value.findIndex((i) => i === m);
    },
    set: (newIndex) => {
      if (props.readonly) {
        return;
      }
      const v = items2.value[newIndex];
      modelValue.value = new Date(safeModelValue(modelValue).setMinutes(v));
    }
  });
  return computed(() => ({
    items: items2.value,
    activeItem
  }));
};
var createSecondsColumn = (props, modelValue) => {
  const items2 = computed(() => {
    const array = createNumbersArray(60);
    if (!props.secondsFilter) {
      return array;
    }
    return array.filter(props.secondsFilter);
  });
  const activeItem = computed({
    get: () => {
      if (!modelValue.value) {
        return -1;
      }
      const s = modelValue.value.getSeconds();
      return items2.value.findIndex((i) => i === s);
    },
    set: (newIndex) => {
      if (props.readonly) {
        return;
      }
      const v = items2.value[newIndex];
      modelValue.value = new Date(safeModelValue(modelValue).setSeconds(v));
    }
  });
  return computed(() => ({
    items: items2.value,
    activeItem
  }));
};
var createPeriodColumn = (props, modelValue, isPM) => {
  return computed(() => ({
    items: ["AM", "PM"],
    activeItem: computed({
      get: () => {
        if (!modelValue.value) {
          return -1;
        }
        return Number(isPM.value);
      },
      set: (val) => {
        isPM.value = Boolean(val);
        const h2 = safeModelValue(modelValue).getHours();
        let h24 = isPM.value ? h2 + 12 : h2;
        if (isPM.value && h2 <= 12) {
          h24 = h2 + 12;
        }
        if (!isPM.value && h2 >= 12) {
          h24 = h2 - 12;
        }
        const isValidFilteredHour = !props.hoursFilter || props.hoursFilter(h24);
        if (props.periodUpdatesModelValue && isValidFilteredHour) {
          modelValue.value = new Date(safeModelValue(modelValue).setHours(h24));
        }
      }
    })
  }));
};
var useTimePicker = (props, modelValue) => {
  const { view } = toRefs(props);
  const isPM = ref(false);
  watch(modelValue, () => {
    isPM.value = safeModelValue(modelValue).getHours() >= 12;
  }, { immediate: true });
  const hoursColumn = createHoursColumn(props, modelValue, isPM);
  const minutesColumn = createMinutesColumn(props, modelValue);
  const secondsColumn = createSecondsColumn(props, modelValue);
  const periodColumn = createPeriodColumn(props, modelValue, isPM);
  const columns = computed(() => {
    const array = [];
    if (view.value === "hours") {
      array.push(hoursColumn.value);
    } else if (view.value === "minutes") {
      array.push(hoursColumn.value, minutesColumn.value);
    } else if (view.value === "seconds") {
      array.push(hoursColumn.value, minutesColumn.value, secondsColumn.value);
    }
    if (props.ampm && !props.hidePeriodSwitch) {
      array.push(periodColumn.value);
    }
    return array;
  });
  return {
    columns,
    isPM
  };
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-time-picker/components/VaTimePickerColumnCell.vue_vue_type_script_setup_true_lang.js
var _sfc_main106 = defineComponent({
  ...{
    name: "VaTimePickerColumnCell"
  },
  __name: "VaTimePickerColumnCell",
  setup(__props) {
    const { isHovered, onMouseEnter, onMouseLeave } = useHover();
    const { getTextColor, getColor } = useColors();
    const styleComputed = computed(() => isHovered.value ? {
      color: getColor(getTextColor(getColor("background-secondary"))),
      background: getColor("background-secondary")
    } : void 0);
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        onMouseenter: _cache[0] || (_cache[0] = //@ts-ignore
        (...args) => unref(onMouseEnter) && unref(onMouseEnter)(...args)),
        onMouseleave: _cache[1] || (_cache[1] = //@ts-ignore
        (...args) => unref(onMouseLeave) && unref(onMouseLeave)(...args)),
        style: normalizeStyle(styleComputed.value)
      }, [
        renderSlot(_ctx.$slots, "default")
      ], 36);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-time-picker/components/VaTimePickerColumn/VaTimePickerColumn.vue_vue_type_script_setup_true_lang.js
var _hoisted_168 = ["onClick"];
var _sfc_main107 = defineComponent({
  ...{
    name: "VaTimePickerColumn"
  },
  __name: "VaTimePickerColumn",
  props: {
    items: { type: Array, default: () => [] },
    activeItemIndex: { type: Number, default: 0 },
    cellHeight: { type: Number, default: 30 }
  },
  emits: ["item-selected", "update:activeItemIndex", ...useFocusEmits],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const rootElement = shallowRef();
    const { focus, blur } = useFocus(rootElement, emit);
    const [syncActiveItemIndex] = useSyncProp("activeItemIndex", props, emit);
    watch(syncActiveItemIndex, (newVal) => {
      scrollTo(newVal);
    });
    onMounted(() => scrollTo(syncActiveItemIndex.value, false));
    const scrollTo = (index, animated = true) => {
      nextTick(() => {
        var _a2, _b;
        (_b = (_a2 = rootElement.value) == null ? void 0 : _a2.scrollTo) == null ? void 0 : _b.call(_a2, {
          behavior: animated ? "smooth" : "auto",
          top: index * props.cellHeight
        });
      });
    };
    const makeActiveNext = (times) => {
      syncActiveItemIndex.value = (syncActiveItemIndex.value + (times || 1)) % props.items.length;
      nextTick(() => scrollTo(syncActiveItemIndex.value));
    };
    const makeActivePrev = (times) => {
      syncActiveItemIndex.value = (syncActiveItemIndex.value - (times || 1) + props.items.length) % props.items.length;
      nextTick(() => scrollTo(syncActiveItemIndex.value));
    };
    const onCellClick = (index) => {
      syncActiveItemIndex.value = index;
    };
    const formatCell = (n) => {
      if (!Number.isInteger(n)) {
        return n;
      }
      return Number(n) < 10 ? `0${n}` : `${n}`;
    };
    const getIndex = () => {
      const scrollTop = rootElement.value.scrollTop;
      const calculatedIndex = Math.max(
        (scrollTop - scrollTop % props.cellHeight) / props.cellHeight,
        scrollTop / props.cellHeight
      );
      if (calculatedIndex >= props.items.length) {
        return props.items.length - 1;
      }
      if (calculatedIndex < 0) {
        return 0;
      }
      if (syncActiveItemIndex.value * props.cellHeight < scrollTop) {
        return Math.ceil(calculatedIndex);
      } else if (syncActiveItemIndex.value * props.cellHeight > scrollTop) {
        return Math.floor(calculatedIndex);
      } else {
        return Math.round(calculatedIndex);
      }
    };
    const onScroll = debounce$2(() => {
      if (rootElement.value && syncActiveItemIndex.value !== -1) {
        syncActiveItemIndex.value = getIndex();
      }
    }, 200);
    __expose({
      focus,
      blur
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        ref_key: "rootElement",
        ref: rootElement,
        tabindex: "0",
        class: "va-time-picker-column",
        onKeydown: [
          _cache[0] || (_cache[0] = withKeys(withModifiers(($event) => makeActiveNext(), ["stop", "prevent"]), ["down"])),
          _cache[1] || (_cache[1] = withKeys(withModifiers(($event) => makeActiveNext(5), ["stop", "prevent"]), ["space"])),
          _cache[2] || (_cache[2] = withKeys(withModifiers(($event) => makeActivePrev(), ["stop", "prevent"]), ["up"]))
        ]
      }, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(__props.items, (item, index) => {
          return openBlock(), createBlock(_sfc_main106, {
            key: item,
            onScrollPassive: unref(onScroll),
            onTouchmovePassive: unref(onScroll),
            onMousewheelPassive: unref(onScroll)
          }, {
            default: withCtx(() => [
              createBaseVNode("div", {
                class: normalizeClass(["va-time-picker-cell", { "va-time-picker-cell--active": index === _ctx.$props.activeItemIndex }]),
                onClick: ($event) => onCellClick(index)
              }, [
                renderSlot(_ctx.$slots, "cell", normalizeProps(guardReactiveProps({ item, index, activeItemIndex: __props.activeItemIndex, items: __props.items, formattedItem: formatCell(item) })), () => [
                  createTextVNode(toDisplayString(formatCell(item)), 1)
                ])
              ], 10, _hoisted_168)
            ]),
            _: 2
          }, 1032, ["onScrollPassive", "onTouchmovePassive", "onMousewheelPassive"]);
        }), 128))
      ], 544);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-time-picker/components/VaTimePickerColumn/VaTimePickerColumn.js
var _style_0100 = '.va-time-picker-column {\n  --va-time-picker-cell-height: 30px;\n  --va-time-picker-column-gap-height: calc(var(--va-time-picker-cell-height) * 2);\n  --va-time-picker-column-border-right: 1px solid var(--va-background-element);\n  --va-time-picker-cell-width: 40px;\n  --va-time-picker-cell-cursor: pointer;\n  --va-time-picker-cell-active-background: var(--va-primary);\n  --va-time-picker-cell-active-color: var(--va-primary);\n  --va-time-picker-cell-background-color-hover: transparent;\n  --va-time-picker-cell-active-background-opacity: 0.05;\n  --va-time-picker-cell-active-background-opacity-hover: 0.1;\n}\n.va-time-picker-column {\n  overflow-y: scroll;\n  -ms-overflow-style: none; /* IE and Edge */\n  scrollbar-width: none; /* Firefox */\n  color: currentColor;\n  height: 100%;\n  border-right: var(--va-time-picker-column-border-right);\n}\n.va-time-picker-column::-webkit-scrollbar { /* WebKit */\n  display: none;\n}\n.va-time-picker-column::before, .va-time-picker-column::after {\n  content: "";\n  display: block;\n  height: var(--va-time-picker-column-gap-height);\n  width: 100%;\n}\n.va-time-picker-column:last-child {\n  border-right: 0;\n}\n.va-time-picker-column .va-time-picker-cell {\n  height: var(--va-time-picker-cell-height);\n  line-height: var(--va-time-picker-cell-height);\n  width: var(--va-time-picker-cell-width);\n  text-align: center;\n  cursor: var(--va-time-picker-cell-cursor);\n  -webkit-user-select: none;\n     -moz-user-select: none;\n          user-select: none;\n}\n.va-time-picker-column .va-time-picker-cell--active {\n  position: relative;\n  color: var(--va-time-picker-cell-active-color);\n  z-index: 0;\n}\n.va-time-picker-column .va-time-picker-cell--active::before {\n  background: var(--va-time-picker-cell-active-background);\n  position: absolute;\n  height: 100%;\n  width: 100%;\n  left: 0;\n  right: 0;\n  content: "";\n  z-index: -1;\n  opacity: var(--va-time-picker-cell-active-background-opacity);\n}\n.va-time-picker-column .va-time-picker-cell:hover {\n  background: var(--va-time-picker-cell-background-color-hover);\n}\n.va-time-picker-column:focus-visible {\n  outline: none;\n}\n.va-time-picker-column:focus-visible .va-time-picker-cell--active {\n  outline: 2px solid var(--va-focus) !important;\n  border-radius: 4px;\n  outline-offset: -2px;\n}';
var _VaTimePickerColumn = _export_sfc(_sfc_main107, [["styles", [_style_0100]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-time-picker/components/VaTimePickerColumn/index.js
var VaTimePickerColumn = withConfigTransport$1(_VaTimePickerColumn);

// node_modules/vuestic-ui/dist/web-components/src/composables/useCSSVariables.js
var useCSSVariables = (prefix2, cb) => {
  return computed(() => Object.entries(cb()).reduce((acc, [key, value]) => {
    acc[`--${prefix2}-${kebabCase$1(key)}`] = value;
    return acc;
  }, {}));
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-time-picker/VaTimePicker.vue_vue_type_script_setup_true_lang.js
var _sfc_main108 = defineComponent({
  ...{
    name: "VaTimePicker"
  },
  __name: "VaTimePicker",
  props: {
    ...useStatefulProps,
    ...useFormFieldProps,
    ...useComponentPresetProp,
    modelValue: { type: Date, required: false },
    ampm: { type: Boolean, default: false },
    hidePeriodSwitch: { type: Boolean, default: false },
    periodUpdatesModelValue: { type: Boolean, default: true },
    // Update model value when switching period automatically
    view: { type: String, default: "minutes" },
    hoursFilter: { type: Function },
    minutesFilter: { type: Function },
    secondsFilter: { type: Function },
    framed: { type: Boolean, default: false },
    cellHeight: { type: Number, default: 30 },
    visibleCellsCount: { type: Number, default: 7 }
  },
  emits: [...useStatefulEmits],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const { valueComputed } = useStateful(props, emit);
    const { columns, isPM } = useTimePicker(props, valueComputed);
    const { setItemRef, itemRefs: pickers } = useArrayRefs();
    const activeColumnIndex = ref();
    const focus = (idx = 0) => {
      var _a2;
      (_a2 = pickers.value[idx]) == null ? void 0 : _a2.focus();
    };
    const blur = (idx) => {
      var _a2;
      idx ? (_a2 = pickers.value[idx]) == null ? void 0 : _a2.blur() : pickers.value.forEach((el) => el == null ? void 0 : el.blur());
    };
    const { computedClasses: computedFormClasses } = useFormField("va-time-picker", props);
    const focusNext = () => {
      const nextIndex = ((activeColumnIndex == null ? void 0 : activeColumnIndex.value) || 0) + 1;
      activeColumnIndex.value = nextIndex % columns.value.length;
      focus(activeColumnIndex.value);
    };
    const focusPrev = () => {
      const nextIndex = ((activeColumnIndex == null ? void 0 : activeColumnIndex.value) || 0) - 1 + columns.value.length;
      activeColumnIndex.value = nextIndex % columns.value.length;
      focus(activeColumnIndex.value);
    };
    const computedClasses = computed(() => ({
      ...computedFormClasses,
      "va-time-picker--framed": props.framed
    }));
    const computedStyles = useCSSVariables("va-time-picker", () => {
      const gapHeight = (props.visibleCellsCount - 1) / 2 * props.cellHeight;
      return {
        height: `${props.cellHeight * props.visibleCellsCount}px`,
        "cell-height": `${props.cellHeight}px`,
        "column-gap-height": `${gapHeight}px`
      };
    });
    __expose({
      focus,
      blur,
      focusNext,
      focusPrev
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["va-time-picker", computedClasses.value]),
        style: normalizeStyle(unref(computedStyles))
      }, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(unref(columns), (column, idx) => {
          return openBlock(), createBlock(unref(VaTimePickerColumn), {
            key: idx,
            ref_for: true,
            ref: unref(setItemRef),
            items: column.items,
            tabindex: _ctx.disabled ? -1 : 0,
            "cell-height": _ctx.$props.cellHeight,
            activeItemIndex: column.activeItem.value,
            "onUpdate:activeItemIndex": ($event) => column.activeItem.value = $event,
            onKeydown: [
              _cache[0] || (_cache[0] = withKeys(withModifiers(($event) => focusNext(), ["stop", "prevent"]), ["right"])),
              _cache[1] || (_cache[1] = withKeys(withModifiers(($event) => focusNext(), ["exact", "stop", "prevent"]), ["tab"])),
              _cache[2] || (_cache[2] = withKeys(withModifiers(($event) => focusPrev(), ["stop", "prevent"]), ["left"])),
              _cache[3] || (_cache[3] = withKeys(withModifiers(($event) => focusPrev(), ["shift", "stop", "prevent"]), ["tab"]))
            ],
            onFocus: ($event) => activeColumnIndex.value = idx
          }, null, 8, ["items", "tabindex", "cell-height", "activeItemIndex", "onUpdate:activeItemIndex", "onFocus"]);
        }), 128))
      ], 6);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-time-picker/VaTimePicker.js
var _style_0101 = ':root,\n:host {\n  --va-time-picker-display: inline-flex;\n  --va-time-picker-disabled-opacity: 0.4;\n}\n.va-time-picker {\n  display: var(--va-time-picker-display);\n  justify-content: center;\n  overflow: hidden;\n  height: var(--va-time-picker-height);\n  font-family: var(--va-font-family);\n}\n.va-time-picker--readonly {\n  position: relative;\n}\n.va-time-picker--readonly::after {\n  content: "";\n  position: absolute;\n  height: 100%;\n  width: 100%;\n  z-index: 1;\n}\n.va-time-picker--disabled {\n  position: relative;\n  opacity: var(--va-time-picker-disabled-opacity);\n}\n.va-time-picker--disabled::after {\n  content: "";\n  position: absolute;\n  height: 100%;\n  width: 100%;\n  z-index: 1;\n}\n.va-time-picker--framed {\n  position: relative;\n}\n.va-time-picker--framed::before {\n  content: "";\n  height: var(--va-time-picker-cell-height);\n  width: 100%;\n  position: absolute;\n  top: 50%;\n  left: 0;\n  transform: translateY(-50%);\n  border-top: 1px solid var(--va-divider);\n  border-bottom: 1px solid var(--va-divider);\n  z-index: 0;\n}';
var _VaTimePicker = _export_sfc(_sfc_main108, [["styles", [_style_0101]]]);

// node_modules/vuestic-ui/dist/web-components/src/composables/useLongPresKey.js
function useLongPressKey(el, options) {
  let timeoutId = -1;
  let intervalId = -1;
  const handleMouseDown = (e) => {
    var _a2;
    (_a2 = options.onStart) == null ? void 0 : _a2.call(options, e);
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => {
      intervalId = setInterval(() => {
        var _a22;
        return (_a22 = options.onUpdate) == null ? void 0 : _a22.call(options, e);
      }, options.interval || 100);
    }, unref(options.delay) || 500);
  };
  const handleMouseUp = (e) => {
    var _a2;
    clearTimeout(timeoutId);
    clearInterval(intervalId);
    (_a2 = options.onEnd) == null ? void 0 : _a2.call(options, e);
  };
  const htmlElement = useHTMLElement(el);
  useEvent(["keydown"], handleMouseDown, htmlElement);
  useEvent([
    "keyup",
    "blur"
  ], handleMouseUp, true);
}

// node_modules/vuestic-ui/dist/web-components/src/components/va-time-input/VaTimeInput.vue_vue_type_script_setup_true_lang.js
var VaInputWrapperProps4 = extractComponentProps(VaInputWrapper, ["focused", "maxLength", "counterValue"]);
var _sfc_main109 = defineComponent({
  ...{
    name: "VaTimeInput",
    inheritAttrs: false
  },
  __name: "VaTimeInput",
  props: {
    ...VaInputWrapperProps4,
    ...useDropdownableProps,
    ...useComponentPresetProp,
    ...useClearableProps,
    ...extractComponentProps(_VaTimePicker),
    ...useValidationProps,
    ...useStatefulProps,
    closeOnContentClick: { type: Boolean, default: false },
    offset: { ...useDropdownableProps.offset, default: () => [2, 0] },
    placement: { ...useDropdownableProps.placement, default: "bottom-end" },
    modelValue: { type: Date, default: void 0 },
    clearValue: { type: Date, default: null },
    format: { type: Function },
    parse: { type: Function },
    manualInput: { type: Boolean, default: false },
    leftIcon: { type: Boolean, default: false },
    icon: { type: String, default: "schedule" },
    ariaLabel: { type: String, default: "$t:selectedTime" },
    ariaResetLabel: { type: String, default: "$t:resetTime" },
    ariaToggleDropdownLabel: { type: String, default: "$t:toggleDropdown" }
  },
  emits: [
    ...useFocusEmits,
    ...useValidationEmits,
    ...useClearableEmits,
    ...useStatefulEmits,
    ...useDropdownableEmits,
    "update:modelValue"
  ],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const input = shallowRef();
    const timePicker = shallowRef();
    const { isOpenSync, dropdownProps } = useDropdownable(props, emit, {
      defaultCloseOnValueUpdate: computed(() => Array.isArray(props.view) && props.view.length === 1)
    });
    const { valueComputed } = useStateful(props, emit);
    const { parse: parse2, isValid } = useTimeParser(props);
    const { format } = useTimeFormatter(props);
    const valueText = computed(() => format(valueComputed.value || props.clearValue));
    const doShowDropdown = computed({
      get() {
        if (props.disabled || props.readonly) {
          return false;
        }
        return isOpenSync.value;
      },
      set(v) {
        isOpenSync.value = v;
        if (v) {
          nextTick(() => {
            var _a2;
            return (_a2 = timePicker.value) == null ? void 0 : _a2.focus();
          });
        } else {
          nextTick(() => {
            var _a2;
            return (_a2 = input.value) == null ? void 0 : _a2.focus();
          });
        }
      }
    });
    const { isFocused, focus, blur, onFocus: focusListener, onBlur: blurListener } = useFocus(input);
    const onInputTextChanged = (e) => {
      var _a2;
      if (props.disabled) {
        return;
      }
      const val = (_a2 = e.target) == null ? void 0 : _a2.value;
      if (!val) {
        return reset();
      }
      const v = parse2(val);
      if (isValid.value && v) {
        valueComputed.value = v;
      } else {
        valueComputed.value = void 0;
        isValid.value = true;
      }
    };
    const reset = () => withoutValidation(() => {
      emit("update:modelValue", props.clearValue);
      emit("clear");
      resetValidation();
      hideDropdown();
    });
    const {
      computedError,
      computedErrorMessages,
      listeners,
      validationAriaAttributes,
      withoutValidation,
      resetValidation,
      isDirty
    } = useValidation(props, emit, { reset, focus, value: valueComputed });
    const {
      canBeCleared,
      clearIconProps,
      onFocus,
      onBlur
    } = useClearable(props, valueText);
    const canBeClearedComputed = computed(() => canBeCleared.value && valueText.value !== format(props.clearValue));
    const filteredWrapperProps = filterComponentProps(VaInputWrapperProps4);
    const computedInputWrapperProps = computed(() => ({
      ...filteredWrapperProps.value,
      focused: isFocused.value,
      error: computedError.value,
      errorMessages: computedErrorMessages.value,
      readonly: props.readonly || !props.manualInput,
      modelValue: valueText.value
    }));
    const viewToNumber = {
      seconds: 1e3,
      minutes: 1e3 * 60,
      hours: 1e3 * 60 * 60
    };
    const onKeyPress = (e) => {
      if (!("key" in e)) {
        return;
      }
      if (e.key === "ArrowDown") {
        valueComputed.value = new Date(Number(valueComputed.value) - viewToNumber[props.view]);
        e.preventDefault();
      }
      if (e.key === "ArrowUp") {
        valueComputed.value = new Date(Number(valueComputed.value) + viewToNumber[props.view]);
        e.preventDefault();
      }
    };
    useLongPressKey(input, {
      onStart: onKeyPress,
      onUpdate: onKeyPress
    });
    const computedInputListeners = {
      focus: () => {
        if (props.disabled) {
          return;
        }
        focusListener();
        if (props.readonly) {
          return;
        }
        onFocus();
        listeners.onFocus();
      },
      blur: () => {
        if (props.disabled) {
          return;
        }
        blurListener();
        if (props.readonly) {
          return;
        }
        onBlur();
        listeners.onBlur();
      }
    };
    const slots = useSlots();
    const filteredSlots = computed(() => {
      const slotsWithIcons = [
        props.leftIcon && "prependInner",
        (!props.leftIcon || props.clearable) && "icon"
      ];
      return Object.keys(slots).filter((slot) => !slotsWithIcons.includes(slot));
    });
    const hideDropdown = () => {
      doShowDropdown.value = false;
    };
    const showDropdown = (event, cancel, prevent) => {
      doShowDropdown.value = true;
    };
    const checkProhibitedDropdownOpening = (e) => {
      if (isOpenSync.value) {
        return false;
      }
      if (props.disabled || props.readonly) {
        return true;
      }
      if (e === void 0) {
        return false;
      }
      return props.manualInput && (e == null ? void 0 : e.code) !== "Space";
    };
    const toggleDropdown = (event) => {
      if (checkProhibitedDropdownOpening(event instanceof KeyboardEvent ? event : void 0)) {
        return;
      }
      doShowDropdown.value = !doShowDropdown.value;
    };
    const cursorStyleComputed = computed(() => {
      if (props.disabled) {
        return {};
      }
      if (props.manualInput) {
        return { cursor: "text" };
      }
      return { cursor: "pointer" };
    });
    const iconTabindexComputed = computed(() => {
      if (!props.manualInput) {
        return -1;
      }
      return props.disabled || props.readonly ? -1 : 0;
    });
    const iconProps = computed(() => ({
      role: "button",
      "aria-hidden": false,
      name: props.icon,
      color: "secondary",
      tabindex: iconTabindexComputed.value
    }));
    const { tp } = useTranslation();
    useAttrs();
    const dropdownPropsComputed = computed(() => ({
      ...dropdownProps.value,
      innerAnchorSelector: ".va-input-wrapper__field",
      trigger: ["click", "right-click", "space", "enter"]
    }));
    const timePickerProps = filterComponentProps(extractComponentProps(_VaTimePicker));
    __expose({
      isFocused,
      isValid,
      value: valueComputed,
      isDirty,
      focus,
      blur,
      reset,
      withoutValidation,
      resetValidation,
      toggleDropdown,
      showDropdown,
      hideDropdown
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(VaDropdown), mergeProps({
        modelValue: doShowDropdown.value,
        "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => doShowDropdown.value = $event),
        class: ["va-time-input", _ctx.$attrs.class],
        style: _ctx.$attrs.style
      }, dropdownPropsComputed.value), {
        anchor: withCtx(() => [
          createVNode(unref(VaInputWrapper), mergeProps({
            class: "va-time-input__anchor",
            ref_key: "input",
            ref: input,
            style: cursorStyleComputed.value
          }, computedInputWrapperProps.value, toHandlers(computedInputListeners), { onChange: onInputTextChanged }), createSlots({
            icon: withCtx(() => [
              canBeClearedComputed.value ? (openBlock(), createBlock(unref(VaIcon), mergeProps({
                key: 0,
                class: "va-time-input__clear-button"
              }, { ...iconProps.value, ...unref(clearIconProps) }, {
                "aria-label": unref(tp)(_ctx.$props.ariaResetLabel),
                onClick: withModifiers(reset, ["stop"]),
                onKeydown: [
                  withKeys(withModifiers(reset, ["stop"]), ["enter"]),
                  withKeys(withModifiers(reset, ["stop"]), ["space"])
                ]
              }), null, 16, ["aria-label", "onKeydown"])) : createCommentVNode("", true),
              !_ctx.$props.leftIcon && _ctx.$props.icon ? (openBlock(), createBlock(unref(VaIcon), mergeProps({
                key: 1,
                class: "va-time-input__right-button va-time-input__side-button",
                "aria-label": unref(tp)(_ctx.$props.ariaToggleDropdownLabel)
              }, iconProps.value), null, 16, ["aria-label"])) : createCommentVNode("", true)
            ]),
            _: 2
          }, [
            renderList(filteredSlots.value, (name) => {
              return {
                name,
                fn: withCtx((slotScope) => [
                  renderSlot(_ctx.$slots, name, normalizeProps(guardReactiveProps({ ...slotScope, toggleDropdown, showDropdown, hideDropdown, isOpen: unref(isOpenSync), focus: unref(focus) })))
                ])
              };
            }),
            _ctx.$slots.prependInner || _ctx.$props.leftIcon ? {
              name: "prependInner",
              fn: withCtx((slotScope) => [
                renderSlot(_ctx.$slots, "prependInner", normalizeProps(guardReactiveProps({ ...slotScope, toggleDropdown, showDropdown, hideDropdown, isOpen: unref(isOpenSync), focus: unref(focus) }))),
                _ctx.$props.leftIcon ? (openBlock(), createBlock(unref(VaIcon), mergeProps({
                  key: 0,
                  class: "va-time-input__left-button va-time-input__side-button",
                  "aria-label": unref(tp)(_ctx.$props.ariaToggleDropdownLabel)
                }, iconProps.value), null, 16, ["aria-label"])) : createCommentVNode("", true)
              ]),
              key: "0"
            } : void 0
          ]), 1040, ["style"])
        ]),
        default: withCtx(() => [
          createVNode(unref(VaDropdownContent), {
            "no-padding": "",
            onKeydown: [
              withKeys(withModifiers(hideDropdown, ["prevent"]), ["esc"]),
              withKeys(withModifiers(hideDropdown, ["prevent"]), ["enter"])
            ]
          }, {
            default: withCtx(() => [
              createVNode(_VaTimePicker, mergeProps({
                ref_key: "timePicker",
                ref: timePicker
              }, unref(timePickerProps), {
                modelValue: unref(valueComputed),
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => isRef(valueComputed) ? valueComputed.value = $event : null)
              }), null, 16, ["modelValue"])
            ]),
            _: 1
          }, 8, ["onKeydown"])
        ]),
        _: 3
      }, 16, ["modelValue", "class", "style"]);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-time-input/index.js
var VaTimeInput = withConfigTransport$1(_sfc_main109);

// node_modules/vuestic-ui/dist/web-components/src/components/va-timeline/VaTimeline.js
var _style_0102 = ":root,\n:host {\n  --va-timeline-display: flex;\n  --va-timeline-flex-wrap: nowrap;\n  /* Vertical */\n  --va-timeline-vertical-flex-direction: column;\n  --va-timeline-vertical-padding-left: 0.25rem;\n  --va-timeline-vertical-padding-right: 0.25rem;\n}\n.va-timeline {\n  display: var(--va-timeline-display);\n  flex-wrap: var(--va-timeline-flex-wrap);\n  font-family: var(--va-font-family);\n}\n.va-timeline--vertical {\n  flex-direction: var(--va-timeline-vertical-flex-direction);\n  padding-left: var(--va-timeline-vertical-padding-left);\n  padding-right: var(--va-timeline-vertical-padding-right);\n}\n.va-timeline--align-top .va-timeline-item__before,\n.va-timeline--align-top .va-timeline-item__after {\n  flex: 0;\n}\n.va-timeline .va-timeline-item {\n  flex: 1;\n}\n.va-timeline .va-timeline-item--vertical .va-timeline-separator--vertical .va-timeline-separator__line:first-child {\n  flex: 0 0 1rem;\n}\n.va-timeline .va-timeline-item--vertical.va-timeline-item--is-first .va-timeline-separator--vertical .va-timeline-separator__line:first-child {\n  flex-basis: 2rem;\n}\n.va-timeline .va-timeline-item--vertical.va-timeline-item--is-first .va-timeline-item__after,\n.va-timeline .va-timeline-item--vertical.va-timeline-item--is-first .va-timeline-item__before {\n  padding-top: 2rem;\n}\n.va-timeline .va-timeline-item--vertical.va-timeline-item--vertical.va-timeline-item--is-last .va-timeline-item__after,\n.va-timeline .va-timeline-item--vertical.va-timeline-item--vertical.va-timeline-item--is-last .va-timeline-item__before {\n  padding-bottom: 2rem;\n}";
var getPropsData = (slot) => slot == null ? void 0 : slot.props;
var getIsActive = (slot) => {
  var _a2;
  return !!((_a2 = slot == null ? void 0 : slot.props) == null ? void 0 : _a2.active) || false;
};
var isVueFragment = (slot) => slot.type === Fragment;
var isEmptyArray = (arr) => arr && arr.length === 0;
function getSlots(slots) {
  var _a2;
  const defaultSlots = (_a2 = slots.default) == null ? void 0 : _a2.call(slots);
  if (!defaultSlots || isEmptyArray(defaultSlots)) {
    return [];
  }
  if (isVueFragment(defaultSlots[0])) {
    return defaultSlots[0].children;
  }
  return defaultSlots;
}
var processSlots = (context) => {
  const slots = getSlots(context.slots);
  slots.forEach((slot, index) => {
    if (!getPropsData(slot)) {
      slot.props = {};
    }
    const propsData = getPropsData(slot);
    propsData.vertical = context.props.vertical;
    if (context.props.centered) {
      propsData.inverted = !!(index % 2);
    }
    if (index === 0) {
      propsData.isFirst = true;
    }
    if (index === slots.length - 1) {
      propsData.isLast = true;
    }
    const currentSlotActive = propsData.active;
    if (!currentSlotActive) {
      return;
    }
    if (index === 0) {
      propsData.activePrevious = currentSlotActive;
    }
    if (index === slots.length - 1) {
      propsData.activeNext = currentSlotActive;
    }
    const previousSlotActive = getIsActive(slots[index - 1]);
    if (previousSlotActive) {
      propsData.activePrevious = true;
    }
    const nextSlotActive = getIsActive(slots[index + 1]);
    if (nextSlotActive) {
      propsData.activeNext = true;
    }
  });
  return slots;
};
var COMPONENT_NAME = "va-timeline";
var _sfc_main110 = {
  name: COMPONENT_NAME,
  props: {
    ...useComponentPresetProp,
    vertical: { type: Boolean },
    centered: { type: Boolean },
    alignTop: { type: Boolean }
  },
  setup(props, { slots }) {
    return () => h(
      "div",
      {
        class: {
          [COMPONENT_NAME]: true,
          [`${COMPONENT_NAME}--vertical`]: props.vertical,
          [`${COMPONENT_NAME}--align-top`]: props.alignTop
        }
      },
      processSlots({ props, slots })
    );
  }
};
var _VaTimeline = _export_sfc(_sfc_main110, [["styles", [_style_0102]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-timeline/index.js
var VaTimeline = withConfigTransport$1(_VaTimeline);

// node_modules/vuestic-ui/dist/web-components/src/components/va-timeline/VaTimelineSeparator/VaTimelineSeparator.vue_vue_type_script_lang.js
var componentName = "va-timeline-separator";
var _sfc_main111 = defineComponent({
  name: componentName,
  props: {
    ...useComponentPresetProp,
    color: { type: String, default: "primary" },
    vertical: { type: Boolean },
    active: { type: Boolean },
    activePrevious: { type: Boolean },
    activeNext: { type: Boolean }
  },
  setup(props) {
    const { getColor } = useColors();
    return () => h(
      "div",
      {
        class: {
          [componentName]: true,
          [`${componentName}--vertical`]: props.vertical
        }
      },
      [
        h("div", {
          class: {
            [`${componentName}__line`]: true,
            [`${componentName}__line--active`]: props.activePrevious
          },
          style: {
            backgroundColor: getColor(props.activePrevious ? props.color : "divider")
          }
        }),
        h("div", {
          class: {
            [`${componentName}__center`]: true,
            [`${componentName}__center--active`]: props.active
          },
          style: {
            backgroundColor: getColor(props.active ? props.color : "divider")
          }
        }),
        h("div", {
          class: {
            [`${componentName}__line`]: true,
            [`${componentName}__line--active`]: props.activeNext
          },
          style: {
            backgroundColor: getColor(props.activeNext ? props.color : "divider")
          }
        })
      ]
    );
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-timeline/VaTimelineSeparator/VaTimelineSeparator.js
var _style_0103 = ":root,\n:host {\n  --va-timeline-separator-display: flex;\n  --va-timeline-separator-align-items: center;\n  /* Line */\n  --va-timeline-separator-line-transition: background-color ease 0.5s;\n  --va-timeline-separator-line-width: 0.125rem;\n  --va-timeline-separator-line-height: 0.125rem;\n  --va-timeline-separator-line-flex: 1;\n  /* Center */\n  --va-timeline-separator-center-transition: background-color ease 0.5s;\n  --va-timeline-separator-center-width: 0.5rem;\n  --va-timeline-separator-center-height: 0.5rem;\n  --va-timeline-separator-center-border-radius: 0.5rem;\n  /* Vertical */\n  --va-timeline-separator-vertical-flex-direction: column;\n}\n.va-timeline-separator {\n  display: var(--va-timeline-separator-display);\n  align-items: var(--va-timeline-separator-align-items);\n}\n.va-timeline-separator--vertical {\n  flex-direction: var(--va-timeline-separator-vertical-flex-direction);\n}\n.va-timeline-separator__line {\n  transition: var(--va-timeline-separator-line-transition);\n  width: var(--va-timeline-separator-line-width);\n  height: var(--va-timeline-separator-line-height);\n  flex: var(--va-timeline-separator-line-flex);\n}\n.va-timeline-separator__center {\n  transition: var(--va-timeline-separator-center-transition);\n  width: var(--va-timeline-separator-center-width);\n  height: var(--va-timeline-separator-center-height);\n  border-radius: var(--va-timeline-separator-center-border-radius);\n}";
var _VaTimelineSeparator = _export_sfc(_sfc_main111, [["styles", [_style_0103]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-timeline/VaTimelineSeparator/index.js
var VaTimelineSeparator = withConfigTransport$1(_VaTimelineSeparator);

// node_modules/vuestic-ui/dist/web-components/src/components/va-timeline/VaTimelineItem/VaTimelineItem.vue_vue_type_script_lang.js
var COMPONENT_NAME2 = "va-timeline-item";
var VaTimelineSeparatorProps = extractComponentProps(VaTimelineSeparator);
var _sfc_main112 = defineComponent({
  name: COMPONENT_NAME2,
  props: {
    ...useComponentPresetProp,
    ...VaTimelineSeparatorProps,
    color: { type: String, default: "primary" },
    isFirst: { type: Boolean },
    isLast: { type: Boolean },
    inverted: { type: Boolean }
  },
  setup(props, { slots }) {
    const children = [
      h(
        VaTimelineSeparator,
        { ...filterComponentProps(VaTimelineSeparatorProps).value }
      )
    ];
    const before = props.inverted ? slots.after : slots.before;
    if (before) {
      children.unshift(
        h(
          "div",
          { class: `${COMPONENT_NAME2}__before` },
          before()
        )
      );
    }
    const after = props.inverted ? slots.before : slots.after;
    if (after) {
      children.push(
        h(
          "div",
          { class: `${COMPONENT_NAME2}__after` },
          after()
        )
      );
    }
    return () => h(
      "div",
      {
        class: [
          { [COMPONENT_NAME2]: true },
          { [`${COMPONENT_NAME2}--vertical`]: props.vertical },
          { [`${COMPONENT_NAME2}--is-first`]: props.isFirst },
          { [`${COMPONENT_NAME2}--is-last`]: props.isLast }
        ]
      },
      children
    );
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-timeline/VaTimelineItem/VaTimelineItem.js
var _style_0104 = ":root,\n:host {\n  --va-timeline-item-display: flex;\n  --va-timeline-item-flex-direction: column;\n  --va-timeline-item-vertical-flex-direction: row;\n  --va-timeline-item-vertical-flex-wrap: nowrap;\n  --va-timeline-item-vertical-align-items: stretch;\n  /* Title */\n  --va-timeline-item-title-text-align: center;\n  --va-timeline-item-title-color: var(--va-primary);\n  --va-timeline-item-title-font-weight: 700;\n  --va-timeline-item-title-font-size: 0.8rem;\n  --va-timeline-item-title-text-transform: uppercase;\n  /* Description */\n  --va-timeline-item-description-margin-top: 0.25rem;\n  --va-timeline-item-description-text-align: center;\n}\n.va-timeline-item {\n  display: var(--va-timeline-item-display);\n  flex-direction: var(--va-timeline-item-flex-direction);\n}\n.va-timeline-item__before, .va-timeline-item__after {\n  flex: 1;\n}\n.va-timeline-item--vertical {\n  flex-direction: var(--va-timeline-item-vertical-flex-direction);\n  flex-wrap: var(--va-timeline-item-vertical-flex-wrap);\n  align-items: var(--va-timeline-item-vertical-align-items);\n}\n.va-timeline-item--vertical .va-timeline-item__before,\n.va-timeline-item--vertical .va-timeline-item__after {\n  padding-top: 1rem;\n  padding-bottom: 1rem;\n}\n.va-timeline-item--vertical .va-timeline-item__before {\n  padding-right: 1rem;\n}\n.va-timeline-item--vertical .va-timeline-item__after {\n  padding-left: 1rem;\n}\n.va-timeline-item:not(.va-timeline-item--vertical) .va-timeline-item__before,\n.va-timeline-item:not(.va-timeline-item--vertical) .va-timeline-item__after {\n  padding-right: 1rem;\n  padding-left: 1rem;\n}\n.va-timeline-item:not(.va-timeline-item--vertical) .va-timeline-item__before {\n  padding-bottom: 0.5rem;\n}\n.va-timeline-item:not(.va-timeline-item--vertical) .va-timeline-item__after {\n  padding-top: 0.5rem;\n}";
var _VaTimelineItem = _export_sfc(_sfc_main112, [["styles", [_style_0104]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-timeline/VaTimelineItem/index.js
var VaTimelineItem = withConfigTransport$1(_VaTimelineItem);

// node_modules/vuestic-ui/dist/web-components/src/components/va-time-picker/index.js
var VaTimePicker = withConfigTransport$1(_VaTimePicker);

// node_modules/vuestic-ui/dist/web-components/src/components/va-tree-view/hooks/useTreeHelpers.js
var useTreeViewProps = {
  nodes: {
    type: Array,
    default: []
  },
  stateful: {
    type: Boolean,
    default: true
  },
  selectable: {
    type: Boolean,
    default: false
  },
  selectionType: {
    type: String,
    default: "leaf",
    validator: (v) => ["leaf", "independent"].includes(v)
  },
  valueBy: {
    type: [String, Function],
    default: "id"
  },
  textBy: {
    type: [String, Function],
    default: "label"
  },
  trackBy: {
    type: [String, Function],
    default: "id"
  },
  iconBy: {
    type: [String, Function],
    default: "icon"
  },
  disabledBy: {
    type: [String, Function],
    default: "disabled"
  },
  expandedBy: {
    type: [String, Function],
    default: "expanded"
  },
  checkedBy: {
    type: [String, Function],
    default: "checked"
  },
  childrenBy: {
    type: [String, Function],
    default: "children"
  },
  expandAll: {
    type: Boolean,
    default: false
  },
  expanded: {
    type: Array,
    default: []
  },
  expandNodeBy: {
    type: String,
    default: "leaf"
  },
  filter: {
    type: String,
    default: ""
  },
  filterMethod: {
    type: Function,
    default: void 0
  },
  checked: {
    type: Array,
    default: []
  },
  color: {
    type: String,
    default: "primary"
  }
};
var useTreeViewEmits = ["update:modelValue", "update:checked", "update:expanded", "update:selected"];
var useTreeHelpers = (props) => {
  const isStringOrNumber = (node) => {
    const typeOfNode = typeof node;
    return typeOfNode === "string" || typeOfNode === "number";
  };
  const getNodeProperty = (node, key) => !key || isStringOrNumber(node) ? node : getValueByKey(node, key);
  const getValue2 = (node) => getNodeProperty(node, props.valueBy);
  const getNodeByValue = (value) => {
    if (!props.valueBy) {
      return value;
    }
    return props.nodes.find((node) => value === getValue2(node)) || value;
  };
  const getText = (node) => getNodeProperty(node, props.textBy);
  const getChecked = (node) => getNodeProperty(node, props.checkedBy);
  const getDisabled = (node) => getNodeProperty(node, props.disabledBy);
  const getExpanded = (node) => getNodeProperty(node, props.expandedBy);
  const getTrackBy = (node) => getNodeProperty(node, props.trackBy);
  const getChildren = (node) => getNodeProperty(node, props.childrenBy) ?? [];
  const iterateNodes = (nodes, cb) => {
    nodes.forEach((node) => {
      const children = node.children || [];
      if (children.length) {
        iterateNodes(children, cb);
      }
      cb(node);
    });
  };
  return {
    getText,
    getValue: getValue2,
    getChecked,
    getTrackBy,
    getChildren,
    getDisabled,
    getExpanded,
    iterateNodes,
    getNodeByValue,
    getNodeProperty
  };
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-tree-view/types.js
var TreeViewKey = Symbol("TreeView");

// node_modules/vuestic-ui/dist/web-components/src/components/va-tree-view/hooks/useTreeKeyboardNavigation.js
var useTreeKeyboardNavigation = (props, methods) => {
  const { emit, toggleNode, toggleCheckbox } = methods;
  const isElementExpanded = (currentElement) => (currentElement == null ? void 0 : currentElement.getAttribute("aria-expanded")) === "true";
  const getParentElement = (currentElement) => {
    var _a2;
    return ((_a2 = currentElement == null ? void 0 : currentElement.parentElement) == null ? void 0 : _a2.closest(".va-tree-node")) || null;
  };
  const getPreviousElement = (currentElement) => currentElement == null ? void 0 : currentElement.previousElementSibling;
  const findPreviousElement = (currentElement) => {
    if (!currentElement) {
      return null;
    }
    let previousElement = getPreviousElement(currentElement);
    let lastChildElement = isElementExpanded(previousElement) && getLastChildElement(previousElement);
    if (lastChildElement) {
      do {
        if (isElementExpanded(lastChildElement)) {
          lastChildElement = getLastChildElement(lastChildElement);
          if (lastChildElement) {
            continue;
          } else {
            break;
          }
        } else {
          previousElement = lastChildElement;
          break;
        }
      } while (true);
    }
    if (!previousElement) {
      return getParentElement(currentElement);
    }
    return previousElement;
  };
  const getNextElement = (currentElement) => currentElement == null ? void 0 : currentElement.nextElementSibling;
  const findNextElement = (currentElement) => {
    if (!currentElement) {
      return null;
    }
    let nextElement = getNextElement(currentElement);
    const isCurrentExpanded = isElementExpanded(currentElement);
    if (!nextElement) {
      let parentElement = getParentElement(currentElement);
      do {
        if (!getNextElement(parentElement)) {
          parentElement = getParentElement(parentElement);
          if (!parentElement) {
            break;
          } else {
            continue;
          }
        } else {
          nextElement = getNextElement(parentElement);
          break;
        }
      } while (true);
    }
    if (isCurrentExpanded) {
      return getFirstChildElement(currentElement);
    }
    return nextElement;
  };
  const getFirstChildElement = (currentElement) => {
    var _a2;
    return ((_a2 = currentElement == null ? void 0 : currentElement.querySelector(".va-tree-node-children")) == null ? void 0 : _a2.firstElementChild) || null;
  };
  const getLastChildElement = (currentElement) => {
    var _a2;
    return ((_a2 = currentElement == null ? void 0 : currentElement.querySelector(".va-tree-node-children")) == null ? void 0 : _a2.lastElementChild) || null;
  };
  const onHorizontalMove = (currentElement, dir, node) => {
    var _a2, _b;
    const isCurrentElementExpanded = isElementExpanded(currentElement);
    if (dir === "left") {
      if (isCurrentElementExpanded) {
        toggleNode(node);
      } else {
        (_a2 = getParentElement(currentElement)) == null ? void 0 : _a2.focus();
      }
    } else {
      if (!isCurrentElementExpanded) {
        toggleNode(node);
      } else {
        (_b = getFirstChildElement(currentElement)) == null ? void 0 : _b.focus();
      }
    }
  };
  const onVerticalMove = (currentElement, dir) => {
    var _a2, _b;
    if (dir === "up") {
      (_a2 = findPreviousElement(currentElement)) == null ? void 0 : _a2.focus();
    } else {
      (_b = findNextElement(currentElement)) == null ? void 0 : _b.focus();
    }
  };
  const handleKeyboardNavigation = (event, node) => {
    const currentElement = event.target;
    switch (event.code) {
      case "ArrowUp":
        onVerticalMove(currentElement, "up");
        break;
      case "ArrowRight":
        onHorizontalMove(currentElement, "right", node);
        break;
      case "ArrowDown":
        onVerticalMove(currentElement, "down");
        break;
      case "ArrowLeft":
        onHorizontalMove(currentElement, "left", node);
        break;
      case "Space":
        if (props.selectable) {
          const state = typeof node.checked !== "undefined" ? !node.checked : null;
          toggleCheckbox(node, state);
        } else {
          emit("update:selected", node);
        }
        break;
      case "Escape":
        if (!props.selectable) {
          emit("update:selected", null);
        }
        currentElement.blur();
        break;
      default:
        currentElement.blur();
    }
  };
  return { handleKeyboardNavigation };
};
var useTreeKeyboardNavigation$1 = useTreeKeyboardNavigation;

// node_modules/vuestic-ui/dist/web-components/src/components/va-tree-view/hooks/useTreeView.js
var useTreeView = (props, emit) => {
  const { getColor } = useColors();
  const colorComputed = computed(() => getColor(props.color));
  const isLeafSelectionComputed = computed(() => props.selectionType === "leaf");
  const {
    getText,
    getValue: getValue2,
    getChecked,
    getTrackBy,
    getChildren,
    getDisabled,
    getExpanded,
    iterateNodes,
    getNodeProperty
  } = useTreeHelpers(props);
  const { nodes, expandAll, filter, filterMethod, textBy } = toRefs(props);
  const { valueComputed: expandedList } = useStateful(props, emit, "expanded");
  const { valueComputed: checkedList } = useStateful(props, emit, "checked");
  const selectedNode = ref();
  const selectedNodeComputed = computed({
    get: () => selectedNode.value,
    set: (node) => {
      const value = getValue2(node);
      if (selectedNode.value !== value) {
        selectedNode.value = value;
        emit("update:selected", node);
      }
    }
  });
  const updateModel = (model, values, state) => {
    if (state) {
      model.value = model.value.concat(values).filter((value, idx, self2) => self2.indexOf(value) === idx);
    } else {
      model.value = model.value.filter((v) => !values.includes(v));
    }
  };
  const toggleCheckbox = (node, state) => {
    let stateValue = state === null ? true : state;
    if (state && node.indeterminate) {
      stateValue = false;
    }
    const values = [getValue2(node)];
    if (isLeafSelectionComputed.value && node.hasChildren) {
      const toggleChildren = (nodes2) => {
        nodes2.forEach((node2) => {
          if (node2.disabled) {
            return;
          }
          const children = getChildren(node2);
          if (children.length) {
            toggleChildren(children);
          }
          values.push(getValue2(node2));
        });
      };
      toggleChildren(getChildren(node));
    }
    updateModel(checkedList, values, stateValue);
  };
  const toggleNode = (node) => {
    if (node.hasChildren) {
      updateModel(expandedList, [getValue2(node)], !node.expanded);
    }
  };
  const createNode = ({ node, level, children = [], computedFilterMethod: computedFilterMethod2 }) => {
    var _a2;
    const valueBy = getValue2(node);
    let matchesFilter = true;
    const hasChildren = !!children.length;
    const disabled = getDisabled(node) || false;
    let indeterminate = false;
    let checked = checkedList.value.includes(valueBy) || false;
    if (isLeafSelectionComputed.value && hasChildren) {
      const isAllChildrenChecked = children.every((c) => c.checked);
      checked = isAllChildrenChecked;
      indeterminate = !isAllChildrenChecked && children.some((c) => c.indeterminate || c.checked);
      if (indeterminate) {
        checked = null;
      }
    }
    if (filter.value) {
      matchesFilter = (children == null ? void 0 : children.some((c) => c.matchesFilter)) || ((_a2 = computedFilterMethod2.value) == null ? void 0 : _a2.call(computedFilterMethod2, node, filter.value, textBy.value));
    }
    return {
      ...node,
      level,
      checked,
      children,
      disabled,
      expanded: expandedList.value.includes(valueBy) || false,
      hasChildren,
      matchesFilter,
      indeterminate
    };
  };
  const computedFilterMethod = computed(() => {
    if (filterMethod == null ? void 0 : filterMethod.value) {
      return filterMethod.value;
    }
    return (node, filter2) => getText(node).toLowerCase().includes(filter2.toLowerCase());
  });
  const buildTree = (nodes2, level = 0) => nodes2.map((node) => {
    const treeItemChildren = getChildren(node);
    if (treeItemChildren.length) {
      const children = buildTree(treeItemChildren, level + 1);
      return createNode({ node, level, children, computedFilterMethod });
    }
    return createNode({ node, level, computedFilterMethod });
  });
  const getFilteredNodes = (nodes2) => nodes2.filter((node) => {
    if (node.children) {
      node.children = getFilteredNodes(node.children);
    }
    if (node.children.length === 0) {
      node.hasChildren = false;
    }
    return node.matchesFilter;
  });
  const { handleKeyboardNavigation } = useTreeKeyboardNavigation$1(props, { emit, toggleCheckbox, toggleNode });
  provide(TreeViewKey, {
    selectedNodeComputed,
    colorComputed,
    iconBy: props.iconBy,
    selectable: props.selectable,
    expandNodeBy: props.expandNodeBy,
    getText,
    getValue: getValue2,
    getTrackBy,
    toggleNode,
    toggleCheckbox,
    getNodeProperty,
    handleKeyboardNavigation
  });
  const treeItems = computed(() => buildTree(nodes.value));
  const checkForInitialValues = () => {
    const expandedValues = [];
    const checkedValues = [];
    iterateNodes(nodes.value, (node) => {
      if (expandAll.value) {
        expandedValues.push(getValue2(node));
      } else {
        getExpanded(node) && expandedValues.push(getValue2(node));
      }
      if (getChecked(node)) {
        checkedValues.push(getValue2(node));
      }
    });
    if (expandedValues.length) {
      updateModel(expandedList, expandedValues, true);
    }
    if (checkedValues.length) {
      updateModel(checkedList, checkedValues, true);
    }
  };
  checkForInitialValues();
  return {
    treeItems: computed(() => getFilteredNodes(treeItems.value)),
    getText,
    getTrackBy,
    toggleCheckbox
  };
};
var useTreeView$1 = useTreeView;

// node_modules/vuestic-ui/dist/web-components/src/components/va-tree-view/components/VaTreeNode/VaTreeNode.vue_vue_type_script_setup_true_lang.js
var _hoisted_169 = ["role", "aria-expanded", "aria-disabled", "aria-checked", "tabindex"];
var _hoisted_235 = { class: "va-tree-node-root" };
var _hoisted_322 = {
  key: 2,
  class: "va-tree-node-content__item"
};
var _hoisted_413 = ["aria-hidden"];
var INJECTION_ERROR_MESSAGE5 = "The VaTreeNode component should be used in the context of VaTreeView component";
var _sfc_main113 = defineComponent({
  ...{
    name: "VaTreeNode"
  },
  __name: "VaTreeNode",
  props: {
    node: {
      type: Object,
      required: true
    }
  },
  setup(__props) {
    const props = __props;
    const {
      iconBy,
      selectable,
      expandNodeBy,
      colorComputed,
      selectedNodeComputed,
      getText,
      getTrackBy,
      toggleNode,
      toggleCheckbox,
      getNodeProperty,
      handleKeyboardNavigation
    } = useStrictInject(TreeViewKey, INJECTION_ERROR_MESSAGE5);
    const labelComputed = computed(() => getText(props.node) || "");
    const isExpandedComputed = computed(() => props.node.hasChildren ? !!props.node.expanded : void 0);
    const iconComputed = computed(() => getNodeProperty(props.node, iconBy));
    const roleComputed = computed(() => props.node.hasChildren ? "group" : "treeitem");
    const treeNodeClassComputed = useBem("va-tree-node", () => ({
      disabled: Boolean(props.node.disabled),
      checked: Boolean(props.node.checked),
      hasChildren: Boolean(props.node.hasChildren),
      [`level-${props.node.level}`]: true,
      [`expand-by-${expandNodeBy}`]: true
    }));
    const expandedClassComputed = useBem("va-tree-node-children", () => ({
      expanded: !!isExpandedComputed.value
    }));
    const indentClassComputed = useBem("va-tree-node-content", () => ({
      indent: props.node.hasChildren === false
    }));
    const cursorClassComputed = useBem("va-tree-node-content", () => ({
      clickable: props.node.hasChildren === true && expandNodeBy === "node"
    }));
    const tabIndexComputed = computed(() => props.node.disabled ? -1 : 0);
    const onNodeClick = (type) => {
      const nodeType = expandNodeBy === "node" && type === "leaf" ? "node" : type;
      if (expandNodeBy === nodeType) {
        toggleNode(props.node);
      }
      selectedNodeComputed.value = props.node;
    };
    return (_ctx, _cache) => {
      const _component_va_tree_node = resolveComponent("va-tree-node", true);
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["va-tree-node", unref(treeNodeClassComputed)]),
        role: roleComputed.value,
        "aria-expanded": isExpandedComputed.value,
        "aria-disabled": _ctx.$props.node.disabled,
        "aria-checked": !!_ctx.$props.node.checked,
        tabindex: tabIndexComputed.value,
        onKeydown: [
          _cache[4] || (_cache[4] = withKeys(withModifiers(($event) => unref(handleKeyboardNavigation)($event, _ctx.$props.node), ["stop", "prevent"]), ["up"])),
          _cache[5] || (_cache[5] = withKeys(withModifiers(($event) => unref(handleKeyboardNavigation)($event, _ctx.$props.node), ["stop", "prevent"]), ["right"])),
          _cache[6] || (_cache[6] = withKeys(withModifiers(($event) => unref(handleKeyboardNavigation)($event, _ctx.$props.node), ["stop", "prevent"]), ["down"])),
          _cache[7] || (_cache[7] = withKeys(withModifiers(($event) => unref(handleKeyboardNavigation)($event, _ctx.$props.node), ["stop", "prevent"]), ["left"])),
          _cache[8] || (_cache[8] = withKeys(withModifiers(($event) => unref(handleKeyboardNavigation)($event, _ctx.$props.node), ["stop", "prevent"]), ["space"])),
          _cache[9] || (_cache[9] = withKeys(withModifiers(($event) => unref(handleKeyboardNavigation)($event, _ctx.$props.node), ["stop", "prevent"]), ["esc"]))
        ]
      }, [
        createBaseVNode("div", _hoisted_235, [
          createBaseVNode("div", {
            class: normalizeClass(["va-tree-node-content", unref(indentClassComputed)]),
            onClick: _cache[3] || (_cache[3] = ($event) => onNodeClick("node"))
          }, [
            _ctx.$props.node.hasChildren ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: "va-tree-node-content__item va-tree-node-content__item--leaf",
              onClick: _cache[0] || (_cache[0] = withModifiers(($event) => onNodeClick("leaf"), ["stop"]))
            }, [
              renderSlot(_ctx.$slots, "icon-toggle", normalizeProps(guardReactiveProps(_ctx.$props.node)), () => [
                createVNode(unref(VaIcon), {
                  name: isExpandedComputed.value ? "keyboard_arrow_down" : "keyboard_arrow_right",
                  size: "20px"
                }, null, 8, ["name"])
              ])
            ])) : createCommentVNode("", true),
            unref(selectable) ? (openBlock(), createElementBlock("div", {
              key: 1,
              class: "va-tree-node-content__item",
              onClick: _cache[2] || (_cache[2] = withModifiers(() => {
              }, ["stop"]))
            }, [
              renderSlot(_ctx.$slots, "checkbox", normalizeProps(guardReactiveProps(_ctx.$props.node)), () => [
                createVNode(unref(VaCheckbox), {
                  "model-value": _ctx.$props.node.checked,
                  color: unref(colorComputed),
                  indeterminate: "",
                  "onUpdate:modelValue": _cache[1] || (_cache[1] = (v) => unref(toggleCheckbox)(_ctx.$props.node, v)),
                  class: "va-tree-node__checkbox"
                }, null, 8, ["model-value", "color"])
              ])
            ])) : createCommentVNode("", true),
            iconComputed.value ? (openBlock(), createElementBlock("div", _hoisted_322, [
              renderSlot(_ctx.$slots, "icon", normalizeProps(guardReactiveProps(_ctx.$props.node)), () => [
                createVNode(unref(VaIcon), {
                  name: iconComputed.value,
                  size: "small"
                }, null, 8, ["name"])
              ])
            ])) : createCommentVNode("", true),
            createBaseVNode("div", {
              class: normalizeClass(["va-tree-node-content__body", unref(cursorClassComputed)])
            }, [
              renderSlot(_ctx.$slots, "content", normalizeProps(guardReactiveProps(_ctx.$props.node)), () => [
                createTextVNode(toDisplayString(labelComputed.value), 1)
              ])
            ], 2)
          ], 2)
        ]),
        withDirectives(createBaseVNode("div", {
          "aria-hidden": !_ctx.$props.node.expanded,
          class: normalizeClass(["va-tree-node-children", unref(expandedClassComputed)])
        }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.$props.node.children, (childNode) => {
            return openBlock(), createBlock(_component_va_tree_node, {
              key: unref(getTrackBy)(childNode),
              node: childNode
            }, createSlots({ _: 2 }, [
              renderList(_ctx.$slots, (_, name) => {
                return {
                  name,
                  fn: withCtx((slotScope) => [
                    renderSlot(_ctx.$slots, name, normalizeProps(guardReactiveProps(slotScope)))
                  ])
                };
              })
            ]), 1032, ["node"]);
          }), 128))
        ], 10, _hoisted_413), [
          [vShow, _ctx.$props.node.hasChildren]
        ])
      ], 42, _hoisted_169);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-tree-view/components/VaTreeNode/VaTreeNode.js
var _style_0105 = ':root,\n:host {\n  --va-tree-node-contents-gap: 8px;\n  --va-tree-node-padding: 6px;\n  --va-tree-node-border-radius: 4px;\n  --va-tree-node-indent: 28px;\n  --va-tree-node-content-item-flex: 0 0 var(--va-tree-node-indent);\n  --va-tree-node-content-body-item-flex: 1;\n  --va-tree-node-interactive-bg-opacity: 0.1;\n  --va-tree-node-children-background: linear-gradient(#adb3b9 33%, rgba(255, 255, 255, 0) 0%) 15px/1px 3px repeat-y transparent;\n}\n.va-tree-node-root {\n  display: flex;\n  padding: var(--va-tree-node-padding);\n  position: relative;\n}\n.va-tree-node-root::before {\n  content: "";\n  background-color: var(--va-primary);\n  border-radius: var(--va-tree-node-border-radius);\n  bottom: 0;\n  left: 0;\n  opacity: 0;\n  pointer-events: none;\n  position: absolute;\n  right: 0;\n  top: 0;\n}\n.va-tree-node-root:hover::before {\n  opacity: var(--va-tree-node-interactive-bg-opacity);\n}\n.va-tree-node-content {\n  display: flex;\n  flex-wrap: nowrap;\n  align-items: center;\n  width: 100%;\n}\n.va-tree-node-content__item {\n  flex: var(--va-tree-node-content-item-flex);\n  min-width: var(--va-tree-node-indent);\n  line-height: 1;\n}\n.va-tree-node-content__body {\n  flex: var(--va-tree-node-content-body-item-flex);\n  width: 100%;\n}\n.va-tree-node-content--indent {\n  margin-left: var(--va-tree-node-indent);\n}\n.va-tree-node-content--clickable {\n  cursor: pointer;\n}\n.va-tree-node-children {\n  display: none;\n  background: var(--va-tree-node-children-background);\n  padding-left: var(--va-tree-node-indent);\n  width: 100%;\n}\n.va-tree-node-children--expanded {\n  display: block;\n}\n.va-tree-node__checkbox {\n  --va-checkbox-input-padding: 0;\n}\n.va-tree-node--disabled {\n  cursor: default;\n  opacity: 0.4;\n  pointer-events: none;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n          user-select: none;\n}\n.va-tree-node--disabled .va-tree-node-content__item--leaf {\n  cursor: pointer;\n  pointer-events: all;\n}\n.va-tree-node:focus-visible > .va-tree-node-root {\n  outline: 2px solid var(--va-focus) !important;\n  border-radius: 2px;\n}\n.va-tree-node:focus-visible > .va-tree-node-root::before {\n  opacity: var(--va-tree-node-interactive-bg-opacity);\n}\n.va-tree-node--expand-by-node .va-tree-node-content {\n  cursor: pointer;\n}\n.va-tree-node--expand-by-leaf .va-tree-node-content__item--leaf {\n  cursor: pointer;\n}';
var _VaTreeNode = _export_sfc(_sfc_main113, [["styles", [_style_0105]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-tree-view/components/VaTreeNode/index.js
var VaTreeNode = withConfigTransport$1(_VaTreeNode);

// node_modules/vuestic-ui/dist/web-components/src/components/va-tree-view/VaTreeView.vue_vue_type_script_setup_true_lang.js
var _hoisted_170 = {
  class: "va-tree-view",
  role: "tree"
};
var _sfc_main114 = defineComponent({
  ...{
    name: "VaTreeView"
  },
  __name: "VaTreeView",
  props: { ...useTreeViewProps },
  emits: [...useTreeViewEmits],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const { treeItems, getTrackBy } = useTreeView$1(props, emit);
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_170, [
        _ctx.$props.filter && !unref(treeItems).length ? renderSlot(_ctx.$slots, "not-found", { key: 0 }, () => [
          createTextVNode("No matching nodes found")
        ]) : (openBlock(true), createElementBlock(Fragment, { key: 1 }, renderList(unref(treeItems), (nodeItem) => {
          return openBlock(), createBlock(unref(VaTreeNode), {
            key: unref(getTrackBy)(nodeItem),
            node: nodeItem
          }, createSlots({ _: 2 }, [
            renderList(_ctx.$slots, (_, name) => {
              return {
                name,
                fn: withCtx((slotScope) => [
                  renderSlot(_ctx.$slots, name, normalizeProps(guardReactiveProps(slotScope)))
                ])
              };
            })
          ]), 1032, ["node"]);
        }), 128))
      ]);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-tree-view/VaTreeView.js
var _style_0106 = ":root,\n:host {\n  --va-tree-view-padding: 0.3125rem;\n}\n.va-tree-view {\n  padding: var(--va-tree-view-padding);\n  font-family: var(--va-font-family);\n}";
var _VaTreeView = _export_sfc(_sfc_main114, [["styles", [_style_0106]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-tree-view/index.js
var VaTreeView = withConfigTransport$1(_VaTreeView);

// node_modules/vuestic-ui/dist/web-components/src/components/va-scroll-container/VaScrollContainer.vue_vue_type_script_setup_true_lang.js
var _hoisted_171 = { class: "va-scroll-container" };
var _hoisted_236 = { class: "va-scroll-container__content" };
var _sfc_main115 = defineComponent({
  ...{
    name: "VaScrollContainer"
  },
  __name: "VaScrollContainer",
  props: {
    ...useSizeProps,
    vertical: { type: Boolean, default: false },
    horizontal: { type: Boolean, default: false },
    color: { type: String, default: "secondary" },
    rtl: { type: Boolean, default: false },
    gradient: { type: Boolean, default: false },
    sizesConfig: {
      type: Object,
      default: () => ({
        defaultSize: 4,
        sizes: { small: 4, medium: 6, large: 8 }
      })
    },
    size: {
      type: String,
      default: "small",
      validator: (v) => ["small", "medium", "large"].includes(v)
    }
  },
  setup(__props) {
    useCssVars((_ctx) => ({
      "43e8524c": scrollColor.value,
      "4a92c6ea": scrollbarSize.value,
      "4974584c": overflowX.value,
      "4974584a": overflowY.value,
      "27ee00b3": scrollbarPosition.value
    }));
    const props = __props;
    const { getColor } = useColors();
    const { sizeComputed } = useSize(props);
    const overflowX = computed(() => props.horizontal ? "auto" : "hidden");
    const overflowY = computed(() => props.vertical ? "auto" : "hidden");
    const scrollColor = computed(() => {
      const color = getColor(props.color);
      return props.gradient ? `linear-gradient(0deg, var(--va-scroll-container-scrollbar-gradient-to) 0%, ${color} 100%)` : color;
    });
    const scrollbarSize = computed(() => sizeComputed.value);
    const scrollbarPosition = computed(() => props.rtl ? "rtl" : "ltr");
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_171, [
        createBaseVNode("div", _hoisted_236, [
          renderSlot(_ctx.$slots, "default")
        ])
      ]);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-scroll-container/VaScrollContainer.js
var _style_0107 = ":root {\n  --va-scroll-container-scrollbar-gradient-to: var(--va-background-primary);\n}\n.va-scroll-container {\n  scrollbar-color: var(--43e8524c) transparent;\n  scrollbar-width: thin;\n  transition: scrollbar-color 0.3s ease-in-out;\n  overflow-x: var(--4974584c);\n  overflow-y: var(--4974584a);\n  width: 100%;\n  height: 100%;\n  direction: var(--27ee00b3);\n}\n.va-scroll-container::-webkit-scrollbar {\n  width: var(--4a92c6ea);\n  height: var(--4a92c6ea);\n}\n.va-scroll-container::-webkit-scrollbar-track {\n  box-shadow: none;\n  border-radius: 10px;\n}\n.va-scroll-container::-webkit-scrollbar-thumb {\n  background: var(--43e8524c);\n  opacity: 0.3;\n  border-radius: 2px;\n  -webkit-transition: background 0.3s ease-in-out;\n  transition: background 0.3s ease-in-out;\n}\n.va-scroll-container__content {\n  height: -webkit-fill-available;\n  height: -moz-available;\n  height: stretch;\n  width: -webkit-fill-available;\n  width: -moz-available;\n  width: stretch;\n  direction: ltr;\n}";
var _VaScrollContainer = _export_sfc(_sfc_main115, [["styles", [_style_0107]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-scroll-container/index.js
var VaScrollContainer = withConfigTransport$1(_VaScrollContainer);

// node_modules/vuestic-ui/dist/web-components/src/components/va-viewer/VaViewer.vue_vue_type_script_setup_true_lang.js
var _hoisted_172 = { class: "va-viewer-content" };
var _sfc_main116 = defineComponent({
  ...{
    name: "VaViewer",
    inheritAttrs: false
  },
  __name: "VaViewer",
  setup(__props, { expose: __expose }) {
    const content = ref();
    const controls = ref();
    const isMounted = useIsMounted();
    const isClosed = ref(true);
    const isOpened = computed(() => isMounted.value && !isClosed.value);
    const openViewer = () => isClosed.value = false;
    const closeViewer = () => isClosed.value = true;
    const slots = useSlots();
    const handleAnchorClick = () => {
      if (!slots.anchor) {
        openViewer();
      }
    };
    useClickOutside([content, controls], closeViewer);
    const document2 = useDocument();
    const teleportTarget = computed(() => {
      var _a2;
      return (_a2 = document2.value) == null ? void 0 : _a2.body;
    });
    __expose({
      openViewer,
      closeViewer
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock(Fragment, null, [
        createBaseVNode("div", mergeProps({ class: "va-viewer" }, _ctx.$attrs, { onClick: handleAnchorClick }), [
          renderSlot(_ctx.$slots, "anchor", normalizeProps(guardReactiveProps({ openViewer }))),
          !_ctx.$slots.anchor ? renderSlot(_ctx.$slots, "default", { key: 0 }) : createCommentVNode("", true)
        ], 16),
        isOpened.value ? (openBlock(), createBlock(Teleport, {
          key: 0,
          to: teleportTarget.value
        }, [
          createBaseVNode("div", _hoisted_172, [
            createBaseVNode("div", {
              ref_key: "content",
              ref: content,
              class: "va-viewer-content__main-area"
            }, [
              !_ctx.$slots.image ? renderSlot(_ctx.$slots, "default", { key: 0 }) : createCommentVNode("", true),
              renderSlot(_ctx.$slots, "image")
            ], 512),
            createBaseVNode("div", {
              ref_key: "controls",
              ref: controls,
              class: "va-viewer-content__controls-panel"
            }, [
              renderSlot(_ctx.$slots, "controls"),
              renderSlot(_ctx.$slots, "close", normalizeProps(guardReactiveProps({ close: closeViewer })), () => [
                createBaseVNode("button", {
                  class: "va-viewer-content__close-button",
                  onClick: closeViewer
                }, [
                  createVNode(unref(VaIcon), {
                    name: "close",
                    color: "backgroundPrimary"
                  })
                ])
              ])
            ], 512)
          ])
        ], 8, ["to"])) : createCommentVNode("", true)
      ], 64);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-viewer/VaViewer.js
var _style_0108 = ":root {\n  --va-viewer-content-overlay-background-color: rgba(0, 0, 0, 0.45);\n  --va-viewer-content-overlay-z-index: var(--va-z-index-teleport-overlay);\n  --va-viewer-content-controls-panel-padding: 0.75rem;\n  --va-viewer-content-controls-panel-justify-content: flex-end;\n  --va-viewer-content-controls-panel-background-color: rgba(0, 0, 0, 0.1);\n  --va-viewer-content-controls-panel-z-index: calc(var(--va-z-index-teleport-overlay) + 50);\n}\n.va-viewer {\n  --va-image-position: relative;\n}\n.va-viewer-content {\n  position: fixed;\n  inset: 0;\n  z-index: var(--va-viewer-content-overlay-z-index);\n  display: flex;\n  justify-content: center;\n  background-color: var(--va-viewer-content-overlay-background-color);\n}\n.va-viewer-content__main-area {\n  --va-image-content-position: relative;\n  display: flex;\n}\n.va-viewer-content__main-area > * {\n  width: auto;\n  max-width: unset;\n}\n.va-viewer-content__controls-panel {\n  position: fixed;\n  top: 0;\n  left: 0;\n  right: 0;\n  z-index: var(--va-viewer-content-controls-panel-z-index);\n  display: flex;\n  justify-content: var(--va-viewer-content-controls-panel-justify-content);\n  padding: var(--va-viewer-content-controls-panel-padding);\n  background-color: var(--va-viewer-content-controls-panel-background-color);\n}";
var _VaViewer = _export_sfc(_sfc_main116, [["styles", [_style_0108]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-viewer/index.js
var VaViewer = withConfigTransport$1(_VaViewer);

// node_modules/vuestic-ui/dist/web-components/src/components/va-value/VaValue.vue_vue_type_script_lang.js
var _sfc_main117 = defineComponent({
  name: "VaValue",
  props: {
    defaultValue: { type: null, required: false, default: false }
  },
  setup(props, { slots }) {
    const value = ref(props.defaultValue);
    const slotBind = new Proxy(value, {
      get(target, prop) {
        if (prop === "value") {
          return target.value;
        }
        return target[prop];
      },
      set(target, prop, value2) {
        if (prop === "value") {
          target.value = value2;
        }
        return true;
      }
    });
    return () => {
      return h(Fragment, [renderSlotNodes(slots.default, slotBind)]);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-value/index.js
var VaValue = withConfigTransport$1(_sfc_main117);

// node_modules/vuestic-ui/dist/web-components/src/components/va-textarea/VaTextarea.vue_vue_type_script_setup_true_lang.js
var _hoisted_173 = ["rows", "loading", "ariaLabel"];
var positiveNumberValidator = (val) => {
  if (val > 0 && (val | 0) === val) {
    return true;
  }
  throw new Error(`\`minRows|maxRows\` must be a positive integer greater than 0, but ${val} is provided`);
};
var { createEmits: createEmits2, createListeners: createListeners2 } = useEmitProxy([
  "input",
  "change",
  "click",
  "update:modelValue"
]);
var VaInputWrapperProps5 = extractComponentProps(VaInputWrapper);
var _sfc_main118 = defineComponent({
  ...{
    name: "VaTextarea"
  },
  __name: "VaTextarea",
  props: {
    ...useFormFieldProps,
    ...VaInputWrapperProps5,
    ...useStatefulProps,
    ...useValidationProps,
    modelValue: { type: [String, Number], default: "" },
    placeholder: { type: String },
    autosize: { type: Boolean, default: false },
    minRows: {
      type: [Number, String],
      default: 1,
      validator: positiveNumberValidator
    },
    maxRows: {
      type: [Number, String],
      validator: positiveNumberValidator
    },
    resize: {
      type: Boolean,
      default: true
    },
    clearValue: {
      type: [String],
      default: ""
    }
  },
  emits: [...createEmits2(), ...useValidationEmits],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const textarea = shallowRef();
    const { valueComputed } = useStateful(props, emit, "modelValue", {
      defaultValue: ""
    });
    const focus = () => {
      focusElement(textarea.value);
    };
    const blur = () => {
      blurElement(textarea.value);
    };
    const reset = () => withoutValidation(() => {
      emit("update:modelValue", props.clearValue);
      emit("clear");
      resetValidation();
    });
    const {
      isDirty,
      computedError,
      computedErrorMessages,
      listeners: validationListeners,
      validationAriaAttributes,
      isLoading,
      resetValidation,
      withoutValidation
    } = useValidation(props, emit, {
      value: valueComputed,
      focus,
      reset
    });
    const isResizable = computed(() => {
      return props.resize && !props.autosize;
    });
    const computedRowsCount = computed(() => {
      if (!props.autosize) {
        return void 0;
      }
      const rows = valueComputed.value ? valueComputed.value.toString().split("\n").length : 1;
      if (!props.maxRows) {
        return rows;
      }
      return Math.max(Number(props.minRows), Math.min(rows, Number(props.maxRows)));
    });
    const computedStyle = computed(() => ({
      resize: isResizable.value ? void 0 : "none"
    }));
    const computedProps = computed(() => ({
      ...pick$1(props, ["disabled", "readonly", "placeholder", "ariaLabel"])
    }));
    const vaInputWrapperProps = filterComponentProps(VaInputWrapperProps5);
    const listeners = createListeners2(emit);
    __expose({
      isDirty,
      isLoading,
      computedError,
      computedErrorMessages,
      reset,
      focus,
      blur,
      value: valueComputed,
      withoutValidation,
      resetValidation
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(VaInputWrapper), mergeProps({ class: "va-textarea" }, unref(vaInputWrapperProps), {
        error: unref(computedError),
        "error-messages": unref(computedErrorMessages)
      }), {
        default: withCtx(() => [
          createBaseVNode("div", {
            class: normalizeClass(["va-textarea__resize-wrapper", {
              "va-textarea__resize-wrapper--resizable": isResizable.value
            }])
          }, [
            withDirectives(createBaseVNode("textarea", mergeProps({
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => isRef(valueComputed) ? valueComputed.value = $event : null)
            }, { ...computedProps.value, ...unref(listeners), ...unref(validationAriaAttributes) }, {
              style: computedStyle.value,
              rows: computedRowsCount.value,
              loading: unref(isLoading),
              ref_key: "textarea",
              ref: textarea,
              ariaLabel: _ctx.$props.label,
              class: "va-textarea__textarea",
              onFocus: _cache[1] || (_cache[1] = //@ts-ignore
              (...args) => unref(validationListeners).onFocus && unref(validationListeners).onFocus(...args)),
              onBlur: _cache[2] || (_cache[2] = //@ts-ignore
              (...args) => unref(validationListeners).onBlur && unref(validationListeners).onBlur(...args))
            }), null, 16, _hoisted_173), [
              [vModelText, unref(valueComputed)]
            ])
          ], 2)
        ]),
        _: 1
      }, 16, ["error", "error-messages"]);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-textarea/VaTextarea.js
var _style_0109 = ".va-textarea .va-input-wrapper__field {\n  padding-top: 12px;\n  padding-bottom: 12px;\n  align-items: flex-start;\n}\n.va-textarea__resize-wrapper {\n  display: flex;\n  overflow: hidden;\n  width: 100%;\n  align-self: stretch;\n}\n.va-textarea__resize-wrapper--resizable {\n  resize: vertical;\n}\n.va-textarea__textarea {\n  border: 0;\n  flex: 1;\n  font-family: var(--va-font-family);\n  width: 100%;\n  padding: 1px 0;\n  margin: -1px 0;\n  background: transparent;\n  color: currentColor;\n  box-sizing: content-box;\n  min-height: 1.15rem;\n  outline: none;\n  position: relative;\n  resize: none;\n  scrollbar-color: var(--va-secondary) transparent;\n  scrollbar-width: thin;\n  transition: scrollbar-color 0.3s ease-in-out;\n}\n.va-textarea__textarea::-webkit-scrollbar {\n  width: 4px;\n  height: 4px;\n}\n.va-textarea__textarea::-webkit-scrollbar-track {\n  box-shadow: none;\n  border-radius: 10px;\n}\n.va-textarea__textarea::-webkit-scrollbar-thumb {\n  background: var(--va-secondary);\n  opacity: 0.3;\n  border-radius: 2px;\n  -webkit-transition: background 0.3s ease-in-out;\n  transition: background 0.3s ease-in-out;\n}";
var _VaTextarea = _export_sfc(_sfc_main118, [["styles", [_style_0109]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-textarea/index.js
var VaTextarea = withConfigTransport(_VaTextarea);

// node_modules/vuestic-ui/dist/web-components/src/components/va-menu-list/composables/useMenuKeyboardNavigation.js
var NON_DISABLED_MENU_ITEM_SELECTOR = '[role="menuitem"]:not([aria-disabled="true"])';
var FOCUSED_MENU_ITEM_SELECTOR = '[role="menuitem"]:focus';
var makeMenuItemAttributes = (options) => ({
  role: "menuitem",
  tabindex: -1,
  "aria-disabled": Boolean(options.disabled)
});
var makeMenuContainerAttributes = () => ({
  role: "menu",
  tabindex: 0
});
var useMenuKeyboardNavigation = (container) => {
  useEvent("keydown", ({ key }) => {
    if (!container.value) {
      return;
    }
    const items2 = container.value.querySelectorAll(NON_DISABLED_MENU_ITEM_SELECTOR);
    const focusedItem = container.value.querySelector(FOCUSED_MENU_ITEM_SELECTOR);
    if (!items2.length) {
      return;
    }
    if (!focusedItem) {
      const firstItem = container.value.querySelector(NON_DISABLED_MENU_ITEM_SELECTOR);
      if (firstItem) {
        focusElement(firstItem);
      }
      return;
    }
    if (key === "ArrowDown" || key === "ArrowRight") {
      const focusedElementIndex = Array.from(items2).indexOf(focusedItem);
      focusElement(items2[focusedElementIndex + 1]);
    }
    if (key === "ArrowUp" || key === "ArrowLeft") {
      const focusedElementIndex = Array.from(items2).indexOf(focusedItem);
      focusElement(items2[focusedElementIndex - 1]);
    }
  }, container);
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-menu-list/components/VaMenuItem.vue_vue_type_script_setup_true_lang.js
var _hoisted_174 = { class: "va-menu-item__cell va-menu-item__cell--left" };
var _hoisted_237 = { class: "va-menu-item__cell va-menu-item__cell--center" };
var _hoisted_323 = { class: "va-menu-item__content" };
var _hoisted_414 = { class: "va-menu-item__cell va-menu-item__cell--right" };
var _sfc_main119 = defineComponent({
  ...{
    name: "VaMenuItem"
  },
  __name: "VaMenuItem",
  props: {
    name: { type: String, default: "" },
    icon: { type: String, defatult: "" },
    rightIcon: { type: String, defatult: "" },
    disabled: { type: Boolean, default: false }
  },
  emits: ["selected"],
  setup(__props, { emit: __emit }) {
    const { hasKeyboardFocus, keyboardFocusListeners } = useKeyboardOnlyFocusGlobal();
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("tr", mergeProps({ class: "va-menu-item" }, unref(makeMenuItemAttributes)({ disabled: __props.disabled }), toHandlers(unref(keyboardFocusListeners), true), {
        class: {
          "va-menu-item--disabled": __props.disabled,
          "va-menu-item--keyboard-focus": unref(hasKeyboardFocus)
        },
        onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("selected")),
        onKeydown: _cache[1] || (_cache[1] = withKeys(($event) => _ctx.$emit("selected"), ["enter", "space"]))
      }), [
        createBaseVNode("td", _hoisted_174, [
          renderSlot(_ctx.$slots, "left-icon", {}, () => [
            __props.icon ? (openBlock(), createBlock(unref(VaIcon), {
              key: 0,
              class: "va-menu-item__icon--left",
              name: __props.icon
            }, null, 8, ["name"])) : createCommentVNode("", true)
          ])
        ]),
        createBaseVNode("td", _hoisted_237, [
          renderSlot(_ctx.$slots, "default", {}, () => [
            createBaseVNode("a", _hoisted_323, toDisplayString(__props.name), 1)
          ])
        ]),
        createBaseVNode("td", _hoisted_414, [
          renderSlot(_ctx.$slots, "right-icon", {}, () => [
            __props.rightIcon ? (openBlock(), createBlock(unref(VaIcon), {
              key: 0,
              class: "va-menu-item__icon--right",
              name: __props.rightIcon
            }, null, 8, ["name"])) : createCommentVNode("", true)
          ])
        ])
      ], 16);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-menu-list/components/VaMenuItem.js
var _style_0110 = '.va-menu-item {\n  display: table-row;\n  cursor: pointer;\n  position: relative;\n  z-index: 0;\n}\n.va-menu-item::after {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  content: "";\n  background: var(--va-menu-item-hover-color);\n  opacity: 0;\n  z-index: -1;\n  transition: all 0.3s ease-in-out;\n}\n.va-menu-item__cell {\n  display: table-cell;\n  vertical-align: middle;\n}\n.va-menu-item__cell--center {\n  padding: 0 var(--va-menu-padding-x);\n  text-align: left;\n  width: 100%;\n}\n.va-menu-item__cell--left, .va-menu-item__cell--right {\n  padding: 0 var(--va-menu-padding-x);\n  text-align: center;\n  min-width: 1px;\n  white-space: nowrap;\n}\n.va-menu-item__cell--left:empty, .va-menu-item__cell--right:empty {\n  padding: 0;\n}\n.va-menu-item__cell--left {\n  padding-right: 0;\n}\n.va-menu-item__cell--right {\n  padding-left: 0;\n}\n.va-menu-item:hover::after {\n  background: var(--va-menu-item-hover-color);\n  opacity: var(--va-menu-item-hover-opacity);\n}\n.va-menu-item--disabled {\n  opacity: 0.5;\n  cursor: not-allowed;\n}\n.va-menu-item--keyboard-focus {\n  outline: 2px solid var(--va-focus) !important;\n  border-radius: 2px;\n}';
var _VaMenuItem = _export_sfc(_sfc_main119, [["styles", [_style_0110]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-menu-list/components/VaMenuGroup.vue_vue_type_script_setup_true_lang.js
var _hoisted_175 = {
  class: "va-menu-list__group-name-wrapper",
  colspan: "99999"
};
var _hoisted_238 = { class: "va-menu-list__group-name" };
var _sfc_main120 = defineComponent({
  ...{
    name: "VaMenuGroup"
  },
  __name: "VaMenuGroup",
  props: {
    groupName: {
      type: String,
      required: true
    },
    color: {
      type: String,
      default: "secondary"
    }
  },
  setup(__props) {
    useCssVars((_ctx) => ({
      "4731859b": colorComputed.value
    }));
    const props = __props;
    const { getColor } = useColors();
    const colorComputed = computed(() => getColor(props.color));
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock(Fragment, null, [
        createBaseVNode("div", _hoisted_175, [
          createBaseVNode("span", _hoisted_238, toDisplayString(__props.groupName), 1)
        ]),
        renderSlot(_ctx.$slots, "default", {}, void 0, true)
      ], 64);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-menu-list/components/VaMenuGroup.js
var _style_0111 = ".va-menu-list__group-name-wrapper[data-v-63ae3ce3] {\n  font-size: 9px;\n  font-style: normal;\n  font-weight: 700;\n  letter-spacing: 0.4px;\n  text-transform: uppercase;\n  padding: 0 var(--va-menu-padding-x);\n  overflow: hidden;\n  height: 1rem;\n  position: relative;\n  color: var(--4731859b);\n}\n.va-menu-list__group-name-wrapper .va-menu-list__group-name[data-v-63ae3ce3] {\n  position: absolute;\n  width: 100%;\n  top: 0;\n  left: 0;\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n}";
var _VaMenuGroup = _export_sfc(_sfc_main120, [["styles", [_style_0111]], ["__scopeId", "data-v-63ae3ce3"]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-menu-list/VaMenuList.vue_vue_type_script_setup_true_lang.js
var _hoisted_176 = { colspan: "9999" };
var _sfc_main121 = defineComponent({
  ...{
    name: "VaMenuList"
  },
  __name: "VaMenuList",
  props: {
    ...useSelectableListProps,
    options: { type: Array, default: () => [] }
  },
  emits: ["selected"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const container = ref();
    useMenuKeyboardNavigation(container);
    const { getText, getValue: getValue2, getDisabled, getGroupBy, getTrackBy } = useSelectableList(props);
    const optionGroups = computed(() => props.options.reduce((groups, option) => {
      const groupBy = getGroupBy(option);
      if (!groupBy) {
        groups._noGroup.push(option);
      } else {
        if (!groups[groupBy]) {
          groups[groupBy] = [];
        }
        groups[groupBy].push(option);
      }
      return groups;
    }, { _noGroup: [] }));
    const getUnSlottedVNodes = (nodes) => {
      if (Array.isArray(nodes) && nodes[0].type === Fragment) {
        return nodes[0].children;
      }
      return nodes;
    };
    const getVNodeComponentName = (node) => {
      if (typeof node.type === "object" && "name" in node.type && typeof node.type.name === "string") {
        return node.type.name;
      }
      return "";
    };
    const getVNodeKey = (node) => {
      if (typeof node.type === "string") {
        return node.type;
      }
      if (typeof node.type === "object" && "name" in node.type && typeof node.type.name === "string") {
        return node.type.name;
      }
      return String(node.key);
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("table", mergeProps({
        class: "va-menu-list",
        ref_key: "container",
        ref: container
      }, unref(makeMenuContainerAttributes)()), [
        createBaseVNode("tbody", null, [
          _ctx.$slots.default ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(getUnSlottedVNodes(_ctx.$slots.default()), (child) => {
            return openBlock(), createElementBlock(Fragment, null, [
              getVNodeComponentName(child) === "VaMenuItem" ? (openBlock(), createBlock(resolveDynamicComponent(child), {
                key: getVNodeKey(child) + "menuitem"
              })) : getVNodeComponentName(child) === "VaDropdown" ? (openBlock(), createBlock(resolveDynamicComponent(child), {
                key: getVNodeKey(child) + "menu-dropdown"
              })) : (openBlock(), createElementBlock("td", {
                colspan: "999",
                key: getVNodeKey(child),
                class: "va-menu-list__virtual-td"
              }, [
                (openBlock(), createBlock(resolveDynamicComponent(child)))
              ]))
            ], 64);
          }), 256)) : renderSlot(_ctx.$slots, "default", { key: 1 }, () => [
            (openBlock(true), createElementBlock(Fragment, null, renderList(optionGroups.value, (options, groupName) => {
              return openBlock(), createElementBlock(Fragment, { key: groupName }, [
                groupName !== "_noGroup" ? renderSlot(_ctx.$slots, "group", { key: 0 }, () => [
                  createBaseVNode("tr", null, [
                    createBaseVNode("td", _hoisted_176, [
                      createVNode(_VaMenuGroup, { "group-name": groupName }, null, 8, ["group-name"])
                    ])
                  ])
                ]) : createCommentVNode("", true),
                (openBlock(true), createElementBlock(Fragment, null, renderList(options, (option) => {
                  return openBlock(), createBlock(_VaMenuItem, {
                    key: unref(getTrackBy)(option),
                    name: unref(getText)(option),
                    icon: option.icon,
                    "right-icon": option.rightIcon,
                    disabled: unref(getDisabled)(option),
                    onSelected: ($event) => _ctx.$emit("selected", unref(getValue2)(option), option)
                  }, {
                    "left-icon": withCtx((bind) => [
                      renderSlot(_ctx.$slots, "left-icon", normalizeProps(guardReactiveProps(bind)))
                    ]),
                    "right-icon": withCtx((bind) => [
                      renderSlot(_ctx.$slots, "right-icon", normalizeProps(guardReactiveProps(bind)))
                    ]),
                    _: 2
                  }, 1032, ["name", "icon", "right-icon", "disabled", "onSelected"]);
                }), 128))
              ], 64);
            }), 128))
          ])
        ])
      ], 16);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-menu-list/VaMenuList.js
var _style_0112 = ":root,\n:host {\n  --va-menu-padding-x: 8px;\n  --va-menu-padding-y: 8px;\n  --va-menu-item-hover-color: var(--va-primary);\n  --va-menu-item-hover-opacity: 0.05;\n}\n.va-menu-list {\n  overflow: auto;\n  min-width: 200px;\n  table-layout: fixed;\n  width: -moz-max-content;\n  width: max-content;\n  outline: none;\n}\n.va-menu-list .va-menu-item {\n  display: table-row;\n  vertical-align: unset;\n  line-height: unset;\n}\n.va-menu-list td:not(.va-menu-list__virtual-td) {\n  padding-top: calc(var(--va-menu-padding-y) / 2);\n  padding-bottom: calc(var(--va-menu-padding-y) / 2);\n}\n.va-menu-list__virtual-td:has(tr) {\n  display: table-row-group;\n}\n.va-menu-list .va-divider {\n  margin: 0;\n}";
var _VaMenuList = _export_sfc(_sfc_main121, [["styles", [_style_0112]]]);

// node_modules/vuestic-ui/dist/web-components/src/components/va-menu-list/index.js
var VaMenuList = withConfigTransport(_VaMenuList);
var VaMenuItem = withConfigTransport(_VaMenuItem);
var VaMenuGroup = withConfigTransport(_VaMenuGroup);

// node_modules/vuestic-ui/dist/web-components/src/composables/useImmediateFocus.js
var useImmediateFocus = (el) => {
  watchEffect(() => {
    if (el.value) {
      nextTick(() => {
        focusElement(unwrapEl(el.value));
      });
    }
  });
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-menu/VaMenu.vue_vue_type_script_setup_true_lang.js
var VaMenuListProps = extractComponentProps(VaMenuList);
var VaMenuListEmits = extractComponentEmits(VaMenuList);
var VaDropdownProps4 = extractComponentProps(VaDropdown);
var VaDropdownEmits = extractComponentEmits(VaDropdown);
var _sfc_main122 = defineComponent({
  ...{
    name: "VaMenu"
  },
  __name: "VaMenu",
  props: {
    ...useComponentPresetProp,
    ...VaMenuListProps,
    ...VaDropdownProps4,
    stickToEdges: { type: Boolean, default: true }
  },
  emits: [
    ...VaDropdownEmits,
    ...VaMenuListEmits
  ],
  setup(__props, { expose: __expose, emit: __emit }) {
    const menuList = ref();
    const dropdown = ref();
    useImmediateFocus(menuList);
    const close = () => {
      var _a2;
      (_a2 = dropdown.value) == null ? void 0 : _a2.hide();
      nextTick(() => {
        var _a22;
        const el = unwrapEl((_a22 = dropdown.value) == null ? void 0 : _a22.anchorRef);
        if (el) {
          focusFirstFocusableChild(el);
        }
      });
    };
    const onKeydown = (event) => {
      if (event.key === "Escape") {
        close();
      }
      if (event.key === "ArrowDown" || event.key === "ArrowUp") {
        event.preventDefault();
      }
    };
    const menuListProps = filterComponentProps(VaMenuListProps);
    const dropdownProps = filterComponentProps(VaDropdownProps4);
    __expose({
      close
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(VaDropdown), mergeProps(unref(dropdownProps), {
        ref_key: "dropdown",
        ref: dropdown
      }), {
        anchor: withCtx(() => [
          renderSlot(_ctx.$slots, "anchor")
        ]),
        default: withCtx(() => [
          createVNode(unref(VaDropdownContent), { onKeydown }, {
            default: withCtx(() => [
              createVNode(unref(VaMenuList), mergeProps({
                onKeydown: _cache[0] || (_cache[0] = withKeys(withModifiers(() => {
                }, ["prevent", "stop"]), ["enter", "space"]))
              }, unref(menuListProps), {
                ref_key: "menuList",
                ref: menuList,
                onSelected: _cache[1] || (_cache[1] = ($event) => {
                  _ctx.$emit("selected", $event);
                  close();
                })
              }), createSlots({ _: 2 }, [
                _ctx.$slots.default ? {
                  name: "default",
                  fn: withCtx(() => [
                    renderSlot(_ctx.$slots, "default")
                  ]),
                  key: "0"
                } : void 0
              ]), 1040)
            ]),
            _: 3
          })
        ]),
        _: 3
      }, 16);
    };
  }
});

// node_modules/vuestic-ui/dist/web-components/src/components/va-menu/va-menu.js
var VaMenu = withConfigTransport(_sfc_main122);

// node_modules/vuestic-ui/dist/web-components/src/services/vue-plugin/components.js
var vuesticComponents = Object.freeze(Object.defineProperty({
  __proto__: null,
  VaAccordion,
  VaAffix,
  VaAlert,
  VaAppBar,
  VaAspectRatio,
  VaAvatar,
  VaAvatarGroup,
  VaBacktop,
  VaBadge,
  VaBreadcrumbs,
  VaBreadcrumbsItem,
  VaButton,
  VaButtonDropdown,
  VaButtonGroup,
  VaButtonToggle,
  VaCard,
  VaCardActions,
  VaCardBlock,
  VaCardContent,
  VaCardTitle,
  VaCarousel,
  VaCheckbox,
  VaChip,
  VaCollapse,
  VaColorIndicator,
  VaColorInput,
  VaColorPalette,
  VaConfig: _sfc_main,
  VaContent,
  VaCounter,
  VaDataTable,
  VaDateInput,
  VaDatePicker,
  VaDivider,
  VaDropdown,
  VaDropdownContent,
  VaFallback,
  VaFileUpload,
  VaForm,
  VaHover,
  VaIcon,
  VaImage,
  VaInfiniteScroll,
  VaInnerLoading,
  VaInput,
  VaInputWrapper,
  VaLayout,
  VaList,
  VaListItem,
  VaListItemLabel,
  VaListItemSection,
  VaListLabel,
  VaListSeparator,
  VaMenu,
  VaMenuGroup,
  VaMenuItem,
  VaMenuList,
  VaMessageList,
  VaModal,
  VaNavbar,
  VaNavbarItem,
  VaOptionList,
  VaPagination,
  VaParallax,
  VaPopover,
  VaProgressBar,
  VaProgressCircle,
  VaRadio,
  VaRating,
  VaScrollContainer,
  VaSelect,
  VaSeparator,
  VaSidebar,
  VaSidebarItem,
  VaSidebarItemContent,
  VaSidebarItemTitle,
  VaSkeleton,
  VaSkeletonGroup,
  VaSlider,
  VaSpacer,
  VaSplit,
  VaStepper,
  VaSwitch,
  VaTab,
  VaTabs,
  VaTextarea,
  VaTimeInput,
  VaTimePicker,
  VaTimeline,
  VaTimelineItem,
  VaToast,
  VaTreeView,
  VaValue,
  VaViewer,
  VaVirtualScroller
}, Symbol.toStringTag, { value: "Module" }));

// node_modules/vuestic-ui/dist/web-components/src/services/vue-plugin/utils/use-plugin.js
var isPluginFabric = (plugin) => typeof plugin === "function";
var usePlugin = (app, plugin, ...options) => {
  if (isPluginFabric(plugin)) {
    app.use(plugin(...options));
  } else {
    app.use(plugin);
  }
};

// node_modules/vuestic-ui/dist/web-components/src/services/vue-plugin/create-vuestic/create-vuestic.js
var createVuestic = defineVuesticPlugin((options = {}) => ({
  install(app) {
    const { config } = options;
    setCurrentApp(app);
    Object.entries(vuesticComponents).forEach(([name, component]) => {
      app.component(name, component);
    });
    usePlugin(app, GlobalConfigPlugin(config));
    usePlugin(app, CachePlugin);
    usePlugin(app, ColorConfigPlugin(config));
    usePlugin(app, ColorsClassesPlugin);
    usePlugin(app, BreakpointConfigPlugin);
    usePlugin(app, VaDropdownPlugin);
    usePlugin(app, VaToastPlugin);
    usePlugin(app, VaModalPlugin);
    setCurrentApp(null);
  }
}));

// node_modules/vuestic-ui/dist/web-components/src/services/vue-plugin/create-vuestic/create-vuestic-essential.js
var ESSENTIAL_PLUGIN_NAMES = ["GlobalConfigPlugin", "ColorConfigPlugin"];
var createVuesticEssential = defineVuesticPlugin((options = {}) => ({
  install(app) {
    const { config, components, plugins } = options;
    setCurrentApp(app);
    usePlugin(app, (plugins == null ? void 0 : plugins.GlobalConfigPlugin) || GlobalConfigPlugin, config);
    usePlugin(app, (plugins == null ? void 0 : plugins.CachePlugin) || CachePlugin);
    usePlugin(app, (plugins == null ? void 0 : plugins.ColorConfigPlugin) || ColorConfigPlugin, config);
    if (plugins) {
      Object.entries(plugins).forEach(([name, plugin]) => {
        if (ESSENTIAL_PLUGIN_NAMES.includes(name)) {
          return;
        }
        usePlugin(app, plugin);
      });
    }
    if (components) {
      Object.entries(components).forEach(([name, component]) => {
        app.component(name, component);
      });
    }
    setCurrentApp(null);
  }
}));

// node_modules/vuestic-ui/dist/web-components/src/services/web-components/register-vuestic-web-components-essential.js
var componentsOrder = [
  "VaConfig",
  // VaConfig should be registered before any component, because it provides them config
  "VaForm",
  // VaForm registered before any component, but not before VaConfig
  "VaAccordion",
  "VaFileUpload",
  "VaSidebar",
  "VaTabs"
];
var registerVuesticWebComponentsEssential = (options) => {
  const { css, components } = options;
  Object.entries(components).sort(([nameA], [nameB]) => {
    if (!componentsOrder.includes(nameA) && !componentsOrder.includes(nameB)) {
      return 0;
    }
    let indexA = componentsOrder.indexOf(nameA);
    let indexB = componentsOrder.indexOf(nameB);
    if (indexA === -1) {
      indexA = Number.MAX_SAFE_INTEGER;
    }
    if (indexB === -1) {
      indexB = Number.MAX_SAFE_INTEGER;
    }
    return indexA - indexB;
  }).forEach(([name, component]) => {
    const customElement = defineCustomElement(component);
    if (css && "styles" in component) {
      component.styles.push(css);
    }
    customElements.define(`${kebabCase$1(name)}`, customElement);
  });
};

// node_modules/vuestic-ui/dist/web-components/src/services/web-components/register-vuestic-web-components.js
var defaultCSS = `
.material-icons {
  font-family: 'Material Icons';
  font-weight: normal;
  font-style: normal;
  line-height: 1;
  letter-spacing: normal;
  text-transform: none;
  display: inline-block;
  white-space: nowrap;
  word-wrap: normal;
  direction: ltr;
  -webkit-font-smoothing: antialiased;
}`;
var registerVuesticWebComponents = (options = {}) => {
  const { css = defaultCSS } = options;
  registerVuesticWebComponentsEssential({
    css,
    components: vuesticComponents
  });
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-data-table/fabrics.js
var defineVaDataTableColumns = (columns) => columns;
var defineVaDataTableItems = (items2) => items2;

// node_modules/vuestic-ui/dist/web-components/src/components/va-modal/hooks/useModal.js
var useModal = () => {
  var _a2;
  const appContext = (_a2 = getCurrentInstance()) == null ? void 0 : _a2.appContext;
  if (!appContext) {
    throw new Error("useModal can be used only in setup function. You can use app.config.globalProperties.$vaModal outside setup function");
  }
  const init = (options) => {
    return createModalInstance(options, appContext);
  };
  const confirm = (options) => {
    if (typeof options === "string") {
      return new Promise((resolve, reject) => {
        createModalInstance({
          message: options,
          onOk() {
            resolve(true);
          },
          onCancel() {
            resolve(false);
          }
        }, appContext);
      });
    }
    return new Promise((resolve, reject) => {
      createModalInstance({
        ...options,
        onOk() {
          var _a22;
          (_a22 = options == null ? void 0 : options.onOk) == null ? void 0 : _a22.call(options);
          resolve(true);
        },
        onCancel() {
          var _a22;
          (_a22 = options == null ? void 0 : options.onCancel) == null ? void 0 : _a22.call(options);
          resolve(false);
        }
      }, appContext);
    });
  };
  return { init, confirm };
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-rating/components/VaRatingItem/index.js
var VaRatingItem = withConfigTransport$1(_VaRatingItem);

// node_modules/vuestic-ui/dist/web-components/src/composables/useAppContext.js
var useAppContext = () => {
  const currentInstance = getCurrentInstance();
  return computed(() => {
    var _a2;
    return ((_a2 = getCurrentApp()) == null ? void 0 : _a2._context) || (currentInstance == null ? void 0 : currentInstance.appContext);
  });
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-toast/hooks/useToast.js
var useToast = () => {
  const appContext = useAppContext();
  const createdInThisSetupContext = [];
  const notify = (options) => {
    const id = createToastInstance(options, appContext.value);
    if (id) {
      createdInThisSetupContext.push(id);
    }
    return id;
  };
  const init = (options) => {
    return notify(options);
  };
  const close = (id) => closeById(id);
  const closeAll = (allApps = false) => closeAllNotifications(allApps ? void 0 : appContext.value);
  const closeAllCreatedInThisHook = () => {
    createdInThisSetupContext.forEach((id) => closeById(id));
  };
  return {
    init,
    notify,
    close,
    closeAll,
    closeAllCreatedInThisHook
  };
};

// node_modules/vuestic-ui/dist/web-components/src/composables/useMount.js
var destroy3 = (el, vNode) => {
  if (el) {
    render(null, el);
    el.remove();
  }
  el = null;
};
var mount3 = (component, { props, appContext } = {}) => {
  const el = document == null ? void 0 : document.createElement("div");
  document.body.appendChild(el);
  const vNode = h(component, {
    ...props,
    stateful: (props == null ? void 0 : props.stateful) ?? true
  });
  if (appContext) {
    vNode.appContext = appContext;
  }
  if (el) {
    render(vNode, el);
  }
  return { vNode, el };
};
var useMount = (component) => {
  var _a2;
  const appContext = (_a2 = getCurrentInstance()) == null ? void 0 : _a2.appContext;
  if (!appContext) {
    throw new Error("useMount can be used only in setup function");
  }
  const createInstance2 = (props) => {
    const { vNode, el } = mount3(component, { props, appContext });
    return () => {
      nextTick(() => {
        destroy3(el);
      });
    };
  };
  return {
    createInstance: createInstance2
  };
};

// node_modules/vuestic-ui/dist/web-components/src/components/va-menu/hooks/useMenu.js
var useMenu = () => {
  const { createInstance: createInstance2 } = useMount(VaMenu);
  const instances = [];
  const destroyAll = () => instances.forEach((destroy4) => destroy4());
  const show = (props) => {
    destroyAll();
    props.event.preventDefault();
    const destroy4 = createInstance2({
      ...props,
      anchor: props.event.target,
      cursor: {
        getBoundingClientRect() {
          const resX = props.event.clientX;
          const resY = props.event.clientY;
          return {
            width: 0,
            height: 0,
            x: resX,
            y: resY,
            top: resY,
            right: resX,
            bottom: resY,
            left: resX
          };
        },
        contextElement: props.event.target
      },
      stateful: true,
      modelValue: true,
      preset: "context",
      onBeforeUnmount: () => {
        destroy4();
      }
    });
    instances.push(destroy4);
    return () => {
      destroy4();
      instances.splice(instances.indexOf(destroy4), 1);
    };
  };
  onBeforeUnmount(destroyAll);
  return {
    show
  };
};
export {
  BreakpointConfigPlugin,
  CachePlugin,
  ColorConfigPlugin,
  ColorsClassesPlugin,
  GlobalConfigPlugin,
  TabsViewKey,
  VaAccordion,
  VaAffix,
  VaAlert,
  VaAppBar,
  VaAspectRatio,
  VaAvatar,
  VaAvatarGroup,
  VaBacktop,
  VaBadge,
  VaBreadcrumbs,
  VaBreadcrumbsItem,
  VaButton,
  VaButtonDropdown,
  VaButtonGroup,
  VaButtonToggle,
  VaCard,
  VaCardActions,
  VaCardBlock,
  VaCardContent,
  VaCardTitle,
  VaCarousel,
  VaCheckbox,
  VaChip,
  VaCollapse,
  VaColorIndicator,
  VaColorInput,
  VaColorPalette,
  _sfc_main as VaConfig,
  VaContent,
  VaCounter,
  VaDataTable,
  VaDateInput,
  VaDatePicker,
  VaDivider,
  VaDropdown,
  VaDropdownContent,
  VaDropdownPlugin,
  VaFallback,
  VaFileUpload,
  VaFileUploadGalleryItem,
  VaFileUploadKey,
  VaFileUploadList,
  VaFileUploadListItem,
  VaFileUploadSingleItem,
  VaFileUploadUndo,
  VaForm,
  VaHover,
  VaIcon,
  VaImage,
  VaInfiniteScroll,
  VaInnerLoading,
  VaInput,
  VaInputWrapper,
  VaLayout,
  VaList,
  VaListItem,
  VaListItemLabel,
  VaListItemSection,
  VaListLabel,
  VaListSeparator,
  VaMenu,
  VaMenuGroup,
  VaMenuItem,
  VaMenuList,
  VaMessageList,
  VaMessageListWrapper,
  VaModal,
  VaModalPlugin,
  VaNavbar,
  VaNavbarItem,
  VaOptionList,
  VaPagination,
  VaParallax,
  VaPopover,
  VaProgressBar,
  VaProgressCircle,
  VaRadio,
  VaRating,
  VaRatingItem,
  VaScrollContainer,
  VaSelect,
  VaSelectOption,
  VaSelectOptionList,
  VaSeparator,
  VaSidebar,
  VaSidebarItem,
  VaSidebarItemContent,
  VaSidebarItemTitle,
  VaSkeleton,
  VaSkeletonGroup,
  VaSlider,
  VaSpacer,
  VaSplit,
  VaStepper,
  VaSwitch,
  VaTab,
  VaTabs,
  VaTextarea,
  VaTimeInput,
  VaTimePicker,
  VaTimeline,
  VaTimelineItem,
  VaTimelineSeparator,
  VaToast,
  VaToastPlugin,
  VaTreeView,
  VaValue,
  VaViewer,
  VaVirtualScroller,
  VuesticIconAliases,
  VuesticIconFonts,
  presets as colorsPreset,
  createIconsConfig,
  createVuestic,
  createVuesticEssential,
  defineVaDataTableColumns,
  defineVaDataTableItems,
  defineVaStepperSteps,
  defineVuesticConfig,
  registerVuesticWebComponents,
  registerVuesticWebComponentsEssential,
  defaultThresholds as thresholdsPreset,
  useBreakpoint,
  useColors,
  useElementTextColor,
  useForm,
  useGlobalConfig,
  useI18nConfig,
  useIcon as useIcons,
  useMenu,
  useModal,
  useToast
};
//# sourceMappingURL=vuestic-ui_web-components.js.map
